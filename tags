!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
-format	Makefile	/^	git archive --format=tar --prefix="haproxy-$(VERSION)\/" HEAD | gzip -9 > haproxy-$(VERSION)$(SUBVERS).tar.gz$/;"	m
ABORT_NOW	include/common/debug.h	42;"	d
ACCEPT_FIELD	contrib/halog/halog.c	28;"	d	file:
ACCESS_LVL_ADMIN	include/types/global.h	61;"	d
ACCESS_LVL_NONE	include/types/global.h	58;"	d
ACCESS_LVL_OPER	include/types/global.h	60;"	d
ACCESS_LVL_USER	include/types/global.h	59;"	d
ACL_COND_IF	include/types/acl.h	/^	ACL_COND_IF,		\/* positive condition (after 'if') *\/$/;"	e	enum:__anon43
ACL_COND_NONE	include/types/acl.h	/^	ACL_COND_NONE,		\/* no polarity set yet *\/$/;"	e	enum:__anon43
ACL_COND_UNLESS	include/types/acl.h	/^	ACL_COND_UNLESS,	\/* negative condition (after 'unless') *\/$/;"	e	enum:__anon43
ACL_DIR_MASK	include/types/acl.h	/^	ACL_DIR_MASK = (ACL_DIR_REQ | ACL_DIR_RTR),$/;"	e	enum:__anon45
ACL_DIR_REQ	include/types/acl.h	/^	ACL_DIR_REQ = 0,        \/* ACL evaluated on request *\/$/;"	e	enum:__anon45
ACL_DIR_RTR	include/types/acl.h	/^	ACL_DIR_RTR = (1 << 0), \/* ACL evaluated on response *\/$/;"	e	enum:__anon45
ACL_HOOK_REQ_BE_HTTP_IN	include/types/acl.h	/^	ACL_HOOK_REQ_BE_HTTP_IN,$/;"	e	enum:__anon48
ACL_HOOK_REQ_BE_HTTP_OUT	include/types/acl.h	/^	ACL_HOOK_REQ_BE_HTTP_OUT,$/;"	e	enum:__anon48
ACL_HOOK_REQ_BE_SWITCH	include/types/acl.h	/^	ACL_HOOK_REQ_BE_SWITCH,$/;"	e	enum:__anon48
ACL_HOOK_REQ_BE_TCP_CONTENT	include/types/acl.h	/^	ACL_HOOK_REQ_BE_TCP_CONTENT,$/;"	e	enum:__anon48
ACL_HOOK_REQ_FE_HTTP_IN	include/types/acl.h	/^	ACL_HOOK_REQ_FE_HTTP_IN,$/;"	e	enum:__anon48
ACL_HOOK_REQ_FE_HTTP_OUT	include/types/acl.h	/^	ACL_HOOK_REQ_FE_HTTP_OUT,$/;"	e	enum:__anon48
ACL_HOOK_REQ_FE_SWITCH	include/types/acl.h	/^	ACL_HOOK_REQ_FE_SWITCH,$/;"	e	enum:__anon48
ACL_HOOK_REQ_FE_TCP	include/types/acl.h	/^	ACL_HOOK_REQ_FE_TCP = 0,$/;"	e	enum:__anon48
ACL_HOOK_REQ_FE_TCP_CONTENT	include/types/acl.h	/^	ACL_HOOK_REQ_FE_TCP_CONTENT,$/;"	e	enum:__anon48
ACL_HOOK_RTR_BE_HTTP_IN	include/types/acl.h	/^	ACL_HOOK_RTR_BE_HTTP_IN,$/;"	e	enum:__anon48
ACL_HOOK_RTR_BE_HTTP_OUT	include/types/acl.h	/^	ACL_HOOK_RTR_BE_HTTP_OUT,$/;"	e	enum:__anon48
ACL_HOOK_RTR_BE_TCP_CONTENT	include/types/acl.h	/^	ACL_HOOK_RTR_BE_TCP_CONTENT,$/;"	e	enum:__anon48
ACL_HOOK_RTR_FE_HTTP_IN	include/types/acl.h	/^	ACL_HOOK_RTR_FE_HTTP_IN,$/;"	e	enum:__anon48
ACL_HOOK_RTR_FE_HTTP_OUT	include/types/acl.h	/^	ACL_HOOK_RTR_FE_HTTP_OUT,$/;"	e	enum:__anon48
ACL_HOOK_RTR_FE_TCP_CONTENT	include/types/acl.h	/^	ACL_HOOK_RTR_FE_TCP_CONTENT,$/;"	e	enum:__anon48
ACL_MAY_LOOKUP	include/types/acl.h	/^	ACL_MAY_LOOKUP          =  1 << 31,  \/* exact pattern lookup *\/$/;"	e	enum:__anon47
ACL_PARTIAL	include/types/acl.h	/^	ACL_PARTIAL = (1 << 1), \/* partial data, return MISS if data are missing *\/$/;"	e	enum:__anon45
ACL_PAT_FAIL	include/types/acl.h	/^	ACL_PAT_FAIL = 0,           \/* test failed *\/$/;"	e	enum:__anon42
ACL_PAT_F_FROM_FILE	include/types/acl.h	/^	ACL_PAT_F_FROM_FILE   = 1 << 1,       \/* pattern comes from a file *\/$/;"	e	enum:__anon46
ACL_PAT_F_IGNORE_CASE	include/types/acl.h	/^	ACL_PAT_F_IGNORE_CASE = 1 << 0,       \/* ignore case *\/$/;"	e	enum:__anon46
ACL_PAT_F_TREE	include/types/acl.h	/^	ACL_PAT_F_TREE        = 1 << 3,       \/* some patterns are arranged in a tree *\/$/;"	e	enum:__anon46
ACL_PAT_F_TREE_OK	include/types/acl.h	/^	ACL_PAT_F_TREE_OK     = 1 << 2,       \/* the pattern parser is allowed to build a tree *\/$/;"	e	enum:__anon46
ACL_PAT_MISS	include/types/acl.h	/^	ACL_PAT_MISS = 1,           \/* test may pass with more info *\/$/;"	e	enum:__anon42
ACL_PAT_PASS	include/types/acl.h	/^	ACL_PAT_PASS = 3,           \/* test passed *\/$/;"	e	enum:__anon42
ACL_TEST_F_FETCH_MORE	include/types/acl.h	/^	ACL_TEST_F_FETCH_MORE = 1 << 7, \/* if test does not match, retry with next entry (for multi-match) *\/$/;"	e	enum:__anon44
ACL_TEST_F_MAY_CHANGE	include/types/acl.h	/^	ACL_TEST_F_MAY_CHANGE = 1 << 8, \/* if test does not match, retry later (eg: request size) *\/$/;"	e	enum:__anon44
ACL_TEST_F_MUST_FREE	include/types/acl.h	/^	ACL_TEST_F_MUST_FREE  = 1 << 1, \/* test data must be freed after end of evaluation *\/$/;"	e	enum:__anon44
ACL_TEST_F_NULL_MATCH	include/types/acl.h	/^	ACL_TEST_F_NULL_MATCH = 1 << 11,\/* call expr->kw->match with NULL pattern if expr->patterns is empty *\/$/;"	e	enum:__anon44
ACL_TEST_F_READ_ONLY	include/types/acl.h	/^	ACL_TEST_F_READ_ONLY  = 1 << 0, \/* test data are read-only *\/$/;"	e	enum:__anon44
ACL_TEST_F_RES_PASS	include/types/acl.h	/^	ACL_TEST_F_RES_PASS   = 1 << 10,\/* with SET_RESULT, sets result to PASS (defaults to FAIL) *\/$/;"	e	enum:__anon44
ACL_TEST_F_RES_SET	include/types/acl.h	/^	ACL_TEST_F_RES_SET    = 1 << 9, \/* for fetch() function to assign the result without calling match() *\/$/;"	e	enum:__anon44
ACL_TEST_F_SET_RES_FAIL	include/types/acl.h	/^	ACL_TEST_F_SET_RES_FAIL = (ACL_TEST_F_RES_SET),                      \/* sets result to FAIL *\/$/;"	e	enum:__anon44
ACL_TEST_F_SET_RES_PASS	include/types/acl.h	/^	ACL_TEST_F_SET_RES_PASS = (ACL_TEST_F_RES_SET|ACL_TEST_F_RES_PASS),  \/* sets result to PASS *\/$/;"	e	enum:__anon44
ACL_TEST_F_VOLATILE	include/types/acl.h	/^	ACL_TEST_F_VOLATILE   = (1<<2)|(1<<3)|(1<<4)|(1<<5)|(1<<6),$/;"	e	enum:__anon44
ACL_TEST_F_VOL_1ST	include/types/acl.h	/^	ACL_TEST_F_VOL_1ST    = 1 << 4, \/* result sensitive to changes in first line (eg: URI) *\/$/;"	e	enum:__anon44
ACL_TEST_F_VOL_HDR	include/types/acl.h	/^	ACL_TEST_F_VOL_HDR    = 1 << 3, \/* result sensitive to changes in headers *\/$/;"	e	enum:__anon44
ACL_TEST_F_VOL_SESS	include/types/acl.h	/^	ACL_TEST_F_VOL_SESS   = 1 << 6, \/* result sensitive to new session (eg: IP) *\/$/;"	e	enum:__anon44
ACL_TEST_F_VOL_TEST	include/types/acl.h	/^	ACL_TEST_F_VOL_TEST   = 1 << 2, \/* result must not survive longer than the test (eg: time) *\/$/;"	e	enum:__anon44
ACL_TEST_F_VOL_TXN	include/types/acl.h	/^	ACL_TEST_F_VOL_TXN    = 1 << 5, \/* result sensitive to new transaction (eg: persist) *\/$/;"	e	enum:__anon44
ACL_USE_HDR_ANY	include/types/acl.h	/^	ACL_USE_HDR_ANY = (ACL_USE_HDR_CACHEABLE | ACL_USE_HDR_VOLATILE),$/;"	e	enum:__anon47
ACL_USE_HDR_CACHEABLE	include/types/acl.h	/^	ACL_USE_HDR_CACHEABLE   = 1 << 21,      \/* cacheable request or response header (eg: content-length) *\/$/;"	e	enum:__anon47
ACL_USE_HDR_VOLATILE	include/types/acl.h	/^	ACL_USE_HDR_VOLATILE    = 1 << 22,      \/* volatile  request or response header (eg: cookie) *\/$/;"	e	enum:__anon47
ACL_USE_L4REQ_ANY	include/types/acl.h	/^	ACL_USE_L4REQ_ANY       = (ACL_USE_L4REQ_PERMANENT | ACL_USE_L4REQ_CACHEABLE | ACL_USE_L4REQ_VOLATILE),$/;"	e	enum:__anon47
ACL_USE_L4REQ_CACHEABLE	include/types/acl.h	/^	ACL_USE_L4REQ_CACHEABLE = 1 << 10,      \/* cacheable layer4 request data (eg: length) *\/$/;"	e	enum:__anon47
ACL_USE_L4REQ_PERMANENT	include/types/acl.h	/^	ACL_USE_L4REQ_PERMANENT = 1 <<  9,      \/* unchanged layer4 request data *\/$/;"	e	enum:__anon47
ACL_USE_L4REQ_VOLATILE	include/types/acl.h	/^	ACL_USE_L4REQ_VOLATILE  = 1 << 11,      \/* volatile  layer4 request data (eg: contents) *\/$/;"	e	enum:__anon47
ACL_USE_L4RTR_ANY	include/types/acl.h	/^	ACL_USE_L4RTR_ANY       = (ACL_USE_L4RTR_PERMANENT | ACL_USE_L4RTR_CACHEABLE | ACL_USE_L4RTR_VOLATILE),$/;"	e	enum:__anon47
ACL_USE_L4RTR_CACHEABLE	include/types/acl.h	/^	ACL_USE_L4RTR_CACHEABLE = 1 << 13,      \/* cacheable layer4 response data (eg: length) *\/$/;"	e	enum:__anon47
ACL_USE_L4RTR_PERMANENT	include/types/acl.h	/^	ACL_USE_L4RTR_PERMANENT = 1 << 12,      \/* unchanged layer4 response data *\/$/;"	e	enum:__anon47
ACL_USE_L4RTR_VOLATILE	include/types/acl.h	/^	ACL_USE_L4RTR_VOLATILE  = 1 << 14,      \/* volatile  layer4 response data (eg: contents) *\/$/;"	e	enum:__anon47
ACL_USE_L4_ANY	include/types/acl.h	/^	ACL_USE_L4_ANY          = (ACL_USE_L4REQ_ANY | ACL_USE_L4RTR_ANY),$/;"	e	enum:__anon47
ACL_USE_L7REQ_ANY	include/types/acl.h	/^	ACL_USE_L7REQ_ANY       = (ACL_USE_L7REQ_PERMANENT | ACL_USE_L7REQ_CACHEABLE | ACL_USE_L7REQ_VOLATILE),$/;"	e	enum:__anon47
ACL_USE_L7REQ_CACHEABLE	include/types/acl.h	/^	ACL_USE_L7REQ_CACHEABLE = 1 << 16,      \/* cacheable layer7 request data (eg: content-length) *\/$/;"	e	enum:__anon47
ACL_USE_L7REQ_PERMANENT	include/types/acl.h	/^	ACL_USE_L7REQ_PERMANENT = 1 << 15,      \/* unchanged layer7 request data (eg: method) *\/$/;"	e	enum:__anon47
ACL_USE_L7REQ_VOLATILE	include/types/acl.h	/^	ACL_USE_L7REQ_VOLATILE  = 1 << 17,      \/* volatile  layer7 request data (eg: cookie) *\/$/;"	e	enum:__anon47
ACL_USE_L7RTR_ANY	include/types/acl.h	/^	ACL_USE_L7RTR_ANY       = (ACL_USE_L7RTR_PERMANENT | ACL_USE_L7RTR_CACHEABLE | ACL_USE_L7RTR_VOLATILE),$/;"	e	enum:__anon47
ACL_USE_L7RTR_CACHEABLE	include/types/acl.h	/^	ACL_USE_L7RTR_CACHEABLE = 1 << 19,      \/* cacheable layer7 response data (eg: content-length) *\/$/;"	e	enum:__anon47
ACL_USE_L7RTR_PERMANENT	include/types/acl.h	/^	ACL_USE_L7RTR_PERMANENT = 1 << 18,      \/* unchanged layer7 response data (eg: status) *\/$/;"	e	enum:__anon47
ACL_USE_L7RTR_VOLATILE	include/types/acl.h	/^	ACL_USE_L7RTR_VOLATILE  = 1 << 20,      \/* volatile  layer7 response data (eg: cookie) *\/$/;"	e	enum:__anon47
ACL_USE_L7_ANY	include/types/acl.h	/^	ACL_USE_L7_ANY          = (ACL_USE_L7REQ_ANY | ACL_USE_L7RTR_ANY | ACL_USE_HDR_ANY),$/;"	e	enum:__anon47
ACL_USE_NOTHING	include/types/acl.h	/^	ACL_USE_NOTHING         = 0,            \/* no need for anything beyond internal information *\/$/;"	e	enum:__anon47
ACL_USE_REQ_CACHEABLE	include/types/acl.h	/^	ACL_USE_REQ_CACHEABLE   = (ACL_USE_TCP4_CACHEABLE | ACL_USE_TCP6_CACHEABLE | ACL_USE_TCP_CACHEABLE |$/;"	e	enum:__anon47
ACL_USE_REQ_PERMANENT	include/types/acl.h	/^	ACL_USE_REQ_PERMANENT   = (ACL_USE_TCP4_PERMANENT | ACL_USE_TCP6_PERMANENT | ACL_USE_TCP_PERMANENT |$/;"	e	enum:__anon47
ACL_USE_REQ_VOLATILE	include/types/acl.h	/^	ACL_USE_REQ_VOLATILE    = (ACL_USE_TCP4_VOLATILE | ACL_USE_TCP6_VOLATILE | ACL_USE_TCP_VOLATILE |$/;"	e	enum:__anon47
ACL_USE_RTR_ANY	include/types/acl.h	/^	ACL_USE_RTR_ANY         = (ACL_USE_L4RTR_ANY | ACL_USE_L7RTR_ANY),$/;"	e	enum:__anon47
ACL_USE_TCP4_ANY	include/types/acl.h	/^	ACL_USE_TCP4_ANY        = (ACL_USE_TCP4_PERMANENT | ACL_USE_TCP4_CACHEABLE | ACL_USE_TCP4_VOLATILE),$/;"	e	enum:__anon47
ACL_USE_TCP4_CACHEABLE	include/types/acl.h	/^	ACL_USE_TCP4_CACHEABLE  = 1 <<  1,      \/* cacheable TCPv4 data (eg: src conns) *\/$/;"	e	enum:__anon47
ACL_USE_TCP4_PERMANENT	include/types/acl.h	/^	ACL_USE_TCP4_PERMANENT  = 1 <<  0,      \/* unchanged TCPv4 data (eg: source IP) *\/$/;"	e	enum:__anon47
ACL_USE_TCP4_VOLATILE	include/types/acl.h	/^	ACL_USE_TCP4_VOLATILE   = 1 <<  2,      \/* volatile  TCPv4 data (eg: RTT) *\/$/;"	e	enum:__anon47
ACL_USE_TCP6_ANY	include/types/acl.h	/^	ACL_USE_TCP6_ANY        = (ACL_USE_TCP6_PERMANENT | ACL_USE_TCP6_CACHEABLE | ACL_USE_TCP6_VOLATILE),$/;"	e	enum:__anon47
ACL_USE_TCP6_CACHEABLE	include/types/acl.h	/^	ACL_USE_TCP6_CACHEABLE  = 1 <<  4,      \/* cacheable TCPv6 data (eg: src conns) *\/$/;"	e	enum:__anon47
ACL_USE_TCP6_PERMANENT	include/types/acl.h	/^	ACL_USE_TCP6_PERMANENT  = 1 <<  3,      \/* unchanged TCPv6 data (eg: source IP) *\/$/;"	e	enum:__anon47
ACL_USE_TCP6_VOLATILE	include/types/acl.h	/^	ACL_USE_TCP6_VOLATILE   = 1 <<  5,      \/* volatile  TCPv6 data (eg: RTT) *\/$/;"	e	enum:__anon47
ACL_USE_TCP_ANY	include/types/acl.h	/^	ACL_USE_TCP_ANY         = (ACL_USE_TCP_PERMANENT | ACL_USE_TCP_CACHEABLE | ACL_USE_TCP_VOLATILE),$/;"	e	enum:__anon47
ACL_USE_TCP_CACHEABLE	include/types/acl.h	/^	ACL_USE_TCP_CACHEABLE   = 1 <<  7,      \/* cacheable TCPv4\/v6 data (eg: src conns) *\/$/;"	e	enum:__anon47
ACL_USE_TCP_PERMANENT	include/types/acl.h	/^	ACL_USE_TCP_PERMANENT   = 1 <<  6,      \/* unchanged TCPv4\/v6 data (eg: source IP) *\/$/;"	e	enum:__anon47
ACL_USE_TCP_VOLATILE	include/types/acl.h	/^	ACL_USE_TCP_VOLATILE    = 1 <<  8,      \/* volatile  TCPv4\/v6 data (eg: RTT) *\/$/;"	e	enum:__anon47
ACT_ALLOW	include/common/regex.h	35;"	d
ACT_DENY	include/common/regex.h	38;"	d
ACT_PASS	include/common/regex.h	39;"	d
ACT_REMOVE	include/common/regex.h	37;"	d
ACT_REPLACE	include/common/regex.h	36;"	d
ACT_SETBE	include/common/regex.h	41;"	d
ACT_TARPIT	include/common/regex.h	40;"	d
ADDINC	Makefile	/^ADDINC =$/;"	m
ADDLIB	Makefile	/^ADDLIB =$/;"	m
AN_REQ_HTTP_BODY	include/types/buffers.h	144;"	d
AN_REQ_HTTP_INNER	include/types/buffers.h	142;"	d
AN_REQ_HTTP_PROCESS_BE	include/types/buffers.h	141;"	d
AN_REQ_HTTP_PROCESS_FE	include/types/buffers.h	139;"	d
AN_REQ_HTTP_TARPIT	include/types/buffers.h	143;"	d
AN_REQ_HTTP_XFER_BODY	include/types/buffers.h	148;"	d
AN_REQ_INSPECT	include/types/buffers.h	137;"	d
AN_REQ_PRST_RDP_COOKIE	include/types/buffers.h	147;"	d
AN_REQ_STICKING_RULES	include/types/buffers.h	145;"	d
AN_REQ_SWITCHING_RULES	include/types/buffers.h	140;"	d
AN_REQ_WAIT_HTTP	include/types/buffers.h	138;"	d
AN_RES_HTTP_PROCESS_BE	include/types/buffers.h	153;"	d
AN_RES_HTTP_PROCESS_FE	include/types/buffers.h	154;"	d
AN_RES_HTTP_XFER_BODY	include/types/buffers.h	156;"	d
AN_RES_INSPECT	include/types/buffers.h	151;"	d
AN_RES_STORE_RULES	include/types/buffers.h	155;"	d
AN_RES_WAIT_HTTP	include/types/buffers.h	152;"	d
ARCH	Makefile	/^ARCH =$/;"	m
ARCH_FLAGS	Makefile	/^ARCH_FLAGS        = $(ARCH_FLAGS.$(ARCH))$/;"	m
ARCH_FLAGS.i386	Makefile	/^ARCH_FLAGS.i386   = -m32 -march=i386$/;"	m
ARCH_FLAGS.i486	Makefile	/^ARCH_FLAGS.i486   = -m32 -march=i486$/;"	m
ARCH_FLAGS.i586	Makefile	/^ARCH_FLAGS.i586   = -m32 -march=i586$/;"	m
ARCH_FLAGS.i686	Makefile	/^ARCH_FLAGS.i686   = -m32 -march=i686$/;"	m
ARCH_FLAGS.x86_64	Makefile	/^ARCH_FLAGS.x86_64 = -m64 -march=x86-64$/;"	m
AU_O_INSECURE	include/types/auth.h	23;"	d
Alert	include/proto/log.h	/^void Alert(const char *fmt, ...)$/;"	p	signature:(const char *fmt, ...)
Alert	src/log.c	/^void Alert(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
B64BASE	src/base64.c	20;"	d	file:
B64CMAX	src/base64.c	22;"	d	file:
B64CMIN	src/base64.c	21;"	d	file:
B64MAX	contrib/base64/base64rev-gen.c	19;"	d	file:
B64PADV	contrib/base64/base64rev-gen.c	20;"	d	file:
B64PADV	src/base64.c	23;"	d	file:
BE_LB_ALGO	include/types/backend.h	78;"	d
BE_LB_ALGO_HH	include/types/backend.h	76;"	d
BE_LB_ALGO_LC	include/types/backend.h	71;"	d
BE_LB_ALGO_NONE	include/types/backend.h	69;"	d
BE_LB_ALGO_PH	include/types/backend.h	75;"	d
BE_LB_ALGO_RCH	include/types/backend.h	77;"	d
BE_LB_ALGO_RR	include/types/backend.h	70;"	d
BE_LB_ALGO_SH	include/types/backend.h	73;"	d
BE_LB_ALGO_SRR	include/types/backend.h	72;"	d
BE_LB_ALGO_UH	include/types/backend.h	74;"	d
BE_LB_HASH_CONS	include/types/backend.h	96;"	d
BE_LB_HASH_HDR	include/types/backend.h	44;"	d
BE_LB_HASH_MAP	include/types/backend.h	95;"	d
BE_LB_HASH_PRM	include/types/backend.h	43;"	d
BE_LB_HASH_RDP	include/types/backend.h	45;"	d
BE_LB_HASH_SRC	include/types/backend.h	41;"	d
BE_LB_HASH_TYPE	include/types/backend.h	97;"	d
BE_LB_HASH_URI	include/types/backend.h	42;"	d
BE_LB_KIND	include/types/backend.h	64;"	d
BE_LB_KIND_HI	include/types/backend.h	63;"	d
BE_LB_KIND_LC	include/types/backend.h	62;"	d
BE_LB_KIND_NONE	include/types/backend.h	60;"	d
BE_LB_KIND_RR	include/types/backend.h	61;"	d
BE_LB_LKUP	include/types/backend.h	89;"	d
BE_LB_LKUP_CHTREE	include/types/backend.h	88;"	d
BE_LB_LKUP_LCTREE	include/types/backend.h	87;"	d
BE_LB_LKUP_MAP	include/types/backend.h	85;"	d
BE_LB_LKUP_NONE	include/types/backend.h	84;"	d
BE_LB_LKUP_RRTREE	include/types/backend.h	86;"	d
BE_LB_NEED	include/types/backend.h	57;"	d
BE_LB_NEED_ADDR	include/types/backend.h	53;"	d
BE_LB_NEED_DATA	include/types/backend.h	54;"	d
BE_LB_NEED_HTTP	include/types/backend.h	55;"	d
BE_LB_NEED_NONE	include/types/backend.h	52;"	d
BE_LB_PARM	include/types/backend.h	49;"	d
BE_LB_PROP_DYN	include/types/backend.h	92;"	d
BE_LB_RR_DYN	include/types/backend.h	47;"	d
BE_LB_RR_STATIC	include/types/backend.h	48;"	d
BE_WEIGHT_SCALE	include/types/backend.h	109;"	d
BF_ANA_TIMEOUT	include/types/buffers.h	108;"	d
BF_AUTO_CLOSE	include/types/buffers.h	74;"	d
BF_AUTO_CONNECT	include/types/buffers.h	112;"	d
BF_CLEAR_READ	include/types/buffers.h	119;"	d
BF_CLEAR_TIMEOUT	include/types/buffers.h	121;"	d
BF_CLEAR_WRITE	include/types/buffers.h	120;"	d
BF_DONT_READ	include/types/buffers.h	114;"	d
BF_EXPECT_MORE	include/types/buffers.h	115;"	d
BF_FULL	include/types/buffers.h	60;"	d
BF_HIJACK	include/types/buffers.h	107;"	d
BF_KERN_SPLICING	include/types/buffers.h	110;"	d
BF_MASK_ANALYSER	include/types/buffers.h	124;"	d
BF_MASK_STATIC	include/types/buffers.h	127;"	d
BF_OUT_EMPTY	include/types/buffers.h	71;"	d
BF_READ_ACTIVITY	include/types/buffers.h	58;"	d
BF_READ_ATTACHED	include/types/buffers.h	109;"	d
BF_READ_DONTWAIT	include/types/buffers.h	111;"	d
BF_READ_ERROR	include/types/buffers.h	57;"	d
BF_READ_NOEXP	include/types/buffers.h	63;"	d
BF_READ_NULL	include/types/buffers.h	54;"	d
BF_READ_PARTIAL	include/types/buffers.h	55;"	d
BF_READ_TIMEOUT	include/types/buffers.h	56;"	d
BF_SEND_DONTWAIT	include/types/buffers.h	116;"	d
BF_SHUTR	include/types/buffers.h	61;"	d
BF_SHUTR_NOW	include/types/buffers.h	62;"	d
BF_SHUTW	include/types/buffers.h	72;"	d
BF_SHUTW_NOW	include/types/buffers.h	73;"	d
BF_STREAMER	include/types/buffers.h	104;"	d
BF_STREAMER_FAST	include/types/buffers.h	105;"	d
BF_WRITE_ACTIVITY	include/types/buffers.h	69;"	d
BF_WRITE_ERROR	include/types/buffers.h	68;"	d
BF_WRITE_NULL	include/types/buffers.h	65;"	d
BF_WRITE_PARTIAL	include/types/buffers.h	66;"	d
BF_WRITE_TIMEOUT	include/types/buffers.h	67;"	d
BITS_PER_INT	include/common/compat.h	32;"	d
BUFSIZE	include/common/defaults.h	35;"	d
BUF_INFINITE_FORWARD	include/types/buffers.h	160;"	d
BUILD_OPTIONS	Makefile	/^BUILD_OPTIONS =$/;"	m
CALLOC	include/common/config.h	53;"	d
CALLOC	include/common/config.h	55;"	d
CAPTURE_LEN	include/common/defaults.h	44;"	d
CC	Makefile	/^CC = gcc$/;"	m
CFG_GLOBAL	include/common/cfgparse.h	33;"	d
CFG_LISTEN	include/common/cfgparse.h	34;"	d
CFG_NONE	include/common/cfgparse.h	32;"	d
CFG_USERLIST	include/common/cfgparse.h	35;"	d
CFLAGS	Makefile	/^CFLAGS = $(ARCH_FLAGS) $(CPU_CFLAGS) $(DEBUG_CFLAGS)$/;"	m
CHK_CONNTIME	include/common/defaults.h	121;"	d
CONFIG_HAP_MEM_OPTIM	include/common/config.h	40;"	d
CONN_FIELD	contrib/halog/halog.c	33;"	d	file:
CONN_RETRIES	include/common/defaults.h	119;"	d
COOKIE_DELIM	include/common/defaults.h	110;"	d
COOKIE_DELIM_DATE	include/common/defaults.h	116;"	d
COPTS	Makefile	/^COPTS  = -Iinclude -I$(EBTREE_DIR) -Wall$/;"	m
CPU	Makefile	/^CPU = generic$/;"	m
CPU_CFLAGS	Makefile	/^CPU_CFLAGS            = $(CPU_CFLAGS.$(CPU))$/;"	m
CPU_CFLAGS.generic	Makefile	/^CPU_CFLAGS.generic    = -O2$/;"	m
CPU_CFLAGS.i586	Makefile	/^CPU_CFLAGS.i586       = -O2 -march=i586$/;"	m
CPU_CFLAGS.i686	Makefile	/^CPU_CFLAGS.i686       = -O2 -march=i686$/;"	m
CPU_CFLAGS.ultrasparc	Makefile	/^CPU_CFLAGS.ultrasparc = -O6 -mcpu=v9 -mtune=ultrasparc$/;"	m
DATA_SRC_NONE	include/types/proto_http.h	190;"	d
DATA_SRC_STATS	include/types/proto_http.h	191;"	d
DATA_ST_END	include/types/proto_http.h	/^	DATA_ST_END,$/;"	e	enum:__anon29
DATA_ST_FIN	include/types/proto_http.h	/^	DATA_ST_FIN,$/;"	e	enum:__anon29
DATA_ST_HEAD	include/types/proto_http.h	/^	DATA_ST_HEAD,$/;"	e	enum:__anon29
DATA_ST_INFO	include/types/proto_http.h	/^	DATA_ST_INFO,$/;"	e	enum:__anon29
DATA_ST_INIT	include/types/proto_http.h	/^	DATA_ST_INIT = 0,$/;"	e	enum:__anon29
DATA_ST_LIST	include/types/proto_http.h	/^	DATA_ST_LIST,$/;"	e	enum:__anon29
DATA_ST_PX_BE	include/types/proto_http.h	/^	DATA_ST_PX_BE,$/;"	e	enum:__anon30
DATA_ST_PX_END	include/types/proto_http.h	/^	DATA_ST_PX_END,$/;"	e	enum:__anon30
DATA_ST_PX_FE	include/types/proto_http.h	/^	DATA_ST_PX_FE,$/;"	e	enum:__anon30
DATA_ST_PX_FIN	include/types/proto_http.h	/^	DATA_ST_PX_FIN,$/;"	e	enum:__anon30
DATA_ST_PX_INIT	include/types/proto_http.h	/^	DATA_ST_PX_INIT = 0,$/;"	e	enum:__anon30
DATA_ST_PX_LI	include/types/proto_http.h	/^	DATA_ST_PX_LI,$/;"	e	enum:__anon30
DATA_ST_PX_SV	include/types/proto_http.h	/^	DATA_ST_PX_SV,$/;"	e	enum:__anon30
DATA_ST_PX_TH	include/types/proto_http.h	/^	DATA_ST_PX_TH,$/;"	e	enum:__anon30
DAY	include/common/time.h	33;"	d
DEBUG	Makefile	/^DEBUG =$/;"	m
DEBUG_CFLAGS	Makefile	/^DEBUG_CFLAGS = -g$/;"	m
DEFAULT_MAXCONN	include/common/defaults.h	149;"	d
DEFAULT_MAXCONN	include/common/defaults.h	152;"	d
DEFAULT_MAXCONN	include/common/defaults.h	153;"	d
DEFINE	Makefile	/^DEFINE =$/;"	m
DEF_CHECK_REQ	include/common/defaults.h	125;"	d
DEF_CHKINTR	include/common/defaults.h	122;"	d
DEF_FALLTIME	include/common/defaults.h	123;"	d
DEF_HANA_ERRLIMIT	include/common/defaults.h	130;"	d
DEF_HANA_ONERR	include/common/defaults.h	129;"	d
DEF_LDAP_CHECK_REQ	include/common/defaults.h	127;"	d
DEF_RISETIME	include/common/defaults.h	124;"	d
DEF_SMTP_CHECK_REQ	include/common/defaults.h	126;"	d
DEF_XFORWARDFOR_HDR	include/common/defaults.h	133;"	d
DEF_XORIGINALTO_HDR	include/common/defaults.h	136;"	d
DESTDIR	Makefile	/^DESTDIR =$/;"	m
DIR2MSK	src/ev_epoll.c	74;"	d	file:
DIR_RD	include/types/fd.h	/^	DIR_RD=0,$/;"	e	enum:__anon55
DIR_SIZE	include/types/fd.h	/^	DIR_SIZE$/;"	e	enum:__anon55
DIR_WR	include/types/fd.h	/^	DIR_WR=1,$/;"	e	enum:__anon55
DLIST_ADD	include/common/mini-clist.h	71;"	d
DLIST_DEL	include/common/mini-clist.h	74;"	d
DLMALLOC_SRC	Makefile	/^DLMALLOC_SRC=src\/dlmalloc.c$/;"	m
DLMALLOC_THRES	Makefile	/^DLMALLOC_THRES = 4096$/;"	m
DOCDIR	Makefile	/^DOCDIR = $(PREFIX)\/doc\/haproxy$/;"	m
DPRINTF	include/common/debug.h	28;"	d
DPRINTF	include/common/debug.h	30;"	d
EAT_AND_JUMP_OR_RETURN	src/proto_http.c	1258;"	d	file:
EB32_ROOT	ebtree/eb32tree.h	30;"	d
EB32_TREE_HEAD	ebtree/eb32tree.h	31;"	d
EB64_ROOT	ebtree/eb64tree.h	30;"	d
EB64_TREE_HEAD	ebtree/eb64tree.h	31;"	d
EBMB_ROOT	ebtree/ebmbtree.h	30;"	d
EBMB_TREE_HEAD	ebtree/ebmbtree.h	31;"	d
EBPT_ROOT	ebtree/ebpttree.h	32;"	d
EBPT_TREE_HEAD	ebtree/ebpttree.h	33;"	d
EBTREE_DIR	Makefile	/^EBTREE_DIR := ebtree$/;"	m
EBTREE_DIR	contrib/halog/Makefile	/^EBTREE_DIR = ..\/..\/ebtree$/;"	m
EBTREE_OBJS	Makefile	/^EBTREE_OBJS = $(EBTREE_DIR)\/ebtree.o \\$/;"	m
EB_LEAF	ebtree/ebtree.h	344;"	d
EB_LEFT	ebtree/ebtree.h	342;"	d
EB_NODE	ebtree/ebtree.h	345;"	d
EB_NODE_BITS	ebtree/ebtree.h	335;"	d
EB_NODE_BRANCHES	ebtree/ebtree.h	336;"	d
EB_NODE_BRANCH_MASK	ebtree/ebtree.h	337;"	d
EB_NORMAL	ebtree/ebtree.h	351;"	d
EB_RGHT	ebtree/ebtree.h	343;"	d
EB_ROOT	ebtree/ebtree.h	389;"	d
EB_ROOT_UNIQUE	ebtree/ebtree.h	394;"	d
EB_TREE_HEAD	ebtree/ebtree.h	399;"	d
EB_UNIQUE	ebtree/ebtree.h	352;"	d
EPOLLERR	include/common/epoll.h	49;"	d
EPOLLET	include/common/epoll.h	52;"	d
EPOLLHUP	include/common/epoll.h	50;"	d
EPOLLIN	include/common/epoll.h	46;"	d
EPOLLONESHOT	include/common/epoll.h	51;"	d
EPOLLOUT	include/common/epoll.h	48;"	d
EPOLLPRI	include/common/epoll.h	47;"	d
EPOLL_CTL_ADD	include/common/epoll.h	39;"	d
EPOLL_CTL_DEL	include/common/epoll.h	40;"	d
EPOLL_CTL_MOD	include/common/epoll.h	41;"	d
ERR_ABORT	include/common/errors.h	34;"	d
ERR_ALERT	include/common/errors.h	36;"	d
ERR_CODE	include/common/errors.h	38;"	d
ERR_FATAL	include/common/errors.h	33;"	d
ERR_NONE	include/common/errors.h	31;"	d
ERR_RETRYABLE	include/common/errors.h	32;"	d
ERR_WARN	include/common/errors.h	35;"	d
EV_FD_CLO	include/proto/fd.h	79;"	d
EV_FD_CLR	include/proto/fd.h	74;"	d
EV_FD_COND_C	include/proto/fd.h	77;"	d
EV_FD_COND_S	include/proto/fd.h	76;"	d
EV_FD_ISSET	include/proto/fd.h	75;"	d
EV_FD_REM	include/proto/fd.h	78;"	d
EV_FD_SET	include/proto/fd.h	73;"	d
EXPECT_LF_HERE	src/proto_http.c	1253;"	d	file:
FD2BIT	src/ev_epoll.c	/^	dmsk <<= FD2BIT(fd);$/;"	p	file:
FD2BIT	src/ev_epoll.c	78;"	d	file:
FD2MSK	src/ev_epoll.c	79;"	d	file:
FD2OFS	src/ev_epoll.c	77;"	d	file:
FDSETS_ARE_INT_ALIGNED	src/ev_poll.c	103;"	d	file:
FD_EV_IDLE	src/ev_sepoll.c	123;"	d	file:
FD_EV_IDLE_R	src/ev_sepoll.c	133;"	d	file:
FD_EV_IDLE_W	src/ev_sepoll.c	139;"	d	file:
FD_EV_IN_PL	src/ev_sepoll.c	121;"	d	file:
FD_EV_IN_SL	src/ev_sepoll.c	120;"	d	file:
FD_EV_MASK	src/ev_sepoll.c	145;"	d	file:
FD_EV_MASK_DIR	src/ev_sepoll.c	131;"	d	file:
FD_EV_MASK_R	src/ev_sepoll.c	137;"	d	file:
FD_EV_MASK_W	src/ev_sepoll.c	143;"	d	file:
FD_EV_RW_PL	src/ev_sepoll.c	130;"	d	file:
FD_EV_RW_SL	src/ev_sepoll.c	129;"	d	file:
FD_EV_SPEC	src/ev_sepoll.c	124;"	d	file:
FD_EV_SPEC_R	src/ev_sepoll.c	134;"	d	file:
FD_EV_SPEC_W	src/ev_sepoll.c	140;"	d	file:
FD_EV_STOP	src/ev_sepoll.c	126;"	d	file:
FD_EV_STOP_R	src/ev_sepoll.c	136;"	d	file:
FD_EV_STOP_W	src/ev_sepoll.c	142;"	d	file:
FD_EV_WAIT	src/ev_sepoll.c	125;"	d	file:
FD_EV_WAIT_R	src/ev_sepoll.c	135;"	d	file:
FD_EV_WAIT_W	src/ev_sepoll.c	141;"	d	file:
FD_FL_TCP	include/types/fd.h	64;"	d
FD_FL_TCP_NODELAY	include/types/fd.h	65;"	d
FD_FL_TCP_NOLING	include/types/fd.h	66;"	d
FD_POLL_DATA	include/types/fd.h	58;"	d
FD_POLL_ERR	include/types/fd.h	55;"	d
FD_POLL_HUP	include/types/fd.h	56;"	d
FD_POLL_IN	include/types/fd.h	52;"	d
FD_POLL_OUT	include/types/fd.h	54;"	d
FD_POLL_PRI	include/types/fd.h	53;"	d
FD_POLL_STICKY	include/types/fd.h	59;"	d
FD_SETS_ARE_BITFIELDS	src/proto_http.c	199;"	d	file:
FD_STCLOSE	include/types/fd.h	35;"	d
FD_STCONN	include/types/fd.h	37;"	d
FD_STERROR	include/types/fd.h	39;"	d
FD_STLISTEN	include/types/fd.h	36;"	d
FD_STREADY	include/types/fd.h	38;"	d
FGETS2_BUFSIZE	contrib/halog/fgets2-64.c	62;"	d	file:
FGETS2_BUFSIZE	contrib/halog/fgets2.c	49;"	d	file:
FIELD_INDEX	contrib/netsnmp-perl/haproxy.pl	/^use constant FIELD_INDEX => 10001;$/;"	c
FIELD_NAME	contrib/netsnmp-perl/haproxy.pl	/^use constant FIELD_NAME => 10002;$/;"	c
FILT_ACC_COUNT	contrib/halog/halog.c	76;"	d	file:
FILT_ACC_DELAY	contrib/halog/halog.c	75;"	d	file:
FILT_COUNT_ONLY	contrib/halog/halog.c	71;"	d	file:
FILT_COUNT_SRV_STATUS	contrib/halog/halog.c	85;"	d	file:
FILT_COUNT_STATUS	contrib/halog/halog.c	84;"	d	file:
FILT_COUNT_TERM_CODES	contrib/halog/halog.c	86;"	d	file:
FILT_COUNT_URL_ANY	contrib/halog/halog.c	95;"	d	file:
FILT_COUNT_URL_COUNT	contrib/halog/halog.c	89;"	d	file:
FILT_COUNT_URL_ERR	contrib/halog/halog.c	90;"	d	file:
FILT_COUNT_URL_ONLY	contrib/halog/halog.c	88;"	d	file:
FILT_COUNT_URL_TAVG	contrib/halog/halog.c	92;"	d	file:
FILT_COUNT_URL_TAVGO	contrib/halog/halog.c	94;"	d	file:
FILT_COUNT_URL_TTOT	contrib/halog/halog.c	91;"	d	file:
FILT_COUNT_URL_TTOTO	contrib/halog/halog.c	93;"	d	file:
FILT_ERRORS_ONLY	contrib/halog/halog.c	74;"	d	file:
FILT_GRAPH_TIMERS	contrib/halog/halog.c	77;"	d	file:
FILT_INVERT	contrib/halog/halog.c	72;"	d	file:
FILT_INVERT_ERRORS	contrib/halog/halog.c	81;"	d	file:
FILT_INVERT_TIME_RESP	contrib/halog/halog.c	82;"	d	file:
FILT_PERCENTILE	contrib/halog/halog.c	78;"	d	file:
FILT_QUIET	contrib/halog/halog.c	73;"	d	file:
FILT_TIME_RESP	contrib/halog/halog.c	79;"	d	file:
FNV_32_PRIME	tests/test_hashes.c	293;"	d	file:
FOREACH_ITEM	include/common/mini-clist.h	154;"	d
FOREACH_ITEM_SAFE	include/common/mini-clist.h	166;"	d
FREE	include/common/config.h	59;"	d
FREE	include/common/config.h	61;"	d
FSM_PRINTF	include/common/debug.h	34;"	d
FSM_PRINTF	include/common/debug.h	36;"	d
Fnv32_t	tests/test_hashes.c	/^typedef unsigned long Fnv32_t;$/;"	t	file:
GTUNE_USE_EPOLL	include/types/global.h	51;"	d
GTUNE_USE_KQUEUE	include/types/global.h	52;"	d
GTUNE_USE_POLL	include/types/global.h	50;"	d
GTUNE_USE_SELECT	include/types/global.h	49;"	d
GTUNE_USE_SEPOLL	include/types/global.h	53;"	d
GTUNE_USE_SPLICE	include/types/global.h	55;"	d
HANA_OBS_LAYER4	include/types/checks.h	/^	HANA_OBS_LAYER4,		\/* Observe L4 - for example tcp *\/$/;"	e	enum:__anon5
HANA_OBS_LAYER7	include/types/checks.h	/^	HANA_OBS_LAYER7,		\/* Observe L7 - for example http *\/$/;"	e	enum:__anon5
HANA_OBS_NONE	include/types/checks.h	/^	HANA_OBS_NONE		= 0,$/;"	e	enum:__anon5
HANA_OBS_SIZE	include/types/checks.h	/^	HANA_OBS_SIZE$/;"	e	enum:__anon5
HANA_ONERR_FAILCHK	include/types/checks.h	/^	HANA_ONERR_FAILCHK,		\/* Simulate a failed check *\/$/;"	e	enum:__anon4
HANA_ONERR_FASTINTER	include/types/checks.h	/^	HANA_ONERR_FASTINTER,		\/* Force fastinter*\/$/;"	e	enum:__anon4
HANA_ONERR_MARKDWN	include/types/checks.h	/^	HANA_ONERR_MARKDWN,		\/* Mark this server down, now! *\/$/;"	e	enum:__anon4
HANA_ONERR_SUDDTH	include/types/checks.h	/^	HANA_ONERR_SUDDTH,		\/* Enters sudden death - one more failed check will mark this server down *\/$/;"	e	enum:__anon4
HANA_ONERR_UNKNOWN	include/types/checks.h	/^	HANA_ONERR_UNKNOWN	= 0,$/;"	e	enum:__anon4
HANA_STATUS_HTTP_BROKEN_PIPE	include/types/checks.h	/^	HANA_STATUS_HTTP_BROKEN_PIPE,	\/* Unexpected close from server *\/$/;"	e	enum:__anon3
HANA_STATUS_HTTP_HDRRSP	include/types/checks.h	/^	HANA_STATUS_HTTP_HDRRSP,	\/* Invalid http response (headers) *\/$/;"	e	enum:__anon3
HANA_STATUS_HTTP_OK	include/types/checks.h	/^	HANA_STATUS_HTTP_OK,		\/* Correct http response *\/$/;"	e	enum:__anon3
HANA_STATUS_HTTP_READ_ERROR	include/types/checks.h	/^	HANA_STATUS_HTTP_READ_ERROR,	\/* Read error *\/$/;"	e	enum:__anon3
HANA_STATUS_HTTP_READ_TIMEOUT	include/types/checks.h	/^	HANA_STATUS_HTTP_READ_TIMEOUT,	\/* Read timeout *\/$/;"	e	enum:__anon3
HANA_STATUS_HTTP_RSP	include/types/checks.h	/^	HANA_STATUS_HTTP_RSP,		\/* Invalid http response *\/$/;"	e	enum:__anon3
HANA_STATUS_HTTP_STS	include/types/checks.h	/^	HANA_STATUS_HTTP_STS,		\/* Wrong http response, for example HTTP 5xx *\/$/;"	e	enum:__anon3
HANA_STATUS_L4_ERR	include/types/checks.h	/^	HANA_STATUS_L4_ERR,		\/* L4 unsuccessful connection *\/$/;"	e	enum:__anon3
HANA_STATUS_L4_OK	include/types/checks.h	/^	HANA_STATUS_L4_OK,		\/* L4 successful connection *\/$/;"	e	enum:__anon3
HANA_STATUS_SIZE	include/types/checks.h	/^	HANA_STATUS_SIZE$/;"	e	enum:__anon3
HANA_STATUS_UNKNOWN	include/types/checks.h	/^	HANA_STATUS_UNKNOWN	= 0,$/;"	e	enum:__anon3
HAPROXY_BACKENDS	tests/test_hashes.c	31;"	d	file:
HAPROXY_DATE	include/common/version.h	64;"	d
HAPROXY_VERSION	include/common/version.h	58;"	d
HASHSIZE	tests/test_hashes.c	449;"	d	file:
HCHK_DESC_LEN	include/common/defaults.h	188;"	d
HCHK_STATUS_CHECKED	include/types/checks.h	/^	HCHK_STATUS_CHECKED,		\/* DUMMY STATUS *\/$/;"	e	enum:__anon2
HCHK_STATUS_HANA	include/types/checks.h	/^	HCHK_STATUS_HANA,		\/* Healt analyze detected enough consecutive errors *\/$/;"	e	enum:__anon2
HCHK_STATUS_INI	include/types/checks.h	/^	HCHK_STATUS_INI,		\/* Initializing *\/$/;"	e	enum:__anon2
HCHK_STATUS_L4CON	include/types/checks.h	/^	HCHK_STATUS_L4CON,		\/* L4 connection problem, for example: *\/$/;"	e	enum:__anon2
HCHK_STATUS_L4OK	include/types/checks.h	/^	HCHK_STATUS_L4OK,		\/* L4 check passed, for example tcp connect *\/$/;"	e	enum:__anon2
HCHK_STATUS_L4TOUT	include/types/checks.h	/^	HCHK_STATUS_L4TOUT,		\/* L4 timeout *\/$/;"	e	enum:__anon2
HCHK_STATUS_L57DATA	include/types/checks.h	/^	HCHK_STATUS_L57DATA,		\/* DUMMY STATUS *\/$/;"	e	enum:__anon2
HCHK_STATUS_L6OK	include/types/checks.h	/^	HCHK_STATUS_L6OK,		\/* L6 check passed *\/$/;"	e	enum:__anon2
HCHK_STATUS_L6RSP	include/types/checks.h	/^	HCHK_STATUS_L6RSP,		\/* L6 invalid response - protocol error *\/$/;"	e	enum:__anon2
HCHK_STATUS_L6TOUT	include/types/checks.h	/^	HCHK_STATUS_L6TOUT,		\/* L6 (SSL) timeout *\/$/;"	e	enum:__anon2
HCHK_STATUS_L7OKCD	include/types/checks.h	/^	HCHK_STATUS_L7OKCD,		\/* L7 check conditionally passed *\/$/;"	e	enum:__anon2
HCHK_STATUS_L7OKD	include/types/checks.h	/^	HCHK_STATUS_L7OKD,		\/* L7 check passed *\/$/;"	e	enum:__anon2
HCHK_STATUS_L7RSP	include/types/checks.h	/^	HCHK_STATUS_L7RSP,		\/* L7 invalid response - protocol error *\/$/;"	e	enum:__anon2
HCHK_STATUS_L7STS	include/types/checks.h	/^	HCHK_STATUS_L7STS,		\/* L7 response error, for example HTTP 5xx *\/$/;"	e	enum:__anon2
HCHK_STATUS_L7TOUT	include/types/checks.h	/^	HCHK_STATUS_L7TOUT,		\/* L7 (HTTP\/SMTP) timeout *\/$/;"	e	enum:__anon2
HCHK_STATUS_SIZE	include/types/checks.h	/^	HCHK_STATUS_SIZE$/;"	e	enum:__anon2
HCHK_STATUS_SOCKERR	include/types/checks.h	/^	HCHK_STATUS_SOCKERR,		\/* Socket error *\/$/;"	e	enum:__anon2
HCHK_STATUS_START	include/types/checks.h	/^	HCHK_STATUS_START,		\/* Check started - SPECIAL STATUS *\/$/;"	e	enum:__anon2
HCHK_STATUS_UNKNOWN	include/types/checks.h	/^	HCHK_STATUS_UNKNOWN	 = 0,	\/* Unknown *\/$/;"	e	enum:__anon2
HOUR	include/common/time.h	32;"	d
HTTP_100	src/proto_http.c	/^const char HTTP_100[] =$/;"	v
HTTP_200	include/proto/httperr.h	/^extern const char *HTTP_200;$/;"	x
HTTP_200	src/proto_http.c	/^const char HTTP_200[] =$/;"	v
HTTP_301	src/proto_http.c	/^const char *HTTP_301 =$/;"	v
HTTP_302	include/proto/httperr.h	/^extern const char *HTTP_302;$/;"	x
HTTP_302	src/proto_http.c	/^const char *HTTP_302 =$/;"	v
HTTP_303	include/proto/httperr.h	/^extern const char *HTTP_303;$/;"	x
HTTP_303	src/proto_http.c	/^const char *HTTP_303 =$/;"	v
HTTP_401_fmt	include/proto/httperr.h	/^extern const char *HTTP_401_fmt;$/;"	x
HTTP_401_fmt	src/proto_http.c	/^const char *HTTP_401_fmt =$/;"	v
HTTP_407_fmt	src/proto_http.c	/^const char *HTTP_407_fmt =$/;"	v
HTTP_AUTH_BASIC	include/types/proto_http.h	/^	HTTP_AUTH_BASIC,$/;"	e	enum:__anon35
HTTP_AUTH_DIGEST	include/types/proto_http.h	/^	HTTP_AUTH_DIGEST,$/;"	e	enum:__anon35
HTTP_AUTH_UNKNOWN	include/types/proto_http.h	/^	HTTP_AUTH_UNKNOWN	= 0,$/;"	e	enum:__anon35
HTTP_AUTH_WRONG	include/types/proto_http.h	/^	HTTP_AUTH_WRONG		= -1,		\/* missing or unknown *\/$/;"	e	enum:__anon35
HTTP_ERR_400	include/types/httperr.h	/^	HTTP_ERR_400 = 0,$/;"	e	enum:__anon14
HTTP_ERR_403	include/types/httperr.h	/^	HTTP_ERR_403,$/;"	e	enum:__anon14
HTTP_ERR_408	include/types/httperr.h	/^	HTTP_ERR_408,$/;"	e	enum:__anon14
HTTP_ERR_500	include/types/httperr.h	/^	HTTP_ERR_500,$/;"	e	enum:__anon14
HTTP_ERR_502	include/types/httperr.h	/^	HTTP_ERR_502,$/;"	e	enum:__anon14
HTTP_ERR_503	include/types/httperr.h	/^	HTTP_ERR_503,$/;"	e	enum:__anon14
HTTP_ERR_504	include/types/httperr.h	/^	HTTP_ERR_504,$/;"	e	enum:__anon14
HTTP_ERR_SIZE	include/types/httperr.h	/^	HTTP_ERR_SIZE$/;"	e	enum:__anon14
HTTP_IS_CRLF	include/proto/proto_http.h	56;"	d
HTTP_IS_CTL	include/proto/proto_http.h	52;"	d
HTTP_IS_LWS	include/proto/proto_http.h	54;"	d
HTTP_IS_SEP	include/proto/proto_http.h	53;"	d
HTTP_IS_SPHT	include/proto/proto_http.h	55;"	d
HTTP_IS_TOKEN	include/proto/proto_http.h	57;"	d
HTTP_IS_VER_TOKEN	include/proto/proto_http.h	58;"	d
HTTP_METH_CONNECT	include/types/proto_http.h	/^	HTTP_METH_CONNECT,$/;"	e	enum:__anon34
HTTP_METH_DELETE	include/types/proto_http.h	/^	HTTP_METH_DELETE,$/;"	e	enum:__anon34
HTTP_METH_GET	include/types/proto_http.h	/^	HTTP_METH_GET,$/;"	e	enum:__anon34
HTTP_METH_HEAD	include/types/proto_http.h	/^	HTTP_METH_HEAD,$/;"	e	enum:__anon34
HTTP_METH_NONE	include/types/proto_http.h	/^	HTTP_METH_NONE = 0,$/;"	e	enum:__anon34
HTTP_METH_OPTIONS	include/types/proto_http.h	/^	HTTP_METH_OPTIONS,$/;"	e	enum:__anon34
HTTP_METH_OTHER	include/types/proto_http.h	/^	HTTP_METH_OTHER,$/;"	e	enum:__anon34
HTTP_METH_POST	include/types/proto_http.h	/^	HTTP_METH_POST,$/;"	e	enum:__anon34
HTTP_METH_PUT	include/types/proto_http.h	/^	HTTP_METH_PUT,$/;"	e	enum:__anon34
HTTP_METH_TRACE	include/types/proto_http.h	/^	HTTP_METH_TRACE,$/;"	e	enum:__anon34
HTTP_MSG_100_SENT	include/types/proto_http.h	177;"	d
HTTP_MSG_BODY	include/types/proto_http.h	176;"	d
HTTP_MSG_CHUNK_SIZE	include/types/proto_http.h	178;"	d
HTTP_MSG_CLOSED	include/types/proto_http.h	186;"	d
HTTP_MSG_CLOSING	include/types/proto_http.h	185;"	d
HTTP_MSG_DATA	include/types/proto_http.h	179;"	d
HTTP_MSG_DATA_CRLF	include/types/proto_http.h	180;"	d
HTTP_MSG_DONE	include/types/proto_http.h	184;"	d
HTTP_MSG_ERROR	include/types/proto_http.h	169;"	d
HTTP_MSG_HDR_COL	include/types/proto_http.h	155;"	d
HTTP_MSG_HDR_FIRST	include/types/proto_http.h	153;"	d
HTTP_MSG_HDR_L1_LF	include/types/proto_http.h	157;"	d
HTTP_MSG_HDR_L1_LWS	include/types/proto_http.h	158;"	d
HTTP_MSG_HDR_L1_SP	include/types/proto_http.h	156;"	d
HTTP_MSG_HDR_L2_LF	include/types/proto_http.h	160;"	d
HTTP_MSG_HDR_L2_LWS	include/types/proto_http.h	161;"	d
HTTP_MSG_HDR_NAME	include/types/proto_http.h	154;"	d
HTTP_MSG_HDR_VAL	include/types/proto_http.h	159;"	d
HTTP_MSG_LAST_LF	include/types/proto_http.h	163;"	d
HTTP_MSG_RPBEFORE	include/types/proto_http.h	140;"	d
HTTP_MSG_RPBEFORE_CR	include/types/proto_http.h	141;"	d
HTTP_MSG_RPCODE	include/types/proto_http.h	146;"	d
HTTP_MSG_RPCODE_SP	include/types/proto_http.h	147;"	d
HTTP_MSG_RPLINE_END	include/types/proto_http.h	149;"	d
HTTP_MSG_RPREASON	include/types/proto_http.h	148;"	d
HTTP_MSG_RPVER	include/types/proto_http.h	144;"	d
HTTP_MSG_RPVER_SP	include/types/proto_http.h	145;"	d
HTTP_MSG_RQBEFORE	include/types/proto_http.h	129;"	d
HTTP_MSG_RQBEFORE_CR	include/types/proto_http.h	130;"	d
HTTP_MSG_RQLINE_END	include/types/proto_http.h	138;"	d
HTTP_MSG_RQMETH	include/types/proto_http.h	133;"	d
HTTP_MSG_RQMETH_SP	include/types/proto_http.h	134;"	d
HTTP_MSG_RQURI	include/types/proto_http.h	135;"	d
HTTP_MSG_RQURI_SP	include/types/proto_http.h	136;"	d
HTTP_MSG_RQVER	include/types/proto_http.h	137;"	d
HTTP_MSG_TRAILERS	include/types/proto_http.h	181;"	d
HTTP_MSG_TUNNEL	include/types/proto_http.h	187;"	d
HiLink	examples/haproxy.vim	/^	command -nargs=+ HiLink hi def link <args>$/;"	c
HiLink	examples/haproxy.vim	/^	command -nargs=+ HiLink hi link <args>$/;"	c
INCLUDE	contrib/halog/Makefile	/^INCLUDE  = -I..\/..\/include -I$(EBTREE_DIR)$/;"	m
IP_FREEBIND	include/common/compat.h	74;"	d
IP_ORIGADDRS	include/import/ip_tproxy.h	23;"	d
IP_RECVORIGADDRS	include/import/ip_tproxy.h	22;"	d
IP_TPROXY	include/import/ip_tproxy.h	38;"	d
IP_TRANSPARENT	include/common/compat.h	77;"	d
ITP_APPLIED	include/import/ip_tproxy.h	58;"	d
ITP_CONNECT	include/import/ip_tproxy.h	52;"	d
ITP_ESTABLISHED	include/import/ip_tproxy.h	54;"	d
ITP_LISTEN	include/import/ip_tproxy.h	53;"	d
ITP_MARK	include/import/ip_tproxy.h	57;"	d
ITP_ONCE	include/import/ip_tproxy.h	56;"	d
ITP_UNIDIR	include/import/ip_tproxy.h	59;"	d
KWM_DEF	src/cfgparse.c	/^	KWM_DEF,      \/* "default" prefixed before the keyword *\/$/;"	e	enum:kw_mod	file:
KWM_NO	src/cfgparse.c	/^	KWM_NO,       \/* "no" prefixed before the keyword *\/$/;"	e	enum:kw_mod	file:
KWM_STD	src/cfgparse.c	/^	KWM_STD = 0,  \/* normal *\/$/;"	e	enum:kw_mod	file:
LBOUND	include/common/standard.h	39;"	d
LB_MAP_RECALC	include/types/lb_map.h	29;"	d
LD	Makefile	/^LD = $(CC)$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = $(ARCH_FLAGS) -g$/;"	m
LDOPTS	Makefile	/^LDOPTS = $(TARGET_LDFLAGS) $(OPTIONS_LDFLAGS) $(ADDLIB)$/;"	m
LIB_EBTREE	Makefile	/^LIB_EBTREE = $(EBTREE_DIR)\/libebtree.a$/;"	m
LIM2A0	include/common/standard.h	105;"	d
LIM2A1	include/common/standard.h	106;"	d
LIM2A2	include/common/standard.h	107;"	d
LIM2A3	include/common/standard.h	108;"	d
LIM2A4	include/common/standard.h	109;"	d
LIM2A5	include/common/standard.h	110;"	d
LIM2A6	include/common/standard.h	111;"	d
LIM2A7	include/common/standard.h	112;"	d
LIM2A8	include/common/standard.h	113;"	d
LIM2A9	include/common/standard.h	114;"	d
LINESIZE	include/common/defaults.h	48;"	d
LIST_ADD	include/common/mini-clist.h	111;"	d
LIST_ADDQ	include/common/mini-clist.h	114;"	d
LIST_DEL	include/common/mini-clist.h	117;"	d
LIST_ELEM	include/common/mini-clist.h	124;"	d
LIST_HEAD	include/common/mini-clist.h	52;"	d
LIST_HEAD	include/common/mini-clist.h	56;"	d
LIST_HEAD_INIT	include/common/mini-clist.h	60;"	d
LIST_INIT	include/common/mini-clist.h	53;"	d
LIST_INIT	include/common/mini-clist.h	58;"	d
LIST_ISEMPTY	include/common/mini-clist.h	127;"	d
LIST_NEXT	include/common/mini-clist.h	134;"	d
LIST_NEXT	include/common/mini-clist.h	54;"	d
LIST_PREV	include/common/mini-clist.h	141;"	d
LI_ASSIGNED	include/types/protocols.h	43;"	d
LI_FULL	include/types/protocols.h	46;"	d
LI_INIT	include/types/protocols.h	42;"	d
LI_LISTEN	include/types/protocols.h	44;"	d
LI_NEW	include/types/protocols.h	41;"	d
LI_O_DEF_ACCEPT	include/types/protocols.h	74;"	d
LI_O_FOREIGN	include/types/protocols.h	72;"	d
LI_O_NOLINGER	include/types/protocols.h	71;"	d
LI_O_NONE	include/types/protocols.h	70;"	d
LI_O_NOQUICKACK	include/types/protocols.h	73;"	d
LI_READY	include/types/protocols.h	45;"	d
LLONG_MAX	src/standard.c	625;"	d	file:
LLONG_MIN	src/standard.c	626;"	d	file:
LSTCHK_CAP_BIND	include/types/global.h	43;"	d
LSTCHK_CTTPROXY	include/types/global.h	44;"	d
LSTCHK_NETADM	include/types/global.h	45;"	d
LW_BYTES	include/types/log.h	45;"	d
LW_CLIP	include/types/log.h	38;"	d
LW_COOKIE	include/types/log.h	46;"	d
LW_DATE	include/types/log.h	37;"	d
LW_PXID	include/types/log.h	44;"	d
LW_PXIP	include/types/log.h	43;"	d
LW_REQ	include/types/log.h	41;"	d
LW_REQHDR	include/types/log.h	47;"	d
LW_RESP	include/types/log.h	42;"	d
LW_RSPHDR	include/types/log.h	48;"	d
LW_SVID	include/types/log.h	40;"	d
LW_SVIP	include/types/log.h	39;"	d
MALLOC	include/common/config.h	47;"	d
MALLOC	include/common/config.h	49;"	d
MANDIR	Makefile	/^MANDIR = $(PREFIX)\/share\/man$/;"	m
MAX	include/common/tools.h	32;"	d
MAXLINE	contrib/halog/halog.c	36;"	d	file:
MAXLINE	tests/ip-hash.c	17;"	d	file:
MAXLINE	tests/uri_hash.c	6;"	d	file:
MAXPATHLEN	src/proto_uxst.c	56;"	d	file:
MAXREWRITE	include/common/defaults.h	40;"	d
MAX_AUTH_GROUPS	include/types/auth.h	21;"	d
MAX_DELAY_MS	include/common/time.h	50;"	d
MAX_HDR_HISTORY	include/common/defaults.h	68;"	d
MAX_HOSTNAME_LEN	include/common/defaults.h	183;"	d
MAX_HTTP_HDR	include/common/defaults.h	63;"	d
MAX_LINE_ARGS	include/common/defaults.h	52;"	d
MAX_MATCH	include/common/defaults.h	58;"	d
MAX_POLLERS	include/types/fd.h	130;"	d
MAX_POLL_EVENTS	include/common/defaults.h	103;"	d
MAX_READ_POLL_LOOPS	include/common/defaults.h	74;"	d
MAX_SIGNAL	include/common/defaults.h	178;"	d
MAX_SPLICE_AT_ONCE	src/stream_sock.c	90;"	d	file:
MAX_START_RETRIES	src/haproxy.c	134;"	d	file:
MAX_STATS_ARGS	include/common/defaults.h	55;"	d
MAX_SYSLOG_LEN	include/types/log.h	30;"	d
MAX_WRITE_POLL_LOOPS	include/common/defaults.h	90;"	d
MEM_F_SHARED	include/common/memory.h	117;"	d
METH_FIELD	contrib/halog/halog.c	34;"	d	file:
MIN	include/common/tools.h	28;"	d
MINTIME	include/common/time.h	54;"	d
MINUTE	include/common/time.h	31;"	d
MIN_RECV_AT_ONCE_ENOUGH	include/common/defaults.h	83;"	d
MIN_RETURN_EVENTS	src/ev_sepoll.c	150;"	d	file:
MIN_RET_FOR_READ_LOOP	include/common/defaults.h	97;"	d
MODE_CHECK	include/types/global.h	37;"	d
MODE_DAEMON	include/types/global.h	35;"	d
MODE_DEBUG	include/types/global.h	34;"	d
MODE_FOREGROUND	include/types/global.h	40;"	d
MODE_QUIET	include/types/global.h	36;"	d
MODE_STARTING	include/types/global.h	39;"	d
MODE_VERBOSE	include/types/global.h	38;"	d
MSG_DONTWAIT	include/common/compat.h	57;"	d
MSG_MORE	include/common/compat.h	62;"	d
MSG_NOSIGNAL	include/common/compat.h	50;"	d
MS_TO_TICKS	include/common/ticks.h	63;"	d
MyPackage	examples/check	/^package MyPackage;$/;"	p
MyPackage::TCP	examples/check	/^sub TCP$/;"	s
MyPackage::get	examples/check	/^sub get$/;"	s
MyPackage::parse_conf	examples/check	/^sub parse_conf$/;"	s
MyPackage::process_request	examples/check	/^sub process_request$/;"	s
MyPackage::regex	examples/check	/^sub regex$/;"	s
NB_LOG_FACILITIES	include/types/log.h	31;"	d
NB_LOG_LEVELS	include/types/log.h	32;"	d
NSERV	tests/ip-hash.c	16;"	d	file:
NSERV	tests/uri_hash.c	5;"	d	file:
OBJS	Makefile	/^OBJS = src\/haproxy.o src\/sessionhash.o src\/base64.o src\/protocols.o \\$/;"	m
OBJS	contrib/halog/Makefile	/^OBJS     = halog halog64$/;"	m
OID_HAPROXY	contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY => '1.3.6.1.4.1.29385.106';$/;"	c
OID_HAPROXY_INFO	contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY_INFO => OID_HAPROXY . '.2';$/;"	c
OID_HAPROXY_STATS	contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY_STATS => OID_HAPROXY . '.1';$/;"	c
OPTIMIZE	contrib/halog/Makefile	/^OPTIMIZE = -O3$/;"	m
OPTIONS_CFLAGS	Makefile	/^OPTIONS_CFLAGS  =$/;"	m
OPTIONS_LDFLAGS	Makefile	/^OPTIONS_LDFLAGS =$/;"	m
OPTIONS_OBJS	Makefile	/^OPTIONS_OBJS    =$/;"	m
PATTERN_FETCH_REQ	include/types/pattern.h	38;"	d
PATTERN_FETCH_RTR	include/types/pattern.h	39;"	d
PATTERN_TYPES	include/types/pattern.h	/^	PATTERN_TYPES$/;"	e	enum:__anon15
PATTERN_TYPE_INTEGER	include/types/pattern.h	/^	PATTERN_TYPE_INTEGER = 1,  \/* unsigned 32bits integer type *\/$/;"	e	enum:__anon15
PATTERN_TYPE_IP	include/types/pattern.h	/^	PATTERN_TYPE_IP      = 0,  \/* ipv4 type *\/$/;"	e	enum:__anon15
PATTERN_TYPE_STRING	include/types/pattern.h	/^	PATTERN_TYPE_STRING  = 2,  \/* char string type *\/$/;"	e	enum:__anon15
PCREDIR	Makefile	/^PCREDIR	        := $(shell pcre-config --prefix 2>\/dev\/null || echo \/usr\/local)$/;"	m
PCREDIR	Makefile	/^PCREDIR         := $(shell pcre-config --prefix 2>\/dev\/null || echo \/usr\/local)$/;"	m
PERSIST_TYPE_FORCE	include/types/proto_http.h	/^	PERSIST_TYPE_FORCE,             \/* force-persist *\/$/;"	e	enum:__anon33
PERSIST_TYPE_IGNORE	include/types/proto_http.h	/^	PERSIST_TYPE_IGNORE,            \/* ignore-persist *\/$/;"	e	enum:__anon33
PERSIST_TYPE_NONE	include/types/proto_http.h	/^	PERSIST_TYPE_NONE = 0,          \/* no persistence *\/$/;"	e	enum:__anon33
POWEROF2	include/common/standard.h	43;"	d
PREFIX	Makefile	/^PREFIX = \/usr\/local$/;"	m
PRODUCT_BRANCH	include/common/version.h	34;"	d
PRODUCT_BRANCH	include/common/version.h	36;"	d
PRODUCT_NAME	include/common/version.h	28;"	d
PRODUCT_NAME	include/common/version.h	30;"	d
PRODUCT_URL	include/common/version.h	40;"	d
PRODUCT_URL	include/common/version.h	42;"	d
PRODUCT_URL_DOC	include/common/version.h	52;"	d
PRODUCT_URL_DOC	include/common/version.h	54;"	d
PRODUCT_URL_UPD	include/common/version.h	46;"	d
PRODUCT_URL_UPD	include/common/version.h	48;"	d
PROTO_NAME_LEN	include/types/protocols.h	38;"	d
PR_CAP_BE	include/types/proxy.h	67;"	d
PR_CAP_FE	include/types/proxy.h	66;"	d
PR_CAP_LISTEN	include/types/proxy.h	69;"	d
PR_CAP_NONE	include/types/proxy.h	65;"	d
PR_CAP_RS	include/types/proxy.h	68;"	d
PR_MODE_HEALTH	include/types/proxy.h	62;"	d
PR_MODE_HTTP	include/types/proxy.h	61;"	d
PR_MODE_TCP	include/types/proxy.h	60;"	d
PR_O2_AS_M_ANY	include/types/proxy.h	135;"	d
PR_O2_AS_M_PP	include/types/proxy.h	133;"	d
PR_O2_AS_M_QS	include/types/proxy.h	134;"	d
PR_O2_AS_PFX	include/types/proxy.h	130;"	d
PR_O2_AS_REQL	include/types/proxy.h	129;"	d
PR_O2_CHK_SNDST	include/types/proxy.h	139;"	d
PR_O2_CLFLOG	include/types/proxy.h	123;"	d
PR_O2_COOK_PSV	include/types/proxy.h	151;"	d
PR_O2_EXP_INV	include/types/proxy.h	150;"	d
PR_O2_EXP_NONE	include/types/proxy.h	144;"	d
PR_O2_EXP_RSTR	include/types/proxy.h	148;"	d
PR_O2_EXP_RSTS	include/types/proxy.h	146;"	d
PR_O2_EXP_STR	include/types/proxy.h	147;"	d
PR_O2_EXP_STS	include/types/proxy.h	145;"	d
PR_O2_EXP_TYPE	include/types/proxy.h	149;"	d
PR_O2_FAKE_KA	include/types/proxy.h	141;"	d
PR_O2_INDEPSTR	include/types/proxy.h	125;"	d
PR_O2_LDAP_CHK	include/types/proxy.h	142;"	d
PR_O2_LOGERRORS	include/types/proxy.h	119;"	d
PR_O2_LOGHCHKS	include/types/proxy.h	124;"	d
PR_O2_MYSQL_CHK	include/types/proxy.h	137;"	d
PR_O2_NOLOGNORM	include/types/proxy.h	118;"	d
PR_O2_RDPC_PRST	include/types/proxy.h	122;"	d
PR_O2_REQBUG_OK	include/types/proxy.h	116;"	d
PR_O2_RSPBUG_OK	include/types/proxy.h	117;"	d
PR_O2_SMARTACC	include/types/proxy.h	120;"	d
PR_O2_SMARTCON	include/types/proxy.h	121;"	d
PR_O2_SOCKSTAT	include/types/proxy.h	126;"	d
PR_O2_SPLIC_ANY	include/types/proxy.h	115;"	d
PR_O2_SPLIC_AUT	include/types/proxy.h	114;"	d
PR_O2_SPLIC_REQ	include/types/proxy.h	112;"	d
PR_O2_SPLIC_RTR	include/types/proxy.h	113;"	d
PR_O2_SSL3_CHK	include/types/proxy.h	140;"	d
PR_O2_USE_PXHDR	include/types/proxy.h	138;"	d
PR_O_ABRT_CLOSE	include/types/proxy.h	96;"	d
PR_O_BIND_SRC	include/types/proxy.h	82;"	d
PR_O_CHK_CACHE	include/types/proxy.h	90;"	d
PR_O_CONTSTATS	include/types/proxy.h	106;"	d
PR_O_COOK_ANY	include/types/proxy.h	78;"	d
PR_O_COOK_IND	include/types/proxy.h	75;"	d
PR_O_COOK_INS	include/types/proxy.h	76;"	d
PR_O_COOK_NOC	include/types/proxy.h	84;"	d
PR_O_COOK_PFX	include/types/proxy.h	77;"	d
PR_O_COOK_POST	include/types/proxy.h	85;"	d
PR_O_COOK_RW	include/types/proxy.h	74;"	d
PR_O_DISABLE404	include/types/proxy.h	108;"	d
PR_O_FORCE_CLO	include/types/proxy.h	94;"	d
PR_O_FWDFOR	include/types/proxy.h	81;"	d
PR_O_HTTP_CHK	include/types/proxy.h	86;"	d
PR_O_HTTP_CLOSE	include/types/proxy.h	89;"	d
PR_O_HTTP_PROXY	include/types/proxy.h	107;"	d
PR_O_KEEPALIVE	include/types/proxy.h	80;"	d
PR_O_LOGASAP	include/types/proxy.h	88;"	d
PR_O_NULLNOLOG	include/types/proxy.h	83;"	d
PR_O_ORGTO	include/types/proxy.h	109;"	d
PR_O_PERSIST	include/types/proxy.h	87;"	d
PR_O_REDISP	include/types/proxy.h	72;"	d
PR_O_SERVER_CLO	include/types/proxy.h	105;"	d
PR_O_SMTP_CHK	include/types/proxy.h	79;"	d
PR_O_TCP_CLI_KA	include/types/proxy.h	91;"	d
PR_O_TCP_NOLING	include/types/proxy.h	95;"	d
PR_O_TCP_SRV_KA	include/types/proxy.h	92;"	d
PR_O_TPXY_ADDR	include/types/proxy.h	99;"	d
PR_O_TPXY_CIP	include/types/proxy.h	100;"	d
PR_O_TPXY_CLI	include/types/proxy.h	101;"	d
PR_O_TPXY_DYN	include/types/proxy.h	102;"	d
PR_O_TPXY_MASK	include/types/proxy.h	103;"	d
PR_O_TRANSP	include/types/proxy.h	73;"	d
PR_O_USE_ALL_BK	include/types/proxy.h	93;"	d
PR_REQ_ACL_ACT_ALLOW	include/types/auth.h	/^	PR_REQ_ACL_ACT_ALLOW,$/;"	e	enum:__anon26
PR_REQ_ACL_ACT_DENY	include/types/auth.h	/^	PR_REQ_ACL_ACT_DENY,$/;"	e	enum:__anon26
PR_REQ_ACL_ACT_HTTP_AUTH	include/types/auth.h	/^	PR_REQ_ACL_ACT_HTTP_AUTH,$/;"	e	enum:__anon26
PR_REQ_ACL_ACT_MAX	include/types/auth.h	/^	PR_REQ_ACL_ACT_MAX$/;"	e	enum:__anon26
PR_REQ_ACL_ACT_UNKNOWN	include/types/auth.h	/^	PR_REQ_ACL_ACT_UNKNOWN = 0,$/;"	e	enum:__anon26
PR_STERROR	include/types/proxy.h	57;"	d
PR_STIDLE	include/types/proxy.h	53;"	d
PR_STNEW	include/types/proxy.h	52;"	d
PR_STPAUSED	include/types/proxy.h	56;"	d
PR_STRUN	include/types/proxy.h	54;"	d
PR_STSTOPPED	include/types/proxy.h	55;"	d
PTR_INT_TYPE	ebtree/ebpttree.h	37;"	d
QBITS	contrib/halog/halog.c	37;"	d	file:
RB_BLACK	include/common/rbtree.h	107;"	d
RB_RED	include/common/rbtree.h	106;"	d
RB_ROOT	include/common/rbtree.h	124;"	d
REDIRECT_FLAG_APPEND_SLASH	include/types/proto_http.h	/^	REDIRECT_FLAG_APPEND_SLASH = 2,	\/* append a slash if missing at the end *\/$/;"	e	enum:__anon31
REDIRECT_FLAG_DROP_QS	include/types/proto_http.h	/^	REDIRECT_FLAG_DROP_QS = 1,	\/* drop query string *\/$/;"	e	enum:__anon31
REDIRECT_FLAG_NONE	include/types/proto_http.h	/^	REDIRECT_FLAG_NONE = 0,$/;"	e	enum:__anon31
REDIRECT_TYPE_LOCATION	include/types/proto_http.h	/^	REDIRECT_TYPE_LOCATION,         \/* location redirect *\/$/;"	e	enum:__anon32
REDIRECT_TYPE_NONE	include/types/proto_http.h	/^	REDIRECT_TYPE_NONE = 0,         \/* no redirection *\/$/;"	e	enum:__anon32
REDIRECT_TYPE_PREFIX	include/types/proto_http.h	/^	REDIRECT_TYPE_PREFIX,           \/* prefix redirect *\/$/;"	e	enum:__anon32
REGEX	Makefile	/^REGEX = libc$/;"	m
REGPRM1	include/common/compiler.h	46;"	d
REGPRM1	include/common/compiler.h	48;"	d
REGPRM2	include/common/compiler.h	54;"	d
REGPRM2	include/common/compiler.h	56;"	d
REGPRM3	include/common/compiler.h	62;"	d
REGPRM3	include/common/compiler.h	64;"	d
REQURI_LEN	include/common/defaults.h	43;"	d
SBINDIR	Makefile	/^SBINDIR = $(PREFIX)\/sbin$/;"	m
SCHEDULER_RESOLUTION	include/common/config.h	33;"	d
SEC	include/common/time.h	30;"	d
SERVER_FIELD	contrib/halog/halog.c	29;"	d	file:
SESSION_HASH_H	include/common/sessionhash.h	2;"	d
SETNOW	include/common/time.h	55;"	d
SHUT_RD	include/common/compat.h	41;"	d
SHUT_WR	include/common/compat.h	45;"	d
SILENT_DEFINE	Makefile	/^SILENT_DEFINE =$/;"	m
SI_ET_CONN_ABRT	include/types/stream_interface.h	/^	SI_ET_CONN_ABRT  = 0x0020,  \/* connection aborted by external cause (eg: abort) *\/$/;"	e	enum:__anon40
SI_ET_CONN_ERR	include/types/stream_interface.h	/^	SI_ET_CONN_ERR   = 0x0010,  \/* connection error (eg: no server available) *\/$/;"	e	enum:__anon40
SI_ET_CONN_OTHER	include/types/stream_interface.h	/^	SI_ET_CONN_OTHER = 0x0040,  \/* connection aborted for other reason (eg: 500) *\/$/;"	e	enum:__anon40
SI_ET_CONN_TO	include/types/stream_interface.h	/^	SI_ET_CONN_TO    = 0x0008,  \/* connection timeout *\/$/;"	e	enum:__anon40
SI_ET_DATA_ABRT	include/types/stream_interface.h	/^	SI_ET_DATA_ABRT  = 0x0200,  \/* data phase aborted by external cause *\/$/;"	e	enum:__anon40
SI_ET_DATA_ERR	include/types/stream_interface.h	/^	SI_ET_DATA_ERR   = 0x0100,  \/* error during data phase *\/$/;"	e	enum:__anon40
SI_ET_DATA_TO	include/types/stream_interface.h	/^	SI_ET_DATA_TO    = 0x0080,  \/* timeout during data phase *\/$/;"	e	enum:__anon40
SI_ET_NONE	include/types/stream_interface.h	/^	SI_ET_NONE       = 0x0000,  \/* no error yet, leave it to zero *\/$/;"	e	enum:__anon40
SI_ET_QUEUE_ABRT	include/types/stream_interface.h	/^	SI_ET_QUEUE_ABRT = 0x0004,  \/* aborted in queue by external cause *\/$/;"	e	enum:__anon40
SI_ET_QUEUE_ERR	include/types/stream_interface.h	/^	SI_ET_QUEUE_ERR  = 0x0002,  \/* queue error (eg: full) *\/$/;"	e	enum:__anon40
SI_ET_QUEUE_TO	include/types/stream_interface.h	/^	SI_ET_QUEUE_TO   = 0x0001,  \/* queue timeout *\/$/;"	e	enum:__anon40
SI_FL_CAP_SPLICE	include/types/stream_interface.h	77;"	d
SI_FL_CAP_SPLTCP	include/types/stream_interface.h	/^	SI_FL_CAP_SPLTCP = 0x0010,  \/* splicing possible from\/to TCP *\/$/;"	e	enum:__anon41
SI_FL_DONT_WAKE	include/types/stream_interface.h	/^	SI_FL_DONT_WAKE  = 0x0020,  \/* resync in progress, don't wake up *\/$/;"	e	enum:__anon41
SI_FL_ERR	include/types/stream_interface.h	/^	SI_FL_ERR        = 0x0002,  \/* a non-recoverable error has occurred *\/$/;"	e	enum:__anon41
SI_FL_EXP	include/types/stream_interface.h	/^	SI_FL_EXP        = 0x0001,  \/* timeout has expired *\/$/;"	e	enum:__anon41
SI_FL_INDEP_STR	include/types/stream_interface.h	/^	SI_FL_INDEP_STR  = 0x0040,  \/* independant streams = don't update rex on write *\/$/;"	e	enum:__anon41
SI_FL_NOLINGER	include/types/stream_interface.h	/^	SI_FL_NOLINGER   = 0x0080,  \/* may close without lingering. One-shot. *\/$/;"	e	enum:__anon41
SI_FL_NONE	include/types/stream_interface.h	/^	SI_FL_NONE       = 0x0000,  \/* nothing *\/$/;"	e	enum:__anon41
SI_FL_WAIT_DATA	include/types/stream_interface.h	/^	SI_FL_WAIT_DATA  = 0x0008,  \/* waiting for more data to send *\/$/;"	e	enum:__anon41
SI_FL_WAIT_ROOM	include/types/stream_interface.h	/^	SI_FL_WAIT_ROOM  = 0x0004,  \/* waiting for space to store incoming data *\/$/;"	e	enum:__anon41
SI_ST_ASS	include/types/stream_interface.h	/^	SI_ST_ASS,               \/* server just assigned to this interface *\/$/;"	e	enum:__anon39
SI_ST_CER	include/types/stream_interface.h	/^	SI_ST_CER,               \/* [transient] previous connection attempt failed (resource released) *\/$/;"	e	enum:__anon39
SI_ST_CLO	include/types/stream_interface.h	/^	SI_ST_CLO,               \/* stream intf closed, might not existing anymore. Buffers shut. *\/$/;"	e	enum:__anon39
SI_ST_CON	include/types/stream_interface.h	/^	SI_ST_CON,               \/* initiated connection request (resource exists) *\/$/;"	e	enum:__anon39
SI_ST_DIS	include/types/stream_interface.h	/^	SI_ST_DIS,               \/* [transient] disconnected from other side, but cleanup not done yet *\/$/;"	e	enum:__anon39
SI_ST_EST	include/types/stream_interface.h	/^	SI_ST_EST,               \/* connection established (resource exists) *\/$/;"	e	enum:__anon39
SI_ST_INI	include/types/stream_interface.h	/^	SI_ST_INI = 0,           \/* interface not sollicitated yet *\/$/;"	e	enum:__anon39
SI_ST_QUE	include/types/stream_interface.h	/^	SI_ST_QUE,               \/* interface waiting in queue *\/$/;"	e	enum:__anon39
SI_ST_REQ	include/types/stream_interface.h	/^	SI_ST_REQ,               \/* [transient] connection initiation desired and not started yet *\/$/;"	e	enum:__anon39
SI_ST_TAR	include/types/stream_interface.h	/^	SI_ST_TAR,               \/* interface in turn-around state after failed connect attempt *\/$/;"	e	enum:__anon39
SKIP_CHAR	contrib/halog/halog.c	39;"	d	file:
SMALL_OPTS	Makefile	/^SMALL_OPTS =$/;"	m
SN_ADDR_SET	include/types/session.h	47;"	d
SN_ASSIGNED	include/types/session.h	46;"	d
SN_BE_ASSIGNED	include/types/session.h	48;"	d
SN_CONN_TAR	include/types/session.h	55;"	d
SN_CURR_SESS	include/types/session.h	52;"	d
SN_DIRECT	include/types/session.h	45;"	d
SN_ERR_CLICL	include/types/session.h	62;"	d
SN_ERR_CLITO	include/types/session.h	61;"	d
SN_ERR_INTERNAL	include/types/session.h	67;"	d
SN_ERR_MASK	include/types/session.h	68;"	d
SN_ERR_NONE	include/types/session.h	60;"	d
SN_ERR_PRXCOND	include/types/session.h	65;"	d
SN_ERR_RESOURCE	include/types/session.h	66;"	d
SN_ERR_SHIFT	include/types/session.h	69;"	d
SN_ERR_SRVCL	include/types/session.h	64;"	d
SN_ERR_SRVTO	include/types/session.h	63;"	d
SN_FINST_C	include/types/session.h	74;"	d
SN_FINST_D	include/types/session.h	76;"	d
SN_FINST_H	include/types/session.h	75;"	d
SN_FINST_L	include/types/session.h	77;"	d
SN_FINST_MASK	include/types/session.h	80;"	d
SN_FINST_Q	include/types/session.h	78;"	d
SN_FINST_R	include/types/session.h	73;"	d
SN_FINST_SHIFT	include/types/session.h	81;"	d
SN_FINST_T	include/types/session.h	79;"	d
SN_FORCE_PRST	include/types/session.h	50;"	d
SN_FRT_ADDR_SET	include/types/session.h	53;"	d
SN_IGNORE_PRST	include/types/session.h	84;"	d
SN_MONITOR	include/types/session.h	51;"	d
SN_REDIRECTABLE	include/types/session.h	56;"	d
SN_REDISP	include/types/session.h	54;"	d
SN_TUNNEL	include/types/session.h	57;"	d
SOURCE_FIELD	contrib/halog/halog.c	27;"	d	file:
SO_REUSEPORT	include/common/compat.h	88;"	d
SO_REUSEPORT	include/common/compat.h	90;"	d
SPLICE_FULL_HINT	src/stream_sock.c	86;"	d	file:
SPLICE_F_MORE	src/stream_sock.c	60;"	d	file:
SPLICE_F_MOVE	src/stream_sock.c	52;"	d	file:
SPLICE_F_NONBLOCK	src/stream_sock.c	56;"	d	file:
SRV_BACKUP	include/types/server.h	44;"	d
SRV_BIND_SRC	include/types/server.h	46;"	d
SRV_CHECKED	include/types/server.h	47;"	d
SRV_CHK_DISABLE	include/types/server.h	68;"	d
SRV_CHK_ERROR	include/types/server.h	66;"	d
SRV_CHK_INTER_THRES	include/common/defaults.h	163;"	d
SRV_CHK_RUNNING	include/types/server.h	67;"	d
SRV_CHK_UNKNOWN	include/types/server.h	65;"	d
SRV_EWGHT_MAX	include/types/server.h	74;"	d
SRV_EWGHT_RANGE	include/types/server.h	73;"	d
SRV_GOINGDOWN	include/types/server.h	48;"	d
SRV_MAINTAIN	include/types/server.h	50;"	d
SRV_MAPPORTS	include/types/server.h	45;"	d
SRV_RUNNING	include/types/server.h	43;"	d
SRV_STATUS_FULL	include/types/server.h	61;"	d
SRV_STATUS_INTERNAL	include/types/server.h	59;"	d
SRV_STATUS_NOSRV	include/types/server.h	60;"	d
SRV_STATUS_OK	include/types/server.h	58;"	d
SRV_STATUS_QUEUED	include/types/server.h	62;"	d
SRV_TPROXY_ADDR	include/types/server.h	51;"	d
SRV_TPROXY_CIP	include/types/server.h	52;"	d
SRV_TPROXY_CLI	include/types/server.h	53;"	d
SRV_TPROXY_DYN	include/types/server.h	54;"	d
SRV_TPROXY_MASK	include/types/server.h	55;"	d
SRV_UWGHT_MAX	include/types/server.h	72;"	d
SRV_UWGHT_RANGE	include/types/server.h	71;"	d
SRV_WARMINGUP	include/types/server.h	49;"	d
SSP_O_HCHK	src/checks.c	146;"	d	file:
STATS_DEFAULT_REALM	include/common/uri_auth.h	59;"	d
STATS_DEFAULT_REALM	include/common/uri_auth.h	61;"	d
STATS_DEFAULT_URI	include/common/uri_auth.h	52;"	d
STATS_DEFAULT_URI	include/common/uri_auth.h	54;"	d
STATS_IID	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_IID => 27;$/;"	c
STATS_PXNAME	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_PXNAME => 0;$/;"	c
STATS_SID	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_SID => 28;$/;"	c
STATS_SVNAME	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_SVNAME => 1;$/;"	c
STATS_TYPE	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_TYPE => 32;$/;"	c
STATS_TYPE_BE	include/proto/dumpstats.h	40;"	d
STATS_TYPE_FE	include/proto/dumpstats.h	39;"	d
STATS_TYPE_SO	include/proto/dumpstats.h	42;"	d
STATS_TYPE_SV	include/proto/dumpstats.h	41;"	d
STATS_VERSION_STRING	include/common/defaults.h	171;"	d
STATUS_FIELD	contrib/halog/halog.c	31;"	d	file:
STAT_ADMIN	include/proto/dumpstats.h	36;"	d
STAT_BOUND	include/proto/dumpstats.h	37;"	d
STAT_CLI_END	include/proto/dumpstats.h	46;"	d
STAT_CLI_GETREQ	include/proto/dumpstats.h	47;"	d
STAT_CLI_INIT	include/proto/dumpstats.h	45;"	d
STAT_CLI_OUTPUT	include/proto/dumpstats.h	48;"	d
STAT_CLI_O_ERR	include/proto/dumpstats.h	54;"	d
STAT_CLI_O_INFO	include/proto/dumpstats.h	52;"	d
STAT_CLI_O_SESS	include/proto/dumpstats.h	53;"	d
STAT_CLI_PRINT	include/proto/dumpstats.h	50;"	d
STAT_CLI_PROMPT	include/proto/dumpstats.h	49;"	d
STAT_FMT_CSV	include/proto/dumpstats.h	31;"	d
STAT_HIDE_DOWN	include/proto/dumpstats.h	34;"	d
STAT_NO_REFRESH	include/proto/dumpstats.h	35;"	d
STAT_SHOW_INFO	include/proto/dumpstats.h	33;"	d
STAT_SHOW_STAT	include/proto/dumpstats.h	32;"	d
STAT_STATUS_DENY	include/proto/dumpstats.h	61;"	d
STAT_STATUS_DONE	include/proto/dumpstats.h	58;"	d
STAT_STATUS_EXCD	include/proto/dumpstats.h	60;"	d
STAT_STATUS_NONE	include/proto/dumpstats.h	59;"	d
STAT_STATUS_UNKN	include/proto/dumpstats.h	57;"	d
STKTABLE_TYPEFLAG_CUSTOMKEYSIZE	include/types/stick_table.h	41;"	d
STKTABLE_TYPES	include/types/stick_table.h	38;"	d
STKTABLE_TYPE_INTEGER	include/types/stick_table.h	35;"	d
STKTABLE_TYPE_IP	include/types/stick_table.h	34;"	d
STKTABLE_TYPE_STRING	include/types/stick_table.h	36;"	d
STK_IS_MATCH	include/types/proxy.h	155;"	d
STK_IS_STORE	include/types/proxy.h	156;"	d
STK_ON_RSP	include/types/proxy.h	157;"	d
ST_CONVDONE	include/common/uri_auth.h	33;"	d
ST_HIDEVER	include/common/uri_auth.h	29;"	d
ST_SHDESC	include/common/uri_auth.h	31;"	d
ST_SHLGNDS	include/common/uri_auth.h	32;"	d
ST_SHNODE	include/common/uri_auth.h	30;"	d
SUBVERS	Makefile	/^SUBVERS := $(shell cat SUBVERS 2>\/dev\/null || touch SUBVERS)$/;"	m
SUBVERS	Makefile	/^SUBVERS := $(shell comms=`git log --no-merges v$(VERSION).. 2>\/dev\/null |grep -c ^commit `; [ $$comms -gt 0 ] && echo "-$$comms" )$/;"	m
SYSLOG_PORT	include/types/log.h	33;"	d
SuperFastHash	tests/test_hashes.c	/^uint32_t SuperFastHash (const char * data, int len) {$/;"	f	signature:(const char * data, int len)
SuperFastHash	tests/uri_hash.c	/^	count_hash_results(SuperFastHash(line, strlen(line)), counts_SuperFastHash);$/;"	p	file:	signature:(line, strlen(line))
SuperFastHash	tests/uri_hash.c	/^uint32_t SuperFastHash (const char * data, int len) {$/;"	f	signature:(const char * data, int len)
SuperFastHash2	tests/test_hashes.c	/^uint32_t SuperFastHash2 (const char * data, int len) {$/;"	f	signature:(const char * data, int len)
SuperFastHash2	tests/uri_hash.c	/^	count_hash_results(SuperFastHash2(line, strlen(line)), counts_SuperFastHash2);$/;"	p	file:	signature:(line, strlen(line))
SuperFastHash2	tests/uri_hash.c	/^uint32_t SuperFastHash2 (const char * data, int len) {$/;"	f	signature:(const char * data, int len)
TABLEMASK	include/common/sessionhash.h	21;"	d
TABLESHIFT	include/common/sessionhash.h	18;"	d
TABLESIZE	include/common/sessionhash.h	20;"	d
TARGET	Makefile	/^TARGET =$/;"	m
TARGET_CFLAGS	Makefile	/^  TARGET_CFLAGS  = $(if $(filter 1.5.%, $(shell uname -r)), -DUSE_IPV6 -DAF_INET6=23 -DINET6_ADDRSTRLEN=46, )$/;"	m
TARGET_CFLAGS	Makefile	/^  TARGET_CFLAGS  = -fomit-frame-pointer -DFD_SETSIZE=65536 -D_REENTRANT$/;"	m
TARGET_LDFLAGS	Makefile	/^  TARGET_LDFLAGS = -lnsl -lsocket$/;"	m
TASK_RUNNING	include/types/task.h	33;"	d
TASK_SLEEPING	include/types/task.h	32;"	d
TASK_WOKEN_ANY	include/types/task.h	43;"	d
TASK_WOKEN_INIT	include/types/task.h	34;"	d
TASK_WOKEN_IO	include/types/task.h	36;"	d
TASK_WOKEN_MSG	include/types/task.h	38;"	d
TASK_WOKEN_OTHER	include/types/task.h	40;"	d
TASK_WOKEN_RES	include/types/task.h	39;"	d
TASK_WOKEN_SIGNAL	include/types/task.h	37;"	d
TASK_WOKEN_TIMER	include/types/task.h	35;"	d
TBLCHKINT	include/common/appsession.h	7;"	d
TCP	examples/check	/^sub TCP$/;"	s
TCP_ACT_ACCEPT	include/types/proto_tcp.h	/^	TCP_ACT_ACCEPT = 1,$/;"	e	enum:__anon63
TCP_ACT_REJECT	include/types/proto_tcp.h	/^	TCP_ACT_REJECT = 2,$/;"	e	enum:__anon63
TCP_NODELAY	include/common/compat.h	37;"	d
TERM_CODES_FIELD	contrib/halog/halog.c	32;"	d	file:
TICKS_TO_MS	include/common/ticks.h	64;"	d
TICK_ETERNITY	include/common/ticks.h	58;"	d
TIMER_LOOK_BACK	include/proto/task.h	78;"	d
TIME_ETERNITY	include/common/time.h	45;"	d
TIME_FIELD	contrib/halog/halog.c	30;"	d	file:
TIME_UNIT_DAY	include/common/standard.h	355;"	d
TIME_UNIT_HOUR	include/common/standard.h	354;"	d
TIME_UNIT_MASK	include/common/standard.h	356;"	d
TIME_UNIT_MIN	include/common/standard.h	353;"	d
TIME_UNIT_MS	include/common/standard.h	351;"	d
TIME_UNIT_S	include/common/standard.h	352;"	d
TIME_UNIT_US	include/common/standard.h	350;"	d
TPROXY_ALLOC	include/import/ip_tproxy.h	/^	TPROXY_ALLOC,$/;"	e	enum:__anon64
TPROXY_ASSIGN	include/import/ip_tproxy.h	/^	TPROXY_ASSIGN,$/;"	e	enum:__anon64
TPROXY_CONNECT	include/import/ip_tproxy.h	/^	TPROXY_CONNECT$/;"	e	enum:__anon64
TPROXY_FLAGS	include/import/ip_tproxy.h	/^	TPROXY_FLAGS,$/;"	e	enum:__anon64
TPROXY_QUERY	include/import/ip_tproxy.h	/^	TPROXY_QUERY,$/;"	e	enum:__anon64
TPROXY_UNASSIGN	include/import/ip_tproxy.h	/^	TPROXY_UNASSIGN,$/;"	e	enum:__anon64
TPROXY_VERSION	include/import/ip_tproxy.h	/^	TPROXY_VERSION = 0,$/;"	e	enum:__anon64
TRACE	include/common/debug.h	48;"	d
TT_ANON	include/types/session.h	/^	TT_ANON     = 1,$/;"	e	enum:__anon6
TT_BIT_SHIFT	include/types/session.h	106;"	d
TT_CLIENT	include/types/session.h	/^	TT_CLIENT   = 0x10,$/;"	e	enum:__anon6
TT_CLIENT_1	include/types/session.h	/^	TT_CLIENT_1,$/;"	e	enum:__anon6
TT_CLIENT_2	include/types/session.h	/^	TT_CLIENT_2,$/;"	e	enum:__anon6
TT_HTTP_CLI	include/types/session.h	/^	TT_HTTP_CLI = 0x20,$/;"	e	enum:__anon6
TT_HTTP_CLI_1	include/types/session.h	/^	TT_HTTP_CLI_1,$/;"	e	enum:__anon6
TT_HTTP_CLI_10	include/types/session.h	/^	TT_HTTP_CLI_10,$/;"	e	enum:__anon6
TT_HTTP_CLI_2	include/types/session.h	/^	TT_HTTP_CLI_2,$/;"	e	enum:__anon6
TT_HTTP_CLI_3	include/types/session.h	/^	TT_HTTP_CLI_3,$/;"	e	enum:__anon6
TT_HTTP_CLI_4	include/types/session.h	/^	TT_HTTP_CLI_4,$/;"	e	enum:__anon6
TT_HTTP_CLI_5	include/types/session.h	/^	TT_HTTP_CLI_5,$/;"	e	enum:__anon6
TT_HTTP_CLI_6	include/types/session.h	/^	TT_HTTP_CLI_6,$/;"	e	enum:__anon6
TT_HTTP_CLI_7	include/types/session.h	/^	TT_HTTP_CLI_7,$/;"	e	enum:__anon6
TT_HTTP_CLI_8	include/types/session.h	/^	TT_HTTP_CLI_8,$/;"	e	enum:__anon6
TT_HTTP_CLI_9	include/types/session.h	/^	TT_HTTP_CLI_9,$/;"	e	enum:__anon6
TT_HTTP_CNT	include/types/session.h	/^	TT_HTTP_CNT = 0x40,$/;"	e	enum:__anon6
TT_HTTP_CNT_1	include/types/session.h	/^	TT_HTTP_CNT_1,$/;"	e	enum:__anon6
TT_HTTP_SRV	include/types/session.h	/^	TT_HTTP_SRV = 0x30,$/;"	e	enum:__anon6
TT_HTTP_SRV_1	include/types/session.h	/^	TT_HTTP_SRV_1,$/;"	e	enum:__anon6
TT_HTTP_SRV_10	include/types/session.h	/^	TT_HTTP_SRV_10,$/;"	e	enum:__anon6
TT_HTTP_SRV_11	include/types/session.h	/^	TT_HTTP_SRV_11,$/;"	e	enum:__anon6
TT_HTTP_SRV_12	include/types/session.h	/^	TT_HTTP_SRV_12,$/;"	e	enum:__anon6
TT_HTTP_SRV_13	include/types/session.h	/^	TT_HTTP_SRV_13,$/;"	e	enum:__anon6
TT_HTTP_SRV_14	include/types/session.h	/^	TT_HTTP_SRV_14,$/;"	e	enum:__anon6
TT_HTTP_SRV_2	include/types/session.h	/^	TT_HTTP_SRV_2,$/;"	e	enum:__anon6
TT_HTTP_SRV_3	include/types/session.h	/^	TT_HTTP_SRV_3,$/;"	e	enum:__anon6
TT_HTTP_SRV_4	include/types/session.h	/^	TT_HTTP_SRV_4,$/;"	e	enum:__anon6
TT_HTTP_SRV_5	include/types/session.h	/^	TT_HTTP_SRV_5,$/;"	e	enum:__anon6
TT_HTTP_SRV_6	include/types/session.h	/^	TT_HTTP_SRV_6,$/;"	e	enum:__anon6
TT_HTTP_SRV_7	include/types/session.h	/^	TT_HTTP_SRV_7,$/;"	e	enum:__anon6
TT_HTTP_SRV_8	include/types/session.h	/^	TT_HTTP_SRV_8,$/;"	e	enum:__anon6
TT_HTTP_SRV_9	include/types/session.h	/^	TT_HTTP_SRV_9,$/;"	e	enum:__anon6
TT_HTTP_URI	include/types/session.h	/^	TT_HTTP_URI = 0x50,$/;"	e	enum:__anon6
TT_HTTP_URI_1	include/types/session.h	/^	TT_HTTP_URI_1,$/;"	e	enum:__anon6
TT_NONE	include/types/session.h	/^	TT_NONE     = 0,$/;"	e	enum:__anon6
TV_ETERNITY	include/common/time.h	37;"	d
TV_ETERNITY_MS	include/common/time.h	42;"	d
TX_CACHEABLE	include/types/proto_http.h	62;"	d
TX_CACHE_COOK	include/types/proto_http.h	63;"	d
TX_CACHE_SHIFT	include/types/proto_http.h	64;"	d
TX_CK_DOWN	include/types/proto_http.h	42;"	d
TX_CK_EXPIRED	include/types/proto_http.h	44;"	d
TX_CK_INVALID	include/types/proto_http.h	41;"	d
TX_CK_MASK	include/types/proto_http.h	46;"	d
TX_CK_NONE	include/types/proto_http.h	40;"	d
TX_CK_OLD	include/types/proto_http.h	45;"	d
TX_CK_SHIFT	include/types/proto_http.h	47;"	d
TX_CK_VALID	include/types/proto_http.h	43;"	d
TX_CLALLOW	include/types/proto_http.h	34;"	d
TX_CLDENY	include/types/proto_http.h	33;"	d
TX_CLTARPIT	include/types/proto_http.h	37;"	d
TX_CON_CLO_SET	include/types/proto_http.h	89;"	d
TX_CON_KAL_SET	include/types/proto_http.h	90;"	d
TX_CON_WANT_CLO	include/types/proto_http.h	86;"	d
TX_CON_WANT_KAL	include/types/proto_http.h	84;"	d
TX_CON_WANT_MSK	include/types/proto_http.h	87;"	d
TX_CON_WANT_SCL	include/types/proto_http.h	85;"	d
TX_CON_WANT_TUN	include/types/proto_http.h	83;"	d
TX_HDR_CONN_CLO	include/types/proto_http.h	101;"	d
TX_HDR_CONN_KAL	include/types/proto_http.h	102;"	d
TX_HDR_CONN_PRS	include/types/proto_http.h	100;"	d
TX_NOT_FIRST	include/types/proto_http.h	106;"	d
TX_REQ_CNT_LEN	include/types/proto_http.h	71;"	d
TX_REQ_TE_CHNK	include/types/proto_http.h	72;"	d
TX_REQ_VER_11	include/types/proto_http.h	67;"	d
TX_REQ_XFER_LEN	include/types/proto_http.h	96;"	d
TX_RES_CNT_LEN	include/types/proto_http.h	73;"	d
TX_RES_TE_CHNK	include/types/proto_http.h	74;"	d
TX_RES_VER_11	include/types/proto_http.h	68;"	d
TX_RES_XFER_LEN	include/types/proto_http.h	97;"	d
TX_SCK_DELETED	include/types/proto_http.h	52;"	d
TX_SCK_FOUND	include/types/proto_http.h	51;"	d
TX_SCK_INSERTED	include/types/proto_http.h	53;"	d
TX_SCK_MASK	include/types/proto_http.h	56;"	d
TX_SCK_NONE	include/types/proto_http.h	50;"	d
TX_SCK_PRESENT	include/types/proto_http.h	59;"	d
TX_SCK_REPLACED	include/types/proto_http.h	54;"	d
TX_SCK_SHIFT	include/types/proto_http.h	57;"	d
TX_SCK_UPDATED	include/types/proto_http.h	55;"	d
TX_SVALLOW	include/types/proto_http.h	36;"	d
TX_SVDENY	include/types/proto_http.h	35;"	d
TX_USE_PX_CONN	include/types/proto_http.h	103;"	d
TX_WAIT_NEXT_RQ	include/types/proto_http.h	98;"	d
U2A0	include/common/standard.h	69;"	d
U2A1	include/common/standard.h	70;"	d
U2A2	include/common/standard.h	71;"	d
U2A3	include/common/standard.h	72;"	d
U2A4	include/common/standard.h	73;"	d
U2A5	include/common/standard.h	74;"	d
U2A6	include/common/standard.h	75;"	d
U2A7	include/common/standard.h	76;"	d
U2A8	include/common/standard.h	77;"	d
U2A9	include/common/standard.h	78;"	d
U2H0	include/common/standard.h	81;"	d
U2H1	include/common/standard.h	82;"	d
U2H2	include/common/standard.h	83;"	d
U2H3	include/common/standard.h	84;"	d
U2H4	include/common/standard.h	85;"	d
U2H5	include/common/standard.h	86;"	d
U2H6	include/common/standard.h	87;"	d
U2H7	include/common/standard.h	88;"	d
U2H8	include/common/standard.h	89;"	d
U2H9	include/common/standard.h	90;"	d
UBOUND	include/common/standard.h	36;"	d
UPDATE_ANALYSERS	src/session.c	820;"	d	file:
URL_FIELD	contrib/halog/halog.c	35;"	d	file:
USE_CRYPT_H	Makefile	/^  USE_CRYPT_H     = implicit$/;"	m
USE_EPOLL	Makefile	/^  USE_EPOLL       = implicit$/;"	m
USE_GETSOCKNAME	Makefile	/^  USE_GETSOCKNAME = implicit$/;"	m
USE_KQUEUE	Makefile	/^  USE_KQUEUE     = implicit$/;"	m
USE_LIBCRYPT	Makefile	/^  USE_LIBCRYPT    = implicit$/;"	m
USE_LIBCRYPT	Makefile	/^  USE_LIBCRYPT   = implicit$/;"	m
USE_MY_EPOLL	Makefile	/^  USE_MY_EPOLL    = implicit$/;"	m
USE_NETFILTER	Makefile	/^  USE_NETFILTER   = implicit$/;"	m
USE_PCRE	Makefile	/^USE_PCRE = 1$/;"	m
USE_POLL	Makefile	/^  USE_POLL        = implicit$/;"	m
USE_POLL	Makefile	/^  USE_POLL       = implicit$/;"	m
USE_POLL	Makefile	/^  USE_POLL   = implicit$/;"	m
USE_SEPOLL	Makefile	/^  USE_SEPOLL      = implicit$/;"	m
USE_STATIC_PCRE	Makefile	/^USE_STATIC_PCRE = 1$/;"	m
USE_TPROXY	Makefile	/^  USE_TPROXY      = implicit$/;"	m
USE_TPROXY	Makefile	/^  USE_TPROXY     = implicit$/;"	m
USE_TPROXY	Makefile	/^  USE_TPROXY = implicit$/;"	m
USE_TPROXY	Makefile	/^USE_TPROXY = 1$/;"	m
VAR_ARRAY	include/common/compiler.h	31;"	d
VAR_ARRAY	include/common/compiler.h	33;"	d
VERBOSE_CFLAGS	Makefile	/^VERBOSE_CFLAGS = $(CFLAGS) $(TARGET_CFLAGS) $(SMALL_OPTS) $(DEFINE)$/;"	m
VERDATE	Makefile	/^VERDATE := $(shell cat VERDATE 2>\/dev\/null || touch VERDATE)$/;"	m
VERDATE	Makefile	/^VERDATE := $(shell date +%Y\/%m\/%d -d "`git log --pretty=fuller HEAD^.. 2>\/dev\/null | sed -ne '\/^CommitDate:\/{s\/\\(^[^ ]*:\\)\\|\\( [-+].*\\)\/\/gp;q}'`" )$/;"	m
VERSION	Makefile	/^VERSION := $(shell [ -d .git\/. ] && ref=`(git describe --tags) 2>\/dev\/null` && ref=$${ref%-g*} && echo "$${ref\\#v}")$/;"	m
VERSION	Makefile	/^VERSION := $(shell cat VERSION 2>\/dev\/null || touch VERSION)$/;"	m
WE_REALLY_KNOW_THAT_FDSETS_ARE_INTS	src/ev_poll.c	106;"	d	file:
Warning	include/proto/log.h	/^void Warning(const char *fmt, ...)$/;"	p	signature:(const char *fmt, ...)
Warning	src/log.c	/^void Warning(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
_COMMON_APPSESS_H	include/common/appsession.h	2;"	d
_COMMON_BASE64_H	include/common/base64.h	15;"	d
_COMMON_CFGPARSE_H	include/common/cfgparse.h	23;"	d
_COMMON_COMPAT_H	include/common/compat.h	23;"	d
_COMMON_COMPILER_H	include/common/compiler.h	23;"	d
_COMMON_CONFIG_H	include/common/config.h	23;"	d
_COMMON_DEBUG_H	include/common/debug.h	23;"	d
_COMMON_DEFAULTS_H	include/common/defaults.h	23;"	d
_COMMON_EPOLL_H	include/common/epoll.h	30;"	d
_COMMON_ERRORS_H	include/common/errors.h	23;"	d
_COMMON_MEMORY_H	include/common/memory.h	23;"	d
_COMMON_MINI_CLIST_H	include/common/mini-clist.h	8;"	d
_COMMON_REGEX_H	include/common/regex.h	23;"	d
_COMMON_STANDARD_H	include/common/standard.h	23;"	d
_COMMON_TEMPLATE_H	include/common/template.h	23;"	d
_COMMON_TICKS_H	include/common/ticks.h	53;"	d
_COMMON_TIME_H	include/common/time.h	23;"	d
_COMMON_TOOLS_H	include/common/tools.h	23;"	d
_COMMON_URI_AUTH_H	include/common/uri_auth.h	14;"	d
_COMMON_VERSION_H	include/common/version.h	23;"	d
_EB32TREE_H	ebtree/eb32tree.h	22;"	d
_EB64TREE_H	ebtree/eb64tree.h	22;"	d
_EBMBTREE_H	ebtree/ebmbtree.h	22;"	d
_EBPTTREE_H	ebtree/ebpttree.h	22;"	d
_EBSTTREE_H	ebtree/ebsttree.h	24;"	d
_EBTREE_H	ebtree/ebtree.h	257;"	d
_GNU_SOURCE	src/auth.c	15;"	d	file:
_GNU_SOURCE	src/stream_sock.c	13;"	d	file:
_IP_TPROXY_H	include/import/ip_tproxy.h	14;"	d
_LINUX_RBTREE_H	include/common/rbtree.h	95;"	d
_PROTO_ACL_H	include/proto/acl.h	23;"	d
_PROTO_AUTH_H	include/proto/auth.h	14;"	d
_PROTO_BACKEND_H	include/proto/backend.h	23;"	d
_PROTO_BUFFERS_H	include/proto/buffers.h	23;"	d
_PROTO_CHECKS_H	include/proto/checks.h	23;"	d
_PROTO_CLIENT_H	include/proto/client.h	23;"	d
_PROTO_CTTPROXY_H	include/proto/cttproxy.h	24;"	d
_PROTO_DUMPSTATS_H	include/proto/dumpstats.h	24;"	d
_PROTO_FD_H	include/proto/fd.h	23;"	d
_PROTO_FREQ_CTR_H	include/proto/freq_ctr.h	23;"	d
_PROTO_HDR_IDX_H	include/proto/hdr_idx.h	23;"	d
_PROTO_HTTPERR_H	include/proto/httperr.h	23;"	d
_PROTO_LB_CHASH_H	include/proto/lb_chash.h	23;"	d
_PROTO_LB_FWLC_H	include/proto/lb_fwlc.h	23;"	d
_PROTO_LB_FWRR_H	include/proto/lb_fwrr.h	23;"	d
_PROTO_LB_MAP_H	include/proto/lb_map.h	23;"	d
_PROTO_LOG_H	include/proto/log.h	24;"	d
_PROTO_PATTERN_H	include/proto/pattern.h	23;"	d
_PROTO_PIPE_H	include/proto/pipe.h	23;"	d
_PROTO_PORT_RANGE_H	include/proto/port_range.h	23;"	d
_PROTO_PROTOCOLS_H	include/proto/protocols.h	23;"	d
_PROTO_PROTO_HTTP_H	include/proto/proto_http.h	23;"	d
_PROTO_PROTO_TCP_H	include/proto/proto_tcp.h	23;"	d
_PROTO_PROTO_UXST_H	include/proto/proto_uxst.h	23;"	d
_PROTO_PROXY_H	include/proto/proxy.h	23;"	d
_PROTO_QUEUE_H	include/proto/queue.h	23;"	d
_PROTO_SERVER_H	include/proto/server.h	23;"	d
_PROTO_SESSION_H	include/proto/session.h	23;"	d
_PROTO_STICK_TABLE_H	include/proto/stick_table.h	23;"	d
_PROTO_STREAM_INTERFACE_H	include/proto/stream_interface.h	23;"	d
_PROTO_STREAM_SOCK_H	include/proto/stream_sock.h	23;"	d
_PROTO_TASK_H	include/proto/task.h	23;"	d
_PROTO_TEMPLATE_H	include/proto/template.h	23;"	d
_TYPES_ACL_H	include/types/acl.h	23;"	d
_TYPES_AUTH_H	include/types/auth.h	14;"	d
_TYPES_BACKEND_H	include/types/backend.h	23;"	d
_TYPES_BUFFERS_H	include/types/buffers.h	23;"	d
_TYPES_CAPTURE_H	include/types/capture.h	23;"	d
_TYPES_COUNTERS_H	include/types/counters.h	23;"	d
_TYPES_FD_H	include/types/fd.h	23;"	d
_TYPES_FREQ_CTR_H	include/types/freq_ctr.h	23;"	d
_TYPES_GLOBAL_H	include/types/global.h	23;"	d
_TYPES_HDR_IDX_H	include/types/hdr_idx.h	42;"	d
_TYPES_HTTPERR_H	include/types/httperr.h	23;"	d
_TYPES_LB_CHASH_H	include/types/lb_chash.h	23;"	d
_TYPES_LB_FWLC_H	include/types/lb_fwlc.h	23;"	d
_TYPES_LB_FWRR_H	include/types/lb_fwrr.h	23;"	d
_TYPES_LB_MAP_H	include/types/lb_map.h	23;"	d
_TYPES_LOG_H	include/types/log.h	23;"	d
_TYPES_PATTERN_H	include/types/pattern.h	23;"	d
_TYPES_PIPE_H	include/types/pipe.h	23;"	d
_TYPES_PORT_RANGE_H	include/types/port_range.h	23;"	d
_TYPES_PROTOCOLS_H	include/types/protocols.h	23;"	d
_TYPES_PROTO_HTTP_H	include/types/proto_http.h	23;"	d
_TYPES_PROTO_TCP_H	include/types/proto_tcp.h	23;"	d
_TYPES_PROXY_H	include/types/proxy.h	23;"	d
_TYPES_QUEUE_H	include/types/queue.h	23;"	d
_TYPES_SERVER_H	include/types/server.h	23;"	d
_TYPES_SESSION_H	include/types/session.h	23;"	d
_TYPES_STICK_TABLE_H	include/types/stick_table.h	23;"	d
_TYPES_STREAM_INTERFACE_H	include/types/stream_interface.h	23;"	d
_TYPES_TASK_H	include/types/task.h	23;"	d
_TYPES_TEMPLATE_H	include/types/template.h	23;"	d
__NR_epoll_create	include/common/epoll.h	67;"	d
__NR_epoll_create	include/common/epoll.h	71;"	d
__NR_epoll_create	include/common/epoll.h	75;"	d
__NR_epoll_create	include/common/epoll.h	79;"	d
__NR_epoll_create	include/common/epoll.h	83;"	d
__NR_epoll_create	include/common/epoll.h	88;"	d
__NR_epoll_ctl	include/common/epoll.h	68;"	d
__NR_epoll_ctl	include/common/epoll.h	72;"	d
__NR_epoll_ctl	include/common/epoll.h	76;"	d
__NR_epoll_ctl	include/common/epoll.h	80;"	d
__NR_epoll_ctl	include/common/epoll.h	84;"	d
__NR_epoll_ctl	include/common/epoll.h	89;"	d
__NR_epoll_wait	include/common/epoll.h	69;"	d
__NR_epoll_wait	include/common/epoll.h	73;"	d
__NR_epoll_wait	include/common/epoll.h	77;"	d
__NR_epoll_wait	include/common/epoll.h	81;"	d
__NR_epoll_wait	include/common/epoll.h	85;"	d
__NR_epoll_wait	include/common/epoll.h	90;"	d
__NR_splice	src/stream_sock.c	65;"	d	file:
__NR_splice	src/stream_sock.c	67;"	d	file:
__NR_splice	src/stream_sock.c	69;"	d	file:
__NR_splice	src/stream_sock.c	71;"	d	file:
__NR_splice	src/stream_sock.c	73;"	d	file:
__NR_splice	src/stream_sock.c	76;"	d	file:
__acl_init	src/acl.c	/^static void __acl_init(void)$/;"	f	file:	signature:(void)
__anon66::expr	src/acl.c	/^	const char *expr[4]; \/* put enough for longest expression *\/$/;"	m	struct:__anon66	file:	access:public
__anon66::name	src/acl.c	/^	const char *name;$/;"	m	struct:__anon66	file:	access:public
__backend_init	src/backend.c	/^static void __backend_init(void)$/;"	f	file:	signature:(void)
__builtin_expect	include/common/compiler.h	89;"	d
__client_init	src/client.c	/^static void __client_init(void)$/;"	f	file:	signature:(void)
__dumpstats_module_init	src/dumpstats.c	/^static void __dumpstats_module_init(void)$/;"	f	file:	signature:(void)
__eb32_delete	ebtree/eb32tree.h	/^static forceinline void __eb32_delete(struct eb32_node *eb32)$/;"	f	signature:(struct eb32_node *eb32)
__eb32_insert	ebtree/eb32tree.h	/^__eb32_insert(struct eb_root *root, struct eb32_node *new) {$/;"	f	signature:(struct eb_root *root, struct eb32_node *new)
__eb32_lookup	ebtree/eb32tree.h	/^static forceinline struct eb32_node *__eb32_lookup(struct eb_root *root, u32 x)$/;"	f	signature:(struct eb_root *root, u32 x)
__eb32i_insert	ebtree/eb32tree.h	/^__eb32i_insert(struct eb_root *root, struct eb32_node *new) {$/;"	f	signature:(struct eb_root *root, struct eb32_node *new)
__eb32i_lookup	ebtree/eb32tree.h	/^static forceinline struct eb32_node *__eb32i_lookup(struct eb_root *root, s32 x)$/;"	f	signature:(struct eb_root *root, s32 x)
__eb64_delete	ebtree/eb64tree.h	/^static forceinline void __eb64_delete(struct eb64_node *eb64)$/;"	f	signature:(struct eb64_node *eb64)
__eb64_insert	ebtree/eb64tree.h	/^__eb64_insert(struct eb_root *root, struct eb64_node *new) {$/;"	f	signature:(struct eb_root *root, struct eb64_node *new)
__eb64_lookup	ebtree/eb64tree.h	/^static forceinline struct eb64_node *__eb64_lookup(struct eb_root *root, u64 x)$/;"	f	signature:(struct eb_root *root, u64 x)
__eb64i_insert	ebtree/eb64tree.h	/^__eb64i_insert(struct eb_root *root, struct eb64_node *new) {$/;"	f	signature:(struct eb_root *root, struct eb64_node *new)
__eb64i_lookup	ebtree/eb64tree.h	/^static forceinline struct eb64_node *__eb64i_lookup(struct eb_root *root, s64 x)$/;"	f	signature:(struct eb_root *root, s64 x)
__eb_delete	ebtree/ebtree.h	/^static forceinline void __eb_delete(struct eb_node *node)$/;"	f	signature:(struct eb_node *node)
__eb_insert_dup	ebtree/ebtree.h	/^__eb_insert_dup(struct eb_node *sub, struct eb_node *new)$/;"	f	signature:(struct eb_node *sub, struct eb_node *new)
__ebim_insert	ebtree/ebimtree.h	/^__ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)$/;"	f	signature:(struct eb_root *root, struct ebpt_node *new, unsigned int len)
__ebim_lookup	ebtree/ebimtree.h	/^__ebim_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f	signature:(struct eb_root *root, const void *x, unsigned int len)
__ebis_insert	ebtree/ebistree.h	/^__ebis_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f	signature:(struct eb_root *root, struct ebpt_node *new)
__ebis_lookup	ebtree/ebistree.h	/^static forceinline struct ebpt_node *__ebis_lookup(struct eb_root *root, const void *x)$/;"	f	signature:(struct eb_root *root, const void *x)
__ebmb_delete	ebtree/ebmbtree.h	/^static forceinline void __ebmb_delete(struct ebmb_node *ebmb)$/;"	f	signature:(struct ebmb_node *ebmb)
__ebmb_insert	ebtree/ebmbtree.h	/^__ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f	signature:(struct eb_root *root, struct ebmb_node *new, unsigned int len)
__ebmb_insert_prefix	ebtree/ebmbtree.h	/^__ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f	signature:(struct eb_root *root, struct ebmb_node *new, unsigned int len)
__ebmb_lookup	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f	signature:(struct eb_root *root, const void *x, unsigned int len)
__ebmb_lookup_longest	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup_longest(struct eb_root *root, const void *x)$/;"	f	signature:(struct eb_root *root, const void *x)
__ebmb_lookup_prefix	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)$/;"	f	signature:(struct eb_root *root, const void *x, unsigned int pfx)
__ebpt_delete	ebtree/ebpttree.h	/^static forceinline void __ebpt_delete(struct ebpt_node *ebpt)$/;"	f	signature:(struct ebpt_node *ebpt)
__ebpt_insert	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *__ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f	signature:(struct eb_root *root, struct ebpt_node *new)
__ebpt_lookup	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *__ebpt_lookup(struct eb_root *root, void *x)$/;"	f	signature:(struct eb_root *root, void *x)
__ebst_insert	ebtree/ebsttree.h	/^__ebst_insert(struct eb_root *root, struct ebmb_node *new)$/;"	f	signature:(struct eb_root *root, struct ebmb_node *new)
__ebst_lookup	ebtree/ebsttree.h	/^static forceinline struct ebmb_node *__ebst_lookup(struct eb_root *root, const void *x)$/;"	f	signature:(struct eb_root *root, const void *x)
__fd_clo	src/ev_epoll.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:	signature:(int fd)
__fd_clo	src/ev_kqueue.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:	signature:(int fd)
__fd_clo	src/ev_sepoll.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:	signature:(int fd)
__fd_clr	src/ev_epoll.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_clr	src/ev_kqueue.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_clr	src/ev_poll.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_clr	src/ev_select.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_clr	src/ev_sepoll.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_cond_c	src/ev_poll.c	/^REGPRM2 static int __fd_cond_c(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_cond_c	src/ev_select.c	/^REGPRM2 static int __fd_cond_c(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_cond_s	src/ev_poll.c	/^REGPRM2 static int __fd_cond_s(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_cond_s	src/ev_select.c	/^REGPRM2 static int __fd_cond_s(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_is_set	src/ev_epoll.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_is_set	src/ev_kqueue.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_is_set	src/ev_poll.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_is_set	src/ev_select.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_is_set	src/ev_sepoll.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_rem	src/ev_epoll.c	/^REGPRM1 static void __fd_rem(int fd)$/;"	f	file:	signature:(int fd)
__fd_rem	src/ev_kqueue.c	/^REGPRM1 static void __fd_rem(int fd)$/;"	f	file:	signature:(int fd)
__fd_rem	src/ev_poll.c	/^REGPRM1 static void __fd_rem(const int fd)$/;"	f	file:	signature:(const int fd)
__fd_rem	src/ev_select.c	/^REGPRM1 static void __fd_rem(int fd)$/;"	f	file:	signature:(int fd)
__fd_rem	src/ev_sepoll.c	/^REGPRM1 static void __fd_rem(int fd)$/;"	f	file:	signature:(int fd)
__fd_set	src/ev_epoll.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_set	src/ev_kqueue.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_set	src/ev_poll.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_set	src/ev_select.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__fd_set	src/ev_sepoll.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:	signature:(const int fd, int dir)
__http_protocol_init	src/proto_http.c	/^static void __http_protocol_init(void)$/;"	f	file:	signature:(void)
__pattern_init	src/pattern.c	/^static void __pattern_init(void)$/;"	f	file:	signature:(void)
__pipe_module_init	src/pipe.c	/^static void __pipe_module_init(void)$/;"	f	file:	signature:(void)
__proxy_module_init	src/proxy.c	/^static void __proxy_module_init(void)$/;"	f	file:	signature:(void)
__rb_erase_color	src/rbtree.c	/^static void __rb_erase_color(struct rb_node *node, struct rb_node *parent,$/;"	f	file:	signature:(struct rb_node *node, struct rb_node *parent, struct rb_root *root)
__rb_rotate_left	src/rbtree.c	/^static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)$/;"	f	file:	signature:(struct rb_node *node, struct rb_root *root)
__rb_rotate_right	src/rbtree.c	/^static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)$/;"	f	file:	signature:(struct rb_node *node, struct rb_root *root)
__signal_process_queue	include/proto/signal.h	/^void __signal_process_queue();$/;"	p	signature:()
__signal_process_queue	src/signal.c	/^void __signal_process_queue()$/;"	f
__str2ui	include/common/standard.h	/^static inline unsigned int __str2ui(const char *s)$/;"	f	signature:(const char *s)
__str2uic	include/common/standard.h	/^static inline unsigned int __str2uic(const char *s)$/;"	f	signature:(const char *s)
__strl2ui	contrib/halog/halog.c	/^static inline unsigned int __strl2ui(const char *s, int len)$/;"	f	file:	signature:(const char *s, int len)
__strl2ui	include/common/standard.h	/^static inline unsigned int __strl2ui(const char *s, int len)$/;"	f	signature:(const char *s, int len)
__strl2uic	include/common/standard.h	/^static inline unsigned int __strl2uic(const char *s, int len)$/;"	f	signature:(const char *s, int len)
__task_queue	include/proto/task.h	/^void __task_queue(struct task *task);$/;"	p	signature:(struct task *task)
__task_queue	src/task.c	/^void __task_queue(struct task *task)$/;"	f	signature:(struct task *task)
__task_unlink_rq	include/proto/task.h	/^static inline struct task *__task_unlink_rq(struct task *t)$/;"	f	signature:(struct task *t)
__task_unlink_wq	include/proto/task.h	/^static inline struct task *__task_unlink_wq(struct task *t)$/;"	f	signature:(struct task *t)
__task_wakeup	include/proto/task.h	/^struct task *__task_wakeup(struct task *t);$/;"	p	signature:(struct task *t)
__task_wakeup	src/task.c	/^struct task *__task_wakeup(struct task *t)$/;"	f	signature:(struct task *t)
__tcp_protocol_init	src/proto_tcp.c	/^static void __tcp_protocol_init(void)$/;"	f	file:	signature:(void)
__tv_add	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f	signature:(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
__tv_add2	include/common/time.h	/^REGPRM2 static inline struct timeval *__tv_add2(struct timeval *tv, const struct timeval *inc)$/;"	f	signature:(struct timeval *tv, const struct timeval *inc)
__tv_add_ifset	include/common/time.h	/^REGPRM3 static inline int __tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f	signature:(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
__tv_cmp	include/common/time.h	/^REGPRM2 static inline int __tv_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_from_ms	include/common/time.h	/^REGPRM2 static inline struct timeval * __tv_from_ms(struct timeval *tv, unsigned long ms)$/;"	f	signature:(struct timeval *tv, unsigned long ms)
__tv_iseq	include/common/time.h	/^REGPRM2 static inline int __tv_iseq(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_isge	include/common/time.h	/^REGPRM2 static inline int __tv_isge(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_isgt	include/common/time.h	/^REGPRM2 static inline int __tv_isgt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_isle	include/common/time.h	/^REGPRM2 static inline int __tv_isle(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_islt	include/common/time.h	/^REGPRM2 static inline int __tv_islt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_ms_add	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)$/;"	f	signature:(struct timeval *tv, const struct timeval *from, int ms)
__tv_ms_cmp	include/common/time.h	/^REGPRM2 static inline int __tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_ms_cmp2	include/common/time.h	/^REGPRM2 static inline int __tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_ms_elapsed	include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_ms_le2	include/common/time.h	/^REGPRM2 static inline int __tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_ms_remain	include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_ms_remain2	include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
__tv_remain	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
__tv_remain2	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
__tv_to_ms	include/common/time.h	/^REGPRM1 static inline unsigned long __tv_to_ms(const struct timeval *tv)$/;"	f	signature:(const struct timeval *tv)
__usec_to_1024th	include/common/time.h	/^REGPRM1 static inline unsigned int __usec_to_1024th(unsigned int usec)$/;"	f	signature:(unsigned int usec)
__uxst_protocol_init	src/proto_uxst.c	/^static void __uxst_protocol_init(void)$/;"	f	file:	signature:(void)
_do_fork	src/ev_epoll.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_fork	src/ev_kqueue.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_fork	src/ev_sepoll.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_init	src/ev_epoll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_init	src/ev_kqueue.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_init	src/ev_poll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_init	src/ev_select.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_init	src/ev_sepoll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_poll	src/ev_epoll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:	signature:(struct poller *p, int exp)
_do_poll	src/ev_kqueue.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:	signature:(struct poller *p, int exp)
_do_poll	src/ev_poll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:	signature:(struct poller *p, int exp)
_do_poll	src/ev_select.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:	signature:(struct poller *p, int exp)
_do_poll	src/ev_sepoll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:	signature:(struct poller *p, int exp)
_do_register	src/ev_epoll.c	/^static void _do_register(void)$/;"	f	file:	signature:(void)
_do_register	src/ev_kqueue.c	/^static void _do_register(void)$/;"	f	file:	signature:(void)
_do_register	src/ev_poll.c	/^static void _do_register(void)$/;"	f	file:	signature:(void)
_do_register	src/ev_select.c	/^static void _do_register(void)$/;"	f	file:	signature:(void)
_do_register	src/ev_sepoll.c	/^static void _do_register(void)$/;"	f	file:	signature:(void)
_do_term	src/ev_epoll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_term	src/ev_kqueue.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_term	src/ev_poll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_term	src/ev_select.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_term	src/ev_sepoll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_test	src/ev_epoll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_test	src/ev_kqueue.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_test	src/ev_poll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_test	src/ev_select.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_do_test	src/ev_sepoll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:	signature:(struct poller *p)
_in_args	include/import/ip_tproxy.h	/^	union _in_args {$/;"	u	struct:in_tproxy	access:public
_syscall1	src/ev_epoll.c	/^static _syscall1 (int, epoll_create, int, size);$/;"	p	file:	signature:(int, epoll_create, int, size)
_syscall1	src/ev_sepoll.c	/^static _syscall1 (int, epoll_create, int, size);$/;"	p	file:	signature:(int, epoll_create, int, size)
_syscall4	src/ev_epoll.c	/^static _syscall4 (int, epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event *, event);$/;"	p	file:	signature:(int, epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event *, event)
_syscall4	src/ev_epoll.c	/^static _syscall4 (int, epoll_wait, int, epfd, struct epoll_event *, events, int, maxevents, int, timeout);$/;"	p	file:	signature:(int, epoll_wait, int, epfd, struct epoll_event *, events, int, maxevents, int, timeout)
_syscall4	src/ev_sepoll.c	/^static _syscall4 (int, epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event *, event);$/;"	p	file:	signature:(int, epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event *, event)
_syscall4	src/ev_sepoll.c	/^static _syscall4 (int, epoll_wait, int, epfd, struct epoll_event *, events, int, maxevents, int, timeout);$/;"	p	file:	signature:(int, epoll_wait, int, epfd, struct epoll_event *, events, int, maxevents, int, timeout)
_tv_add	include/common/time.h	/^REGPRM3 struct timeval *_tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc);$/;"	p	signature:(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
_tv_add	src/time.c	/^REGPRM3 struct timeval *_tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f	signature:(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
_tv_add_ifset	include/common/time.h	/^REGPRM3 int _tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc);$/;"	p	signature:(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
_tv_add_ifset	src/time.c	/^REGPRM3 int _tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f	signature:(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
_tv_isgt	include/common/time.h	/^REGPRM2 int _tv_isgt(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_isgt	src/time.c	/^REGPRM2 int _tv_isgt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_isle	include/common/time.h	/^REGPRM2 int _tv_isle(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_isle	src/time.c	/^REGPRM2 int _tv_isle(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_add	include/common/time.h	/^REGPRM3 struct timeval *_tv_ms_add(struct timeval *tv, const struct timeval *from, int ms);$/;"	p	signature:(struct timeval *tv, const struct timeval *from, int ms)
_tv_ms_add	src/time.c	/^REGPRM3 struct timeval *_tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)$/;"	f	signature:(struct timeval *tv, const struct timeval *from, int ms)
_tv_ms_cmp	include/common/time.h	/^REGPRM2 int _tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_cmp	src/time.c	/^REGPRM2 int _tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_cmp2	include/common/time.h	/^REGPRM2 int _tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_cmp2	src/time.c	/^REGPRM2 int _tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_elapsed	include/common/time.h	/^REGPRM2 unsigned long _tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_elapsed	src/time.c	/^REGPRM2 unsigned long _tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_le2	include/common/time.h	/^REGPRM2 int _tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_le2	src/time.c	/^REGPRM2 int _tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_remain	include/common/time.h	/^REGPRM2 unsigned long _tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_remain	src/time.c	/^REGPRM2 unsigned long _tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_remain2	include/common/time.h	/^REGPRM2 unsigned long _tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_ms_remain2	src/time.c	/^REGPRM2 unsigned long _tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2)
_tv_remain	include/common/time.h	/^REGPRM3 struct timeval *_tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
_tv_remain	src/time.c	/^REGPRM3 struct timeval *_tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
_tv_remain2	include/common/time.h	/^REGPRM3 struct timeval *_tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
_tv_remain2	src/time.c	/^REGPRM3 struct timeval *_tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
a	include/types/acl.h	/^		void *a[8];     \/* any array of up to 8 pointers *\/$/;"	m	union:acl_test::__anon53	access:public
a	tests/sessionhash_test.c	/^	appsess *a, *b, *c, *d, *tmp;$/;"	l
a	tests/test_hashes.c	/^  uint32_t a,b,c;$/;"	l
a2base64	include/common/base64.h	/^int a2base64(char *in, int ilen, char *out, int olen);$/;"	p	signature:(char *in, int ilen, char *out, int olen)
a2base64	src/base64.c	/^int a2base64(char *in, int ilen, char *out, int olen)$/;"	f	signature:(char *in, int ilen, char *out, int olen)
absmaxevents	src/ev_sepoll.c	/^static int absmaxevents = 0;    \/\/ absolute maximum amounts of polled events$/;"	v	file:
accept	include/types/protocols.h	/^	int (*accept)(int fd);		\/* accept() function passed to fdtab[] *\/$/;"	m	struct:listener	access:public
accept_date	include/types/session.h	/^		struct timeval accept_date;	\/* date of the accept() in user date *\/$/;"	m	struct:session::__anon8	typeref:struct:session::__anon8::timeval	access:public
accept_delay	src/proto_tcp.c	/^		int accept_delay = 1;$/;"	l
acl	include/types/acl.h	/^	struct acl *acl;            \/* acl pointed to by this term *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::acl	access:public
acl	include/types/acl.h	/^struct acl {$/;"	s
acl	include/types/proxy.h	/^	struct list acl;                        \/* ACL declared on this proxy *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
acl	src/acl.c	/^	struct acl *acl;$/;"	l
acl	src/cfgparse.c	/^	struct acl *acl;$/;"	l
acl	src/haproxy.c	/^	struct acl *acl, *aclb;$/;"	l
acl	src/proto_tcp.c	/^			struct acl *acl;$/;"	l
acl::cache_idx	include/types/acl.h	/^	int cache_idx;              \/* ACL index in cache *\/$/;"	m	struct:acl	access:public
acl::expr	include/types/acl.h	/^	struct list expr;	    \/* list of acl_exprs *\/$/;"	m	struct:acl	typeref:struct:acl::list	access:public
acl::list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl	typeref:struct:acl::list	access:public
acl::name	include/types/acl.h	/^	char *name;		    \/* acl name *\/$/;"	m	struct:acl	access:public
acl::requires	include/types/acl.h	/^	unsigned int requires;      \/* or'ed bit mask of all acl_expr's ACL_USE_* *\/$/;"	m	struct:acl	access:public
acl_cond	include/types/acl.h	/^struct acl_cond {$/;"	s
acl_cond::file	include/types/acl.h	/^	const char *file;           \/* config file where the condition is declared *\/$/;"	m	struct:acl_cond	access:public
acl_cond::line	include/types/acl.h	/^	int line;                   \/* line in the config file where the condition is declared *\/$/;"	m	struct:acl_cond	access:public
acl_cond::list	include/types/acl.h	/^	struct list list;           \/* Some specific tests may use multiple conditions *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list	access:public
acl_cond::pol	include/types/acl.h	/^	int pol;                    \/* polarity: ACL_COND_IF \/ ACL_COND_UNLESS *\/$/;"	m	struct:acl_cond	access:public
acl_cond::requires	include/types/acl.h	/^	unsigned int requires;      \/* or'ed bit mask of all acl's ACL_USE_* *\/$/;"	m	struct:acl_cond	access:public
acl_cond::suites	include/types/acl.h	/^	struct list suites;         \/* list of acl_term_suites *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list	access:public
acl_exec_cond	include/proto/acl.h	/^int acl_exec_cond(struct acl_cond *cond, struct proxy *px, struct session *l4, void *l7, int dir);$/;"	p	signature:(struct acl_cond *cond, struct proxy *px, struct session *l4, void *l7, int dir)
acl_exec_cond	src/acl.c	/^int acl_exec_cond(struct acl_cond *cond, struct proxy *px, struct session *l4, void *l7, int dir)$/;"	f	signature:(struct acl_cond *cond, struct proxy *px, struct session *l4, void *l7, int dir)
acl_expr	include/types/acl.h	/^struct acl_expr {$/;"	s
acl_expr	include/types/acl.h	/^struct acl_expr;$/;"	x
acl_expr	src/acl.c	/^	struct acl_expr *acl_expr;$/;"	l
acl_expr::__anon54::srv	include/types/acl.h	/^		struct server *srv;$/;"	m	union:acl_expr::__anon54	typeref:struct:acl_expr::__anon54::server	access:public
acl_expr::__anon54::str	include/types/acl.h	/^		char *str;$/;"	m	union:acl_expr::__anon54	access:public
acl_expr::__anon54::ul	include/types/acl.h	/^		struct userlist *ul;$/;"	m	union:acl_expr::__anon54	typeref:struct:acl_expr::__anon54::userlist	access:public
acl_expr::arg	include/types/acl.h	/^	} arg;$/;"	m	struct:acl_expr	typeref:union:acl_expr::__anon54	access:public
acl_expr::arg_len	include/types/acl.h	/^	int arg_len;                \/* optional argument length *\/$/;"	m	struct:acl_expr	access:public
acl_expr::kw	include/types/acl.h	/^	struct acl_keyword *kw;     \/* back-reference to the keyword *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::acl_keyword	access:public
acl_expr::list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::list	access:public
acl_expr::pattern_tree	include/types/acl.h	/^	struct eb_root pattern_tree;  \/* may be used for lookup in large datasets *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::eb_root	access:public
acl_expr::patterns	include/types/acl.h	/^	struct list patterns;       \/* list of acl_patterns *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::list	access:public
acl_fetch_avg_queue_size	src/backend.c	/^acl_fetch_avg_queue_size(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_be_conn	src/backend.c	/^acl_fetch_be_conn(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_be_sess_rate	src/backend.c	/^acl_fetch_be_sess_rate(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_chdr	src/proto_http.c	/^acl_fetch_chdr(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_chdr_cnt	src/proto_http.c	/^acl_fetch_chdr_cnt(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_chdr_ip	src/proto_http.c	/^acl_fetch_chdr_ip(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_chdr_val	src/proto_http.c	/^acl_fetch_chdr_val(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_connslots	src/backend.c	/^acl_fetch_connslots(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_dconn	src/client.c	/^acl_fetch_dconn(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_dport	src/client.c	/^acl_fetch_dport(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_dst	src/client.c	/^acl_fetch_dst(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_false	src/acl.c	/^acl_fetch_false(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_fe_conn	src/backend.c	/^acl_fetch_fe_conn(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_fe_id	src/client.c	/^acl_fetch_fe_id(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_fe_sess_rate	src/backend.c	/^acl_fetch_fe_sess_rate(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_hdr	src/proto_http.c	/^acl_fetch_hdr(struct proxy *px, struct session *l4, void *l7, char *sol,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, char *sol, struct acl_expr *expr, struct acl_test *test)
acl_fetch_hdr_cnt	src/proto_http.c	/^acl_fetch_hdr_cnt(struct proxy *px, struct session *l4, void *l7, char *sol,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, char *sol, struct acl_expr *expr, struct acl_test *test)
acl_fetch_hdr_ip	src/proto_http.c	/^acl_fetch_hdr_ip(struct proxy *px, struct session *l4, void *l7, char *sol,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, char *sol, struct acl_expr *expr, struct acl_test *test)
acl_fetch_hdr_val	src/proto_http.c	/^acl_fetch_hdr_val(struct proxy *px, struct session *l4, void *l7, char *sol,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, char *sol, struct acl_expr *expr, struct acl_test *test)
acl_fetch_http_auth	src/proto_http.c	/^acl_fetch_http_auth(struct proxy *px, struct session *s, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *s, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_http_first_req	src/proto_http.c	/^acl_fetch_http_first_req(struct proxy *px, struct session *s, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *s, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_meth	src/proto_http.c	/^acl_fetch_meth(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_nbsrv	src/backend.c	/^acl_fetch_nbsrv(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_nothing	include/proto/acl.h	/^int acl_fetch_nothing(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	p	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_nothing	src/acl.c	/^int acl_fetch_nothing(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_path	src/proto_http.c	/^acl_fetch_path(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_proto_http	src/proto_http.c	/^acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *s, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_queue_size	src/backend.c	/^acl_fetch_queue_size(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_rdp_cookie	include/proto/proto_tcp.h	/^int acl_fetch_rdp_cookie(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	p	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_rdp_cookie	src/proto_tcp.c	/^acl_fetch_rdp_cookie(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_rdp_cookie_cnt	src/proto_tcp.c	/^acl_fetch_rdp_cookie_cnt(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_req_len	src/proto_tcp.c	/^acl_fetch_req_len(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_req_ssl_ver	src/proto_tcp.c	/^acl_fetch_req_ssl_ver(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_rqver	src/proto_http.c	/^acl_fetch_rqver(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_shdr	src/proto_http.c	/^acl_fetch_shdr(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_shdr_cnt	src/proto_http.c	/^acl_fetch_shdr_cnt(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_shdr_ip	src/proto_http.c	/^acl_fetch_shdr_ip(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_shdr_val	src/proto_http.c	/^acl_fetch_shdr_val(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_so_id	src/client.c	/^acl_fetch_so_id(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_sport	src/client.c	/^acl_fetch_sport(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_src	src/client.c	/^acl_fetch_src(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_srv_is_up	src/backend.c	/^acl_fetch_srv_is_up(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_stcode	src/proto_http.c	/^acl_fetch_stcode(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_stver	src/proto_http.c	/^acl_fetch_stver(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_true	src/acl.c	/^acl_fetch_true(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_url	src/proto_http.c	/^acl_fetch_url(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_url_ip	src/proto_http.c	/^acl_fetch_url_ip(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_url_port	src/proto_http.c	/^acl_fetch_url_port(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_fetch_wait_end	src/acl.c	/^acl_fetch_wait_end(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct acl_expr *expr, struct acl_test *test)
acl_find_targets	include/proto/acl.h	/^int acl_find_targets(struct proxy *p);$/;"	p	signature:(struct proxy *p)
acl_find_targets	src/acl.c	/^acl_find_targets(struct proxy *p)$/;"	f	signature:(struct proxy *p)
acl_free_reg	src/acl.c	/^static void acl_free_reg(void *ptr) {$/;"	f	file:	signature:(void *ptr)
acl_keyword	include/types/acl.h	/^struct acl_keyword {$/;"	s
acl_keyword::fetch	include/types/acl.h	/^	int (*fetch)(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	m	struct:acl_keyword	access:public
acl_keyword::kw	include/types/acl.h	/^	const char *kw;$/;"	m	struct:acl_keyword	access:public
acl_keyword::match	include/types/acl.h	/^	int (*match)(struct acl_test *test, struct acl_pattern *pattern);$/;"	m	struct:acl_keyword	access:public
acl_keyword::parse	include/types/acl.h	/^	int (*parse)(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	m	struct:acl_keyword	access:public
acl_keyword::requires	include/types/acl.h	/^	unsigned int requires;   \/* bit mask of all ACL_USE_* required to evaluate this keyword *\/$/;"	m	struct:acl_keyword	access:public
acl_keyword::use_cnt	include/types/acl.h	/^	int use_cnt;$/;"	m	struct:acl_keyword	access:public
acl_keywords	src/acl.c	/^static struct acl_kw_list acl_keywords = {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kw_list	include/types/acl.h	/^struct acl_kw_list {$/;"	s
acl_kw_list::kw	include/types/acl.h	/^	struct acl_keyword kw[VAR_ARRAY];$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::acl_keyword	access:public
acl_kw_list::list	include/types/acl.h	/^	struct list list;$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::list	access:public
acl_kws	src/acl.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/backend.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/client.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/proto_http.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/proto_tcp.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
acl_lookup_ip	src/acl.c	/^void *acl_lookup_ip(struct acl_test *test, struct acl_expr *expr)$/;"	f	signature:(struct acl_test *test, struct acl_expr *expr)
acl_lookup_str	src/acl.c	/^void *acl_lookup_str(struct acl_test *test, struct acl_expr *expr)$/;"	f	signature:(struct acl_test *test, struct acl_expr *expr)
acl_match_auth	include/proto/auth.h	/^int acl_match_auth(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_auth	src/auth.c	/^acl_match_auth(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_beg	include/proto/acl.h	/^int acl_match_beg(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_beg	src/acl.c	/^int acl_match_beg(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_dir	include/proto/acl.h	/^int acl_match_dir(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_dir	src/acl.c	/^int acl_match_dir(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_dom	include/proto/acl.h	/^int acl_match_dom(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_dom	src/acl.c	/^int acl_match_dom(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_end	include/proto/acl.h	/^int acl_match_end(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_end	src/acl.c	/^int acl_match_end(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_int	include/proto/acl.h	/^int acl_match_int(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_int	src/acl.c	/^int acl_match_int(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_ip	include/proto/acl.h	/^int acl_match_ip(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_ip	src/acl.c	/^int acl_match_ip(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_meth	src/proto_http.c	/^static int acl_match_meth(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	file:	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_nothing	include/proto/acl.h	/^int acl_match_nothing(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_nothing	src/acl.c	/^int acl_match_nothing(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_reg	include/proto/acl.h	/^int acl_match_reg(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_reg	src/acl.c	/^int acl_match_reg(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_str	include/proto/acl.h	/^int acl_match_str(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_str	src/acl.c	/^int acl_match_str(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_sub	include/proto/acl.h	/^int acl_match_sub(struct acl_test *test, struct acl_pattern *pattern);$/;"	p	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_match_sub	src/acl.c	/^int acl_match_sub(struct acl_test *test, struct acl_pattern *pattern)$/;"	f	signature:(struct acl_test *test, struct acl_pattern *pattern)
acl_neg	include/proto/acl.h	/^static inline int acl_neg(int res)$/;"	f	signature:(int res)
acl_parse_dotted_ver	include/proto/acl.h	/^int acl_parse_dotted_ver(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	p	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_dotted_ver	src/acl.c	/^int acl_parse_dotted_ver(const char **text, struct acl_pattern *pattern, int *opaque)$/;"	f	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_int	include/proto/acl.h	/^int acl_parse_int(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	p	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_int	src/acl.c	/^int acl_parse_int(const char **text, struct acl_pattern *pattern, int *opaque)$/;"	f	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_ip	include/proto/acl.h	/^int acl_parse_ip(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	p	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_ip	src/acl.c	/^int acl_parse_ip(const char **text, struct acl_pattern *pattern, int *opaque)$/;"	f	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_meth	src/proto_http.c	/^static int acl_parse_meth(const char **text, struct acl_pattern *pattern, int *opaque)$/;"	f	file:	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_nothing	include/proto/acl.h	/^int acl_parse_nothing(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	p	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_nothing	src/acl.c	/^int acl_parse_nothing(const char **text, struct acl_pattern *pattern, int *opaque)$/;"	f	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_range	include/proto/acl.h	/^int acl_parse_range(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	p	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_reg	include/proto/acl.h	/^int acl_parse_reg(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	p	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_reg	src/acl.c	/^int acl_parse_reg(const char **text, struct acl_pattern *pattern, int *opaque)$/;"	f	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_str	include/proto/acl.h	/^int acl_parse_str(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	p	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_str	src/acl.c	/^int acl_parse_str(const char **text, struct acl_pattern *pattern, int *opaque)$/;"	f	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_strcat	include/proto/acl.h	/^int acl_parse_strcat(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	p	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_strcat	src/acl.c	/^acl_parse_strcat(const char **text, struct acl_pattern *pattern, int *opaque)$/;"	f	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_parse_ver	src/proto_http.c	/^static int acl_parse_ver(const char **text, struct acl_pattern *pattern, int *opaque)$/;"	f	file:	signature:(const char **text, struct acl_pattern *pattern, int *opaque)
acl_pass	include/proto/acl.h	/^static inline int acl_pass(int res)$/;"	f	signature:(int res)
acl_pattern	include/types/acl.h	/^struct acl_pattern {$/;"	s
acl_pattern::__anon49::__anon50::max	include/types/acl.h	/^			signed long long min, max;$/;"	m	struct:acl_pattern::__anon49::__anon50	access:public
acl_pattern::__anon49::__anon50::max_set	include/types/acl.h	/^			int max_set :1;$/;"	m	struct:acl_pattern::__anon49::__anon50	access:public
acl_pattern::__anon49::__anon50::min	include/types/acl.h	/^			signed long long min, max;$/;"	m	struct:acl_pattern::__anon49::__anon50	access:public
acl_pattern::__anon49::__anon50::min_set	include/types/acl.h	/^			int min_set :1;$/;"	m	struct:acl_pattern::__anon49::__anon50	access:public
acl_pattern::__anon49::__anon51::addr	include/types/acl.h	/^			struct in_addr addr;$/;"	m	struct:acl_pattern::__anon49::__anon51	typeref:struct:acl_pattern::__anon49::__anon51::in_addr	access:public
acl_pattern::__anon49::__anon51::mask	include/types/acl.h	/^			struct in_addr mask;$/;"	m	struct:acl_pattern::__anon49::__anon51	typeref:struct:acl_pattern::__anon49::__anon51::in_addr	access:public
acl_pattern::__anon49::group_mask	include/types/acl.h	/^		unsigned int group_mask;$/;"	m	union:acl_pattern::__anon49	access:public
acl_pattern::__anon49::i	include/types/acl.h	/^		int i;                          \/* integer value *\/$/;"	m	union:acl_pattern::__anon49	access:public
acl_pattern::__anon49::ipv4	include/types/acl.h	/^		} ipv4;                         \/* IPv4 address *\/$/;"	m	union:acl_pattern::__anon49	typeref:struct:acl_pattern::__anon49::__anon51	access:public
acl_pattern::__anon49::range	include/types/acl.h	/^		} range; \/* integer range *\/$/;"	m	union:acl_pattern::__anon49	typeref:struct:acl_pattern::__anon49::__anon50	access:public
acl_pattern::__anon49::time	include/types/acl.h	/^		struct acl_time time;           \/* valid hours and days *\/$/;"	m	union:acl_pattern::__anon49	typeref:struct:acl_pattern::__anon49::acl_time	access:public
acl_pattern::__anon49::tree	include/types/acl.h	/^		struct eb_root *tree;           \/* tree storing all values if any *\/$/;"	m	union:acl_pattern::__anon49	typeref:struct:acl_pattern::__anon49::eb_root	access:public
acl_pattern::__anon52::ptr	include/types/acl.h	/^		void *ptr;              \/* any data *\/$/;"	m	union:acl_pattern::__anon52	access:public
acl_pattern::__anon52::reg	include/types/acl.h	/^		regex_t *reg;           \/* a compiled regex *\/$/;"	m	union:acl_pattern::__anon52	access:public
acl_pattern::__anon52::str	include/types/acl.h	/^		char *str;              \/* any string  *\/$/;"	m	union:acl_pattern::__anon52	access:public
acl_pattern::flags	include/types/acl.h	/^	int flags;                      \/* expr or pattern flags. *\/$/;"	m	struct:acl_pattern	access:public
acl_pattern::freeptrbuf	include/types/acl.h	/^	void(*freeptrbuf)(void *ptr);	\/* a destructor able to free objects from the ptr *\/$/;"	m	struct:acl_pattern	access:public
acl_pattern::len	include/types/acl.h	/^	int len;                        \/* data length when required  *\/$/;"	m	struct:acl_pattern	access:public
acl_pattern::list	include/types/acl.h	/^	struct list list;                       \/* chaining *\/$/;"	m	struct:acl_pattern	typeref:struct:acl_pattern::list	access:public
acl_pattern::ptr	include/types/acl.h	/^	} ptr;                          \/* indirect values, allocated *\/$/;"	m	struct:acl_pattern	typeref:union:acl_pattern::__anon52	access:public
acl_pattern::val	include/types/acl.h	/^	} val;                                  \/* direct value *\/$/;"	m	struct:acl_pattern	typeref:union:acl_pattern::__anon49	access:public
acl_read_patterns_from_file	src/acl.c	/^static int acl_read_patterns_from_file(	struct acl_keyword *aclkw,$/;"	f	file:	signature:( struct acl_keyword *aclkw, struct acl_expr *expr, const char *filename, int patflags)
acl_register_keywords	include/proto/acl.h	/^void acl_register_keywords(struct acl_kw_list *kwl);$/;"	p	signature:(struct acl_kw_list *kwl)
acl_register_keywords	src/acl.c	/^void acl_register_keywords(struct acl_kw_list *kwl)$/;"	f	signature:(struct acl_kw_list *kwl)
acl_requires	include/types/proxy.h	/^	int acl_requires;                       \/* Elements required to satisfy all ACLs (ACL_USE_*) *\/$/;"	m	struct:proxy	access:public
acl_res	src/acl.c	/^	int acl_res, suite_res, cond_res;$/;"	l
acl_term	include/types/acl.h	/^struct acl_term {$/;"	s
acl_term::acl	include/types/acl.h	/^	struct acl *acl;            \/* acl pointed to by this term *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::acl	access:public
acl_term::list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::list	access:public
acl_term::neg	include/types/acl.h	/^	int neg;                    \/* 1 if the ACL result must be negated *\/$/;"	m	struct:acl_term	access:public
acl_term_suite	include/types/acl.h	/^struct acl_term_suite {$/;"	s
acl_term_suite::list	include/types/acl.h	/^	struct list list;           \/* chaining of term suites *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list	access:public
acl_term_suite::terms	include/types/acl.h	/^	struct list terms;          \/* list of acl_terms *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list	access:public
acl_test	include/types/acl.h	/^struct acl_test {$/;"	s
acl_test::__anon53::a	include/types/acl.h	/^		void *a[8];     \/* any array of up to 8 pointers *\/$/;"	m	union:acl_test::__anon53	access:public
acl_test::__anon53::d	include/types/acl.h	/^		double d;       \/* any float or double *\/$/;"	m	union:acl_test::__anon53	access:public
acl_test::__anon53::i	include/types/acl.h	/^		int i;          \/* any integer *\/$/;"	m	union:acl_test::__anon53	access:public
acl_test::__anon53::ll	include/types/acl.h	/^		long long ll;   \/* any long long or smaller *\/$/;"	m	union:acl_test::__anon53	access:public
acl_test::__anon53::p	include/types/acl.h	/^		void *p;        \/* any pointer *\/$/;"	m	union:acl_test::__anon53	access:public
acl_test::ctx	include/types/acl.h	/^	} ctx;$/;"	m	struct:acl_test	typeref:union:acl_test::__anon53	access:public
acl_test::flags	include/types/acl.h	/^	int flags;              \/* ACL_TEST_F_* set to 0 on first call *\/$/;"	m	struct:acl_test	access:public
acl_test::i	include/types/acl.h	/^	int i;                  \/* integer value *\/$/;"	m	struct:acl_test	access:public
acl_test::len	include/types/acl.h	/^	int len;                \/* length of value at ptr, otherwise ignored *\/$/;"	m	struct:acl_test	access:public
acl_test::ptr	include/types/acl.h	/^	char *ptr;              \/* pointer to beginning of value *\/$/;"	m	struct:acl_test	access:public
acl_time	include/types/acl.h	/^struct acl_time {$/;"	s
acl_time::dow	include/types/acl.h	/^	int dow:7;              \/* 1 bit per day of week: 0-6 *\/$/;"	m	struct:acl_time	access:public
acl_time::h1	include/types/acl.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:acl_time	access:public
acl_time::h2	include/types/acl.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:acl_time	access:public
acl_time::m1	include/types/acl.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:acl_time	access:public
acl_time::m2	include/types/acl.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:acl_time	access:public
acl_unregister_keywords	include/proto/acl.h	/^void acl_unregister_keywords(struct acl_kw_list *kwl);$/;"	p	signature:(struct acl_kw_list *kwl)
acl_unregister_keywords	src/acl.c	/^void acl_unregister_keywords(struct acl_kw_list *kwl)$/;"	f	signature:(struct acl_kw_list *kwl)
aclb	src/haproxy.c	/^	struct acl *acl, *aclb;$/;"	l
aclkw	src/acl.c	/^	struct acl_keyword *aclkw;$/;"	l
act	include/types/lb_chash.h	/^	struct eb_root act;	\/* weighted chash entries of active servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root	access:public
act	include/types/lb_fwlc.h	/^	struct eb_root act;	\/* weighted least conns on the active servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root	access:public
act	include/types/lb_fwrr.h	/^	struct fwrr_group act;	\/* weighted round robin on the active servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group	access:public
act	src/lb_map.c	/^	int act, bck;$/;"	l
actconn	include/types/fd.h	/^extern int actconn;                     \/* # of active sessions *\/$/;"	x
actconn	include/types/global.h	/^extern int  actconn;            \/* # of active sessions *\/$/;"	x
actconn	src/fd.c	/^int actconn;                    \/* # of active sessions *\/$/;"	v
action	include/common/regex.h	/^    int action;				\/* ACT_ALLOW, ACT_REPLACE, ACT_REMOVE, ACT_DENY *\/$/;"	m	struct:hdr_exp	access:public
action	include/types/auth.h	/^	unsigned int action;$/;"	m	struct:req_acl_rule	access:public
action	include/types/proto_tcp.h	/^	int action;$/;"	m	struct:tcp_rule	access:public
action	src/proto_http.c	/^	int action = 0;$/;"	l
action	src/proto_tcp.c	/^		int action;$/;"	l
addr	include/import/ip_tproxy.h	/^		struct in_tproxy_addr	addr;$/;"	m	union:in_tproxy::_in_args	typeref:struct:in_tproxy::_in_args::in_tproxy_addr	access:public
addr	include/types/acl.h	/^			struct in_addr addr;$/;"	m	struct:acl_pattern::__anon49::__anon51	typeref:struct:acl_pattern::__anon49::__anon51::in_addr	access:public
addr	include/types/log.h	/^		struct sockaddr addr;$/;"	m	union:logsrv::__anon1	typeref:struct:logsrv::__anon1::sockaddr	access:public
addr	include/types/protocols.h	/^	struct sockaddr_storage addr;	\/* the address we listen to *\/$/;"	m	struct:listener	typeref:struct:listener::sockaddr_storage	access:public
addr	include/types/server.h	/^	struct sockaddr_in addr;		\/* the address to connect to *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_in	access:public
addr	src/client.c	/^		struct sockaddr_storage addr;$/;"	l
addr	src/pattern.c	/^	const char *addr;$/;"	l
addr	src/proto_tcp.c	/^	struct sockaddr_in addr;$/;"	l
addr	src/proto_uxst.c	/^		struct sockaddr_storage addr;$/;"	l
addr	src/proto_uxst.c	/^	struct sockaddr_un addr;$/;"	l
addr	tests/reset.c	/^	char *addr;$/;"	l
address	tests/ip-hash.c	/^	unsigned int address = 0;$/;"	l
adjusted	src/time.c	/^	struct timeval adjusted, deadline;$/;"	l
admin_rules	include/common/uri_auth.h	/^	struct list admin_rules;	\/* 'stats admin' rules (chained) *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list	access:public
advance	src/buffers.c	/^	int advance, to_move;$/;"	l
age	src/freq_ctr.c	/^	unsigned int age;$/;"	l
age	src/freq_ctr.c	/^	unsigned int wait, age;$/;"	l
algo	include/types/backend.h	/^	int algo;			\/* load balancing algorithm and variants: BE_LB_* *\/$/;"	m	struct:lbprm	access:public
align	src/memory.c	/^	unsigned int align;$/;"	l
alloc_chg_list	src/ev_epoll.c	/^REGPRM2 static void alloc_chg_list(const int fd, int old_evt)$/;"	f	file:	signature:(const int fd, int old_evt)
alloc_spec_entry	src/ev_sepoll.c	/^REGPRM1 static inline void alloc_spec_entry(const int fd)$/;"	f	file:	signature:(const int fd)
alloc_stats_fe	src/dumpstats.c	/^static struct proxy *alloc_stats_fe(const char *name)$/;"	f	file:	signature:(const char *name)
allocated	include/common/memory.h	/^	unsigned int allocated;	\/* how many chunks have been allocated *\/$/;"	m	struct:pool_head	access:public
allocated	src/memory.c	/^	unsigned long allocated, used;$/;"	l
alltrim	include/common/standard.h	/^static inline char *alltrim(char *s, char c) {$/;"	f	signature:(char *s, char c)
ana_back	src/session.c	/^			unsigned int ana_back;$/;"	l
ana_list	src/session.c	/^			unsigned int ana_list;$/;"	l
analyse_exp	include/types/buffers.h	/^	int analyse_exp;                \/* expiration date for current analysers (if set) *\/$/;"	m	struct:buffer	access:public
analysers	include/types/buffers.h	/^	unsigned int analysers;         \/* bit field indicating what to do on the buffer *\/$/;"	m	struct:buffer	access:public
analysers	include/types/protocols.h	/^	unsigned int analysers;		\/* bitmap of required protocol analysers *\/$/;"	m	struct:listener	access:private
analyze_status	include/types/checks.h	/^struct analyze_status {$/;"	s
analyze_status::desc	include/types/checks.h	/^	char *desc;				\/* description *\/$/;"	m	struct:analyze_status	access:public
analyze_status::lr	include/types/checks.h	/^	unsigned char lr[HANA_OBS_SIZE];	\/* result for l4\/l7: 0 = ignore, 1 - error, 2 - OK *\/$/;"	m	struct:analyze_status	access:public
analyze_statuses	src/checks.c	/^const struct analyze_status analyze_statuses[HANA_STATUS_SIZE] = {		\/* 0: ignore, 1: error, 2: OK *\/$/;"	v	typeref:struct:analyze_status
apools	include/common/appsession.h	/^extern struct app_pool apools;$/;"	x
apools	src/appsession.c	/^struct app_pool apools;$/;"	v	typeref:struct:app_pool
app_pool	include/common/appsession.h	/^struct app_pool {$/;"	s
app_pool::serverid	include/common/appsession.h	/^	struct pool_head *serverid;$/;"	m	struct:app_pool	typeref:struct:app_pool::pool_head	access:public
app_pool::sessid	include/common/appsession.h	/^	struct pool_head *sessid;$/;"	m	struct:app_pool	typeref:struct:app_pool::pool_head	access:public
apply_filter_to_req_headers	include/proto/proto_http.h	/^int apply_filter_to_req_headers(struct session *t, struct buffer *req, struct hdr_exp *exp);$/;"	p	signature:(struct session *t, struct buffer *req, struct hdr_exp *exp)
apply_filter_to_req_headers	src/proto_http.c	/^int apply_filter_to_req_headers(struct session *t, struct buffer *req, struct hdr_exp *exp)$/;"	f	signature:(struct session *t, struct buffer *req, struct hdr_exp *exp)
apply_filter_to_req_line	include/proto/proto_http.h	/^int apply_filter_to_req_line(struct session *t, struct buffer *req, struct hdr_exp *exp);$/;"	p	signature:(struct session *t, struct buffer *req, struct hdr_exp *exp)
apply_filter_to_req_line	src/proto_http.c	/^int apply_filter_to_req_line(struct session *t, struct buffer *req, struct hdr_exp *exp)$/;"	f	signature:(struct session *t, struct buffer *req, struct hdr_exp *exp)
apply_filter_to_resp_headers	src/proto_http.c	/^int apply_filter_to_resp_headers(struct session *t, struct buffer *rtr, struct hdr_exp *exp)$/;"	f	signature:(struct session *t, struct buffer *rtr, struct hdr_exp *exp)
apply_filter_to_sts_line	src/proto_http.c	/^int apply_filter_to_sts_line(struct session *t, struct buffer *rtr, struct hdr_exp *exp)$/;"	f	signature:(struct session *t, struct buffer *rtr, struct hdr_exp *exp)
apply_filters_to_request	include/proto/proto_http.h	/^int apply_filters_to_request(struct session *s, struct buffer *req, struct proxy *px);$/;"	p	signature:(struct session *s, struct buffer *req, struct proxy *px)
apply_filters_to_request	src/proto_http.c	/^int apply_filters_to_request(struct session *s, struct buffer *req, struct proxy *px)$/;"	f	signature:(struct session *s, struct buffer *req, struct proxy *px)
apply_filters_to_response	include/proto/proto_http.h	/^int apply_filters_to_response(struct session *t, struct buffer *rtr, struct proxy *px);$/;"	p	signature:(struct session *t, struct buffer *rtr, struct proxy *px)
apply_filters_to_response	src/proto_http.c	/^int apply_filters_to_response(struct session *s, struct buffer *rtr, struct proxy *px)$/;"	f	signature:(struct session *s, struct buffer *rtr, struct proxy *px)
appsess	include/common/appsession.h	/^} appsess;$/;"	t	typeref:struct:appsessions
appsess_refresh	src/appsession.c	/^static struct task *appsess_refresh = NULL;$/;"	v	typeref:struct:task	file:
appsession	include/types/proxy.h	/^		int appsession;                 \/* appsession cookie expiration *\/$/;"	m	struct:proxy::__anon19	access:public
appsession_cleanup	include/common/appsession.h	/^void appsession_cleanup(void);$/;"	p	signature:(void)
appsession_cleanup	src/appsession.c	/^void appsession_cleanup( void )$/;"	f	signature:( void )
appsession_hash	include/common/sessionhash.h	/^struct appsession_hash$/;"	s
appsession_hash::destroy	include/common/sessionhash.h	/^	void (*destroy)(appsess *);$/;"	m	struct:appsession_hash	access:public
appsession_hash::table	include/common/sessionhash.h	/^	struct list *table;$/;"	m	struct:appsession_hash	typeref:struct:appsession_hash::list	access:public
appsession_hash_destroy	include/common/sessionhash.h	/^void appsession_hash_destroy(struct appsession_hash *hash);$/;"	p	signature:(struct appsession_hash *hash)
appsession_hash_destroy	src/sessionhash.c	/^void appsession_hash_destroy(struct appsession_hash *hash)$/;"	f	signature:(struct appsession_hash *hash)
appsession_hash_dump	include/common/sessionhash.h	/^void appsession_hash_dump(struct appsession_hash *hash);$/;"	p	signature:(struct appsession_hash *hash)
appsession_hash_dump	src/sessionhash.c	/^void appsession_hash_dump(struct appsession_hash *hash)$/;"	f	signature:(struct appsession_hash *hash)
appsession_hash_f	include/common/sessionhash.h	/^unsigned int appsession_hash_f(char *);$/;"	p	signature:(char *)
appsession_hash_f	src/sessionhash.c	/^unsigned int appsession_hash_f(char *ptr)$/;"	f	signature:(char *ptr)
appsession_hash_init	include/common/sessionhash.h	/^int appsession_hash_init(struct appsession_hash *hash,$/;"	p	signature:(struct appsession_hash *hash, void(*destroy)(appsess*))
appsession_hash_init	src/sessionhash.c	/^int appsession_hash_init(struct appsession_hash *hash,$/;"	f	signature:(struct appsession_hash *hash, void(*destroy)(appsess*))
appsession_hash_insert	include/common/sessionhash.h	/^void appsession_hash_insert(struct appsession_hash *hash,$/;"	p	signature:(struct appsession_hash *hash, struct appsessions *session)
appsession_hash_insert	src/sessionhash.c	/^void appsession_hash_insert(struct appsession_hash *hash, appsess *session)$/;"	f	signature:(struct appsession_hash *hash, appsess *session)
appsession_hash_lookup	include/common/sessionhash.h	/^struct appsessions *appsession_hash_lookup(struct appsession_hash *hash,$/;"	p	signature:(struct appsession_hash *hash, char *key)
appsession_hash_lookup	src/sessionhash.c	/^appsess *appsession_hash_lookup(struct appsession_hash *hash, char *sessid)$/;"	f	signature:(struct appsession_hash *hash, char *sessid)
appsession_hash_remove	include/common/sessionhash.h	/^void appsession_hash_remove(struct appsession_hash *hash,$/;"	p	signature:(struct appsession_hash *hash, struct appsessions *session)
appsession_hash_remove	src/sessionhash.c	/^void appsession_hash_remove(struct appsession_hash *hash, appsess *session)$/;"	f	signature:(struct appsession_hash *hash, appsess *session)
appsession_init	include/common/appsession.h	/^int appsession_init(void);$/;"	p	signature:(void)
appsession_init	src/appsession.c	/^int appsession_init(void)$/;"	f	signature:(void)
appsession_len	include/types/proxy.h	/^	int  appsession_len;			\/* length of the appsession cookie value to be used *\/$/;"	m	struct:proxy	access:public
appsession_name	include/types/proxy.h	/^	char *appsession_name;			\/* name of the cookie to look for *\/$/;"	m	struct:proxy	access:public
appsession_name_len	include/types/proxy.h	/^	int  appsession_name_len;		\/* strlen(appsession_name), computed only once *\/$/;"	m	struct:proxy	access:public
appsession_refresh	include/common/appsession.h	/^struct task *appsession_refresh(struct task *t);$/;"	p	signature:(struct task *t)
appsession_refresh	src/appsession.c	/^struct task *appsession_refresh(struct task *t)$/;"	f	signature:(struct task *t)
appsession_task_init	include/common/appsession.h	/^int appsession_task_init(void);$/;"	p	signature:(void)
appsession_task_init	src/appsession.c	/^int appsession_task_init(void)$/;"	f	signature:(void)
appsessions	include/common/appsession.h	/^typedef struct appsessions {$/;"	s
appsessions::expire	include/common/appsession.h	/^	int   expire;		\/* next expiration time for this application session (in tick) *\/$/;"	m	struct:appsessions	access:public
appsessions::hash_list	include/common/appsession.h	/^	struct list hash_list;$/;"	m	struct:appsessions	typeref:struct:appsessions::list	access:public
appsessions::request_count	include/common/appsession.h	/^	unsigned long int request_count;$/;"	m	struct:appsessions	access:public
appsessions::serverid	include/common/appsession.h	/^	char *serverid;$/;"	m	struct:appsessions	access:public
appsessions::sessid	include/common/appsession.h	/^	char *sessid;$/;"	m	struct:appsessions	access:public
arg	include/types/acl.h	/^	} arg;$/;"	m	struct:acl_expr	typeref:union:acl_expr::__anon54	access:public
arg	include/types/pattern.h	/^	char *arg;                                \/* configured keyword argument *\/$/;"	m	struct:pattern_expr	access:public
arg	src/acl.c	/^	const char *arg;$/;"	l
arg	src/acl.c	/^	int arg, neg;$/;"	l
arg	src/backend.c	/^		int arg = 1;$/;"	l
arg	src/cfgparse.c	/^		int arg, kwm = KWM_STD;$/;"	l
arg	src/dumpstats.c	/^	int arg;$/;"	l
arg2	src/acl.c	/^		char *end, *arg2;$/;"	l
arg_end	src/acl.c	/^			int arg_end = arg + 1;$/;"	l
arg_i	include/types/pattern.h	/^	int arg_i;                                \/* int arg, most often the argument's length *\/$/;"	m	struct:pattern_conv_expr	access:public
arg_len	include/types/acl.h	/^	int arg_len;                \/* optional argument length *\/$/;"	m	struct:acl_expr	access:public
arg_len	include/types/pattern.h	/^	int arg_len;                              \/* configured keyword argument length *\/$/;"	m	struct:pattern_expr	access:public
arg_mode	src/haproxy.c	/^	int arg_mode = 0;	\/* MODE_DEBUG, ... *\/$/;"	l
arg_p	include/types/pattern.h	/^	void *arg_p;                              \/* pointer arg, most often a string argument *\/$/;"	m	struct:pattern_conv_expr	access:public
argp	src/buffers.c	/^	va_list argp;$/;"	l
argp	src/log.c	/^	va_list argp;$/;"	l
args	src/acl.c	/^	const char *args[2];$/;"	l
args	src/cfgparse.c	/^		char *args[MAX_LINE_ARGS + 1];$/;"	l
args	src/dumpstats.c	/^	char *args[MAX_STATS_ARGS + 1];$/;"	l
args_new	src/acl.c	/^			const char **args_new;$/;"	l
array	contrib/halog/halog.c	/^	int array[5];$/;"	l
as_hash_for_each_entry_safe	include/common/sessionhash.h	58;"	d
ascii_zero	src/standard.c	/^	const unsigned int ascii_zero = ('0' << 24) | ('0' << 16) | ('0' << 8) | '0';$/;"	l
asession	src/proto_http.c	/^		appsess *asession = NULL;$/;"	l
asession	src/proto_http.c	/^	appsess *asession = NULL;$/;"	l
assign_server	include/proto/backend.h	/^int assign_server(struct session *s);$/;"	p	signature:(struct session *s)
assign_server	src/backend.c	/^int assign_server(struct session *s)$/;"	f	signature:(struct session *s)
assign_server_address	include/proto/backend.h	/^int assign_server_address(struct session *s);$/;"	p	signature:(struct session *s)
assign_server_address	src/backend.c	/^int assign_server_address(struct session *s)$/;"	f	signature:(struct session *s)
assign_server_and_queue	include/proto/backend.h	/^int assign_server_and_queue(struct session *s);$/;"	p	signature:(struct session *s)
assign_server_and_queue	src/backend.c	/^int assign_server_and_queue(struct session *s)$/;"	f	signature:(struct session *s)
assign_tproxy_address	src/backend.c	/^static void assign_tproxy_address(struct session *s)$/;"	f	file:	signature:(struct session *s)
att_beg	src/proto_http.c	/^	char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;$/;"	l
att_end	src/proto_http.c	/^	char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;$/;"	l
attempts	src/checks.c	/^	int attempts = 0;$/;"	l
attempts	src/proto_tcp.c	/^			int attempts = 10; \/* should be more than enough to find a spare port *\/$/;"	l
au	src/auth.c	/^	struct auth_users *au, *tau;$/;"	l
auth	include/types/proto_http.h	/^	struct http_auth_data auth;	\/* HTTP auth data *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_auth_data	access:public
auth_find_userlist	include/proto/auth.h	/^struct userlist *auth_find_userlist(char *name);$/;"	p	signature:(char *name)
auth_find_userlist	src/auth.c	/^auth_find_userlist(char *name)$/;"	f	signature:(char *name)
auth_method	src/proto_http.c	/^	struct chunk auth_method;$/;"	l
auth_realm	include/common/uri_auth.h	/^	char *auth_realm;		\/* the realm reported to the client *\/$/;"	m	struct:uri_auth	access:public
auth_resolve_groups	include/proto/auth.h	/^unsigned int auth_resolve_groups(struct userlist *l, char *groups);$/;"	p	signature:(struct userlist *l, char *groups)
auth_resolve_groups	src/auth.c	/^auth_resolve_groups(struct userlist *l, char *groups)$/;"	f	signature:(struct userlist *l, char *groups)
auth_users	include/types/auth.h	/^struct auth_users {$/;"	s
auth_users::__anon28::group_mask	include/types/auth.h	/^		unsigned int group_mask;$/;"	m	union:auth_users::__anon28	access:public
auth_users::__anon28::groups	include/types/auth.h	/^		char *groups;$/;"	m	union:auth_users::__anon28	access:public
auth_users::flags	include/types/auth.h	/^	unsigned int flags;$/;"	m	struct:auth_users	access:public
auth_users::next	include/types/auth.h	/^	struct auth_users *next;$/;"	m	struct:auth_users	typeref:struct:auth_users::auth_users	access:public
auth_users::pass	include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users	access:public
auth_users::u	include/types/auth.h	/^	} u;$/;"	m	struct:auth_users	typeref:union:auth_users::__anon28	access:public
auth_users::user	include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users	access:public
avail	include/types/port_range.h	/^	int avail;			\/* number of available ports left *\/$/;"	m	struct:port_range	access:public
avoided	src/lb_chash.c	/^	struct server *srv, *avoided;$/;"	l
avoided	src/lb_fwlc.c	/^	struct server *srv, *avoided;$/;"	l
avoided	src/lb_fwrr.c	/^	struct server *srv, *full, *avoided;$/;"	l
avoided	src/lb_map.c	/^	struct server *srv, *avoided;$/;"	l
avoided_node	src/lb_chash.c	/^	struct eb32_node *node, *stop, *avoided_node;$/;"	l
avoididx	src/lb_map.c	/^	int newidx, avoididx;$/;"	l
b	contrib/halog/halog.c	/^	const char *b, *e, *p;$/;"	l
b	contrib/halog/halog.c	/^	const char *b, *e;$/;"	l
b	ebtree/ebtree.h	/^	eb_troot_t    *b[EB_NODE_BRANCHES]; \/* left and right branches *\/$/;"	m	struct:eb_root	access:public
b	include/types/fd.h	/^		struct buffer *b;            \/* read\/write buffer *\/$/;"	m	struct:fdtab::__anon56	typeref:struct:fdtab::__anon56::buffer	access:public
b	src/base64.c	/^	signed char b;$/;"	l
b	src/stream_sock.c	/^	struct buffer *b = si->ib;$/;"	l
b	src/stream_sock.c	/^	struct buffer *b = si->ob;$/;"	l
b	tests/sessionhash_test.c	/^	appsess *a, *b, *c, *d, *tmp;$/;"	l
b	tests/test_hashes.c	/^  uint32_t a,b,c;$/;"	l
b64tos30	include/common/base64.h	/^int b64tos30(const char *in);$/;"	p	signature:(const char *in)
b64tos30	src/base64.c	/^int b64tos30(const char *in)$/;"	f	signature:(const char *in)
b:current_syntax	examples/haproxy.vim	/^let b:current_syntax = "haproxy"$/;"	v
back	src/appsession.c	/^	appsess                *element, *back;$/;"	l
back	src/session.c	/^	struct bref *bref, *back;$/;"	l
back_refs	include/types/session.h	/^	struct list back_refs;			\/* list of users tracking this session *\/$/;"	m	struct:session	typeref:struct:session::list	access:public
backend	include/types/proxy.h	/^		struct proxy *backend;		\/* target backend *\/$/;"	m	union:switching_rule::__anon21	typeref:struct:switching_rule::__anon21::proxy	access:public
backend	src/proto_http.c	/^	char *backend = NULL;$/;"	l
backend_lb_algo_str	include/proto/backend.h	/^const char *backend_lb_algo_str(int algo);$/;"	p	signature:(int algo)
backend_lb_algo_str	src/backend.c	/^const char *backend_lb_algo_str(int algo) {$/;"	f	signature:(int algo)
backend_parse_balance	include/proto/backend.h	/^int backend_parse_balance(const char **args, char *err,$/;"	p	signature:(const char **args, char *err, int errlen, struct proxy *curproxy)
backend_parse_balance	src/backend.c	/^int backend_parse_balance(const char **args, char *err, int errlen, struct proxy *curproxy)$/;"	f	signature:(const char **args, char *err, int errlen, struct proxy *curproxy)
backlog	include/types/protocols.h	/^	unsigned int backlog;		\/* if set, listen backlog *\/$/;"	m	struct:listener	access:public
backlog	include/types/proxy.h	/^	unsigned int backlog;			\/* force the frontend's listen backlog *\/$/;"	m	struct:proxy	access:public
backname	src/proto_uxst.c	/^	char backname[MAXPATHLEN];$/;"	l
base	contrib/base64/base64rev-gen.c	18;"	d	file:
base64dec	include/common/base64.h	/^int base64dec(const char *in, size_t ilen, char *out, size_t olen);$/;"	p	signature:(const char *in, size_t ilen, char *out, size_t olen)
base64dec	src/base64.c	/^int base64dec(const char *in, size_t ilen, char *out, size_t olen) {$/;"	f	signature:(const char *in, size_t ilen, char *out, size_t olen)
base64rev	contrib/base64/base64rev-gen.c	/^char base64rev[128];$/;"	v
base64rev	src/base64.c	/^const char base64rev[]="b###cXYZ[\\\\]^_`a###d###$%&'()*+,-.\/0123456789:;<=######>?@ABCDEFGHIJKLMNOPQRSTUVW";$/;"	v
base64tab	contrib/base64/base64rev-gen.c	/^const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v
base64tab	include/common/base64.h	/^extern const char base64tab[];$/;"	x
base64tab	src/base64.c	/^const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v
batched	src/stick_table.c	/^	int batched = 0;$/;"	l
bck	include/types/lb_chash.h	/^	struct eb_root bck;	\/* weighted chash entries of backup servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root	access:public
bck	include/types/lb_fwlc.h	/^	struct eb_root bck;	\/* weighted least conns on the backup servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root	access:public
bck	include/types/lb_fwrr.h	/^	struct fwrr_group bck;	\/* weighted round robin on the backup servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group	access:public
bck	src/lb_map.c	/^	int act, bck;$/;"	l
be	include/types/counters.h	/^	} fe, be;				\/* FE and BE stats *\/$/;"	m	struct:pxcounters	typeref:union:pxcounters::__anon58	access:public
be	include/types/proxy.h	/^		struct proxy *be;		\/* default backend, or NULL if none set *\/$/;"	m	union:proxy::__anon17	typeref:struct:proxy::__anon17::proxy	access:public
be	include/types/proxy.h	/^	} be;$/;"	m	struct:switching_rule	typeref:union:switching_rule::__anon21	access:public
be	include/types/session.h	/^	struct proxy *be;			\/* the proxy this session depends on for the server side *\/$/;"	m	struct:session	typeref:struct:session::proxy	access:public
be	src/log.c	/^	struct proxy *be = s->be;$/;"	l
be	src/proto_http.c	/^	struct proxy *be = s->be;$/;"	l
be_downtime	include/proto/backend.h	/^int be_downtime(struct proxy *px);$/;"	p	signature:(struct proxy *px)
be_downtime	src/backend.c	/^int be_downtime(struct proxy *px) {$/;"	f	signature:(struct proxy *px)
be_req_ana	include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy	access:public
be_rsp_ana	include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy	access:public
be_sess_per_sec	include/types/proxy.h	/^	struct freq_ctr be_sess_per_sec;	\/* sessions per second on the backend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr	access:public
be_sps_max	include/types/counters.h	/^	unsigned int be_sps_max;		\/* maximum of new sessions per second seen on the backend *\/$/;"	m	struct:pxcounters	access:public
beconn	include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends sessions *\/$/;"	m	struct:proxy	access:public
beconn_max	include/types/counters.h	/^	unsigned int feconn_max, beconn_max;	\/* max # of active frontend and backend sessions *\/$/;"	m	struct:pxcounters	access:public
beg	ebtree/ebtree.h	/^	int beg;$/;"	l
beg	src/backend.c	/^			const char *beg, *end;$/;"	l
beg	src/backend.c	/^		const char *beg, *end;$/;"	l
beg	src/cfgparse.c	/^				const char *beg, *end;$/;"	l
beg	src/proto_http.c	/^			char *beg = buf->w + buf->send_max;$/;"	l
bernstein	tests/test_hashes.c	/^ub4 bernstein(ub1 *key, ub4 len, ub4 level){$/;"	f	signature:(ub1 *key, ub4 len, ub4 level)
best	src/lb_map.c	/^	struct server *cur, *best;$/;"	l
bind_addr	src/proto_tcp.c	/^	struct sockaddr_in bind_addr;$/;"	l
bind_all	include/types/protocols.h	/^	int (*bind_all)(struct protocol *proto);	\/* bind all unbound listeners *\/$/;"	m	struct:protocol	access:public
bind_attempts	src/checks.c	/^						int bind_attempts = 10; \/* should be more than enough to find a spare port *\/$/;"	l
bind_hdr_len	include/types/proxy.h	/^	int bind_hdr_len;			\/* length of the name of the header above *\/$/;"	m	struct:proxy	access:public
bind_hdr_len	include/types/server.h	/^	int bind_hdr_len;			\/* length of the name of the header above *\/$/;"	m	struct:server	access:public
bind_hdr_name	include/types/proxy.h	/^	char *bind_hdr_name;			\/* bind to this header name if defined *\/$/;"	m	struct:proxy	access:public
bind_hdr_name	include/types/server.h	/^	char *bind_hdr_name;			\/* bind to this header name if defined *\/$/;"	m	struct:server	access:public
bind_hdr_occ	include/types/proxy.h	/^	int bind_hdr_occ;			\/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled *\/$/;"	m	struct:proxy	access:public
bind_hdr_occ	include/types/server.h	/^	int bind_hdr_occ;			\/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled *\/$/;"	m	struct:server	access:public
bind_proc	include/types/proxy.h	/^	unsigned int bind_proc;			\/* bitmask of processes using this proxy. 0 = all. *\/$/;"	m	struct:proxy	access:public
bit	ebtree/ebimtree.h	/^	int bit;$/;"	l
bit	ebtree/ebistree.h	/^	int bit;$/;"	l
bit	ebtree/ebmbtree.h	/^	int bit;$/;"	l
bit	ebtree/ebsttree.h	/^	int bit;$/;"	l
bit	ebtree/ebtree.h	/^	int bit, ret;$/;"	l
bit	ebtree/ebtree.h	/^	short int      bit;     \/* link's bit position. *\/$/;"	m	struct:eb_node	access:public
bit	tests/uri_hash.c	/^	int bit;$/;"	l
bit_a	ebtree/ebtree.h	/^	unsigned char bit_a, bit_b;$/;"	l
bit_b	ebtree/ebtree.h	/^	unsigned char bit_a, bit_b;$/;"	l
bits	ebtree/ebtree.h	/^	unsigned int bits = 32;$/;"	l
bits	tests/uri_hash.c	/^    int bits;$/;"	l
bleft	src/proto_tcp.c	/^	int bleft;$/;"	l
bleft	src/proto_tcp.c	/^	int version, bleft, msg_len;$/;"	l
block1	src/proto_http.c	/^		int block1 = buf->l;$/;"	l
block2	src/proto_http.c	/^		int block2 = 0;$/;"	l
block_cond	include/types/proxy.h	/^	struct list block_cond;                 \/* early blocking conditions (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
blocked_sig	src/signal.c	/^sigset_t blocked_sig;$/;"	v
bol	include/types/session.h	/^			int bol;		\/* pointer to beginning of current line *\/$/;"	m	struct:session::__anon9::__anon12	access:public
bp	src/fd.c	/^	struct poller *bp;$/;"	l
branches	ebtree/ebtree.h	/^	struct eb_root branches; \/* branches, must be at the beginning *\/$/;"	m	struct:eb_node	typeref:struct:eb_node::eb_root	access:public
bref	include/common/mini-clist.h	/^struct bref {$/;"	s
bref	include/types/session.h	/^			struct bref bref;	\/* back-reference from the session being dumped *\/$/;"	m	struct:session::__anon9::__anon11	typeref:struct:session::__anon9::__anon11::bref	access:public
bref	src/session.c	/^	struct bref *bref, *back;$/;"	l
bref::ref	include/common/mini-clist.h	/^	struct list *ref; \/* pointer to the target's list entry *\/$/;"	m	struct:bref	typeref:struct:bref::list	access:public
bref::users	include/common/mini-clist.h	/^	struct list users;$/;"	m	struct:bref	typeref:struct:bref::list	access:public
buf	include/types/proxy.h	/^	char buf[BUFSIZE];		\/* copy of the beginning of the message *\/$/;"	m	struct:error_snapshot	access:public
buf	include/types/session.h	/^			unsigned int buf;	\/* buffer being dumped, 0 = req, 1 = rep *\/$/;"	m	struct:session::__anon9::__anon12	access:public
buf	include/types/stick_table.h	/^	char buf[BUFSIZE];        \/* used to store a null terminated string key *\/$/;"	m	union:stktable_key_data	access:public
buf	src/proto_http.c	/^	struct buffer *buf = s->rep;$/;"	l
buf	src/proto_http.c	/^	struct buffer *buf = s->req;$/;"	l
buf2ip	src/pattern.c	/^static int buf2ip(const char *buf, size_t len, struct in_addr *dst)$/;"	f	file:	signature:(const char *buf, size_t len, struct in_addr *dst)
buffer	contrib/halog/fgets2-64.c	/^	static char buffer[FGETS2_BUFSIZE + 9]; \/\/ +9 to have zeroes past the end$/;"	l	file:
buffer	contrib/halog/fgets2.c	/^	static char buffer[FGETS2_BUFSIZE + 5];$/;"	l	file:
buffer	include/types/buffers.h	/^struct buffer {$/;"	s
buffer::analyse_exp	include/types/buffers.h	/^	int analyse_exp;                \/* expiration date for current analysers (if set) *\/$/;"	m	struct:buffer	access:public
buffer::analysers	include/types/buffers.h	/^	unsigned int analysers;         \/* bit field indicating what to do on the buffer *\/$/;"	m	struct:buffer	access:public
buffer::cons	include/types/buffers.h	/^	struct stream_interface *cons;  \/* consumer attached to this buffer *\/$/;"	m	struct:buffer	typeref:struct:buffer::stream_interface	access:public
buffer::cto	include/types/buffers.h	/^	int cto;                        \/* connect timeout, in ticks *\/$/;"	m	struct:buffer	access:public
buffer::data	include/types/buffers.h	/^	char data[0];                   \/* <size> bytes *\/$/;"	m	struct:buffer	access:public
buffer::flags	include/types/buffers.h	/^	unsigned int flags;             \/* BF_* *\/$/;"	m	struct:buffer	access:public
buffer::hijacker	include/types/buffers.h	/^	void (*hijacker)(struct session *, struct buffer *); \/* alternative content producer *\/$/;"	m	struct:buffer	access:public
buffer::l	include/types/buffers.h	/^	unsigned int l;                 \/* data length *\/$/;"	m	struct:buffer	access:public
buffer::lr	include/types/buffers.h	/^	char *r, *w, *lr;               \/* read ptr, write ptr, last read *\/$/;"	m	struct:buffer	access:public
buffer::pipe	include/types/buffers.h	/^	struct pipe *pipe;		\/* non-NULL only when data present *\/$/;"	m	struct:buffer	typeref:struct:buffer::pipe	access:public
buffer::prod	include/types/buffers.h	/^	struct stream_interface *prod;  \/* producer attached to this buffer *\/$/;"	m	struct:buffer	typeref:struct:buffer::stream_interface	access:public
buffer::r	include/types/buffers.h	/^	char *r, *w, *lr;               \/* read ptr, write ptr, last read *\/$/;"	m	struct:buffer	access:public
buffer::rex	include/types/buffers.h	/^	int rex;                        \/* expiration date for a read, in ticks *\/$/;"	m	struct:buffer	access:public
buffer::rto	include/types/buffers.h	/^	int rto;                        \/* read timeout, in ticks *\/$/;"	m	struct:buffer	access:public
buffer::send_max	include/types/buffers.h	/^	unsigned int send_max;          \/* number of bytes the sender can consume om this buffer, <= l *\/$/;"	m	struct:buffer	access:public
buffer::size	include/types/buffers.h	/^	unsigned int size;              \/* buffer size in bytes *\/$/;"	m	struct:buffer	access:public
buffer::to_forward	include/types/buffers.h	/^	unsigned long to_forward;       \/* number of bytes to forward after send_max without a wake-up *\/$/;"	m	struct:buffer	access:public
buffer::total	include/types/buffers.h	/^	unsigned long long total;       \/* total data read *\/$/;"	m	struct:buffer	access:public
buffer::w	include/types/buffers.h	/^	char *r, *w, *lr;               \/* read ptr, write ptr, last read *\/$/;"	m	struct:buffer	access:public
buffer::wex	include/types/buffers.h	/^	int wex;                        \/* expiration date for a write or connect, in ticks *\/$/;"	m	struct:buffer	access:public
buffer::wto	include/types/buffers.h	/^	int wto;                        \/* write timeout, in ticks *\/$/;"	m	struct:buffer	access:public
buffer::xfer_large	include/types/buffers.h	/^	unsigned char xfer_large;       \/* number of consecutive large xfers *\/$/;"	m	struct:buffer	access:public
buffer::xfer_small	include/types/buffers.h	/^	unsigned char xfer_small;       \/* number of consecutive small xfers *\/$/;"	m	struct:buffer	access:public
buffer_abort	include/proto/buffers.h	/^static inline void buffer_abort(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_almost_full	include/proto/buffers.h	/^static inline int buffer_almost_full(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_auto_close	include/proto/buffers.h	/^static inline void buffer_auto_close(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_auto_connect	include/proto/buffers.h	/^static inline void buffer_auto_connect(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_auto_read	include/proto/buffers.h	/^static inline void buffer_auto_read(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_bounce_realign	include/proto/buffers.h	/^void buffer_bounce_realign(struct buffer *buf);$/;"	p	signature:(struct buffer *buf)
buffer_bounce_realign	src/buffers.c	/^void buffer_bounce_realign(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_check_timeouts	include/proto/buffers.h	/^static inline void buffer_check_timeouts(struct buffer *b)$/;"	f	signature:(struct buffer *b)
buffer_contig_data	include/proto/buffers.h	/^static inline int buffer_contig_data(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_contig_space	include/proto/buffers.h	/^static inline int buffer_contig_space(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_cut_tail	include/proto/buffers.h	/^static inline void buffer_cut_tail(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_dont_close	include/proto/buffers.h	/^static inline void buffer_dont_close(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_dont_connect	include/proto/buffers.h	/^static inline void buffer_dont_connect(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_dont_read	include/proto/buffers.h	/^static inline void buffer_dont_read(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_dump	include/proto/buffers.h	/^void buffer_dump(FILE *o, struct buffer *b, int from, int to);$/;"	p	signature:(FILE *o, struct buffer *b, int from, int to)
buffer_dump	src/buffers.c	/^void buffer_dump(FILE *o, struct buffer *b, int from, int to)$/;"	f	signature:(FILE *o, struct buffer *b, int from, int to)
buffer_erase	include/proto/buffers.h	/^static inline void buffer_erase(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_feed	include/proto/buffers.h	/^static inline int buffer_feed(struct buffer *buf, const char *str)$/;"	f	signature:(struct buffer *buf, const char *str)
buffer_feed2	include/proto/buffers.h	/^int buffer_feed2(struct buffer *buf, const char *str, int len);$/;"	p	signature:(struct buffer *buf, const char *str, int len)
buffer_feed2	src/buffers.c	/^int buffer_feed2(struct buffer *buf, const char *str, int len)$/;"	f	signature:(struct buffer *buf, const char *str, int len)
buffer_feed_chunk	include/proto/buffers.h	/^static inline int buffer_feed_chunk(struct buffer *buf, struct chunk *chunk)$/;"	f	signature:(struct buffer *buf, struct chunk *chunk)
buffer_flush	include/proto/buffers.h	/^static inline void buffer_flush(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_forward	include/proto/buffers.h	/^static inline void buffer_forward(struct buffer *buf, unsigned long bytes)$/;"	f	signature:(struct buffer *buf, unsigned long bytes)
buffer_ignore	include/proto/buffers.h	/^static inline void buffer_ignore(struct buffer *buf, int n)$/;"	f	signature:(struct buffer *buf, int n)
buffer_init	include/proto/buffers.h	/^static inline void buffer_init(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_insert_line2	include/proto/buffers.h	/^int buffer_insert_line2(struct buffer *b, char *pos, const char *str, int len);$/;"	p	signature:(struct buffer *b, char *pos, const char *str, int len)
buffer_insert_line2	src/buffers.c	/^int buffer_insert_line2(struct buffer *b, char *pos, const char *str, int len)$/;"	f	signature:(struct buffer *b, char *pos, const char *str, int len)
buffer_install_hijacker	include/proto/buffers.h	/^static inline void buffer_install_hijacker(struct session *s,$/;"	f	signature:(struct session *s, struct buffer *b, void (*func)(struct session *, struct buffer *))
buffer_max	include/proto/buffers.h	/^static inline int buffer_max(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buffer_max_len	include/proto/buffers.h	/^static inline int buffer_max_len(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_realign	include/proto/buffers.h	/^static inline int buffer_realign(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_replace	include/proto/buffers.h	/^int buffer_replace(struct buffer *b, char *pos, char *end, const char *str);$/;"	p	signature:(struct buffer *b, char *pos, char *end, const char *str)
buffer_replace	src/buffers.c	/^int buffer_replace(struct buffer *b, char *pos, char *end, const char *str)$/;"	f	signature:(struct buffer *b, char *pos, char *end, const char *str)
buffer_replace2	include/proto/buffers.h	/^int buffer_replace2(struct buffer *b, char *pos, char *end, const char *str, int len);$/;"	p	signature:(struct buffer *b, char *pos, char *end, const char *str, int len)
buffer_replace2	src/buffers.c	/^int buffer_replace2(struct buffer *b, char *pos, char *end, const char *str, int len)$/;"	f	signature:(struct buffer *b, char *pos, char *end, const char *str, int len)
buffer_shutr_now	include/proto/buffers.h	/^static inline void buffer_shutr_now(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_shutw_now	include/proto/buffers.h	/^static inline void buffer_shutw_now(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_si_peekchar	include/proto/buffers.h	/^static inline int buffer_si_peekchar(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_si_peekline	include/proto/buffers.h	/^int buffer_si_peekline(struct buffer *buf, char *str, int len);$/;"	p	signature:(struct buffer *buf, char *str, int len)
buffer_si_peekline	src/buffers.c	/^int buffer_si_peekline(struct buffer *buf, char *str, int len)$/;"	f	signature:(struct buffer *buf, char *str, int len)
buffer_si_putchar	include/proto/buffers.h	/^int buffer_si_putchar(struct buffer *buf, char c);$/;"	p	signature:(struct buffer *buf, char c)
buffer_si_putchar	include/proto/buffers.h	/^static inline int buffer_si_putchar(struct buffer *buf, char c)$/;"	f	signature:(struct buffer *buf, char c)
buffer_skip	include/proto/buffers.h	/^static inline void buffer_skip(struct buffer *buf, int len)$/;"	f	signature:(struct buffer *buf, int len)
buffer_stop_hijack	include/proto/buffers.h	/^static inline void buffer_stop_hijack(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buffer_write	include/proto/buffers.h	/^int buffer_write(struct buffer *buf, const char *msg, int len);$/;"	p	signature:(struct buffer *buf, const char *msg, int len)
buffer_write	src/buffers.c	/^int buffer_write(struct buffer *buf, const char *msg, int len)$/;"	f	signature:(struct buffer *buf, const char *msg, int len)
buffer_write_chunk	include/proto/buffers.h	/^static inline int buffer_write_chunk(struct buffer *buf, struct chunk *chunk)$/;"	f	signature:(struct buffer *buf, struct chunk *chunk)
bufsize	include/types/global.h	/^		int bufsize;       \/* buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon16	access:public
build_acl_cond	include/proto/acl.h	/^struct acl_cond *build_acl_cond(const char *file, int line, struct proxy *px, const char **args);$/;"	p	signature:(const char *file, int line, struct proxy *px, const char **args)
build_acl_cond	src/acl.c	/^struct acl_cond *build_acl_cond(const char *file, int line, struct proxy *px, const char **args)$/;"	f	signature:(const char *file, int line, struct proxy *px, const char **args)
bytes	src/proto_http.c	/^			int bytes = msg->sov - msg->som;$/;"	l
bytes	src/proto_http.c	/^		int bytes;$/;"	l
bytes	src/proto_http.c	/^	int bytes, len;$/;"	l
bytes	src/proto_http.c	/^	int bytes;$/;"	l
bytes	src/session.c	/^	unsigned long long bytes;$/;"	l
bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:licounters	access:public
bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:pxcounters	access:public
bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:srvcounters	access:public
bytes_in	include/types/session.h	/^		long long bytes_in;		\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:session::__anon8	access:public
bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:licounters	access:public
bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:pxcounters	access:public
bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:srvcounters	access:public
bytes_out	include/types/session.h	/^		long long bytes_out;		\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:session::__anon8	access:public
c	contrib/base64/base64rev-gen.c	/^	char *p, c;$/;"	l
c	contrib/halog/halog.c	/^	unsigned char c;$/;"	l
c	ebtree/ebtree.h	/^		unsigned char c;$/;"	l
c	ebtree/ebtree.h	/^	unsigned char c;$/;"	l
c	include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
c	src/acl.c	/^	char *c, *end;$/;"	l
c	src/acl.c	/^	char *c;$/;"	l
c	src/backend.c	/^	int c;$/;"	l
c	src/buffers.c	/^	char c;$/;"	l
c	src/cfgparse.c	/^				char c;$/;"	l
c	src/cfgparse.c	/^		char c;$/;"	l
c	src/cfgparse.c	/^	char *c, *next, *range, *dupstr;$/;"	l
c	src/dumpstats.c	/^	unsigned char c;$/;"	l
c	src/proto_http.c	/^		int c;$/;"	l
c	src/standard.c	/^		char c = *sample ^ *word;$/;"	l
c	src/standard.c	/^	char *c, *s;$/;"	l
c	src/standard.c	/^	char *c;$/;"	l
c	tests/sessionhash_test.c	/^	appsess *a, *b, *c, *d, *tmp;$/;"	l
c	tests/test_hashes.c	/^  int c;$/;"	l
c	tests/test_hashes.c	/^  uint32_t a,b,c;$/;"	l
c	tests/uri_hash.c	/^    int c;$/;"	l
c_donothing	src/pattern.c	/^static int c_donothing(union pattern_data *data)$/;"	f	file:	signature:(union pattern_data *data)
c_int2ip	src/pattern.c	/^static int c_int2ip(union pattern_data *data)$/;"	f	file:	signature:(union pattern_data *data)
c_int2str	src/pattern.c	/^static int c_int2str(union pattern_data *data)$/;"	f	file:	signature:(union pattern_data *data)
c_ip2int	src/pattern.c	/^static int c_ip2int(union pattern_data *data)$/;"	f	file:	signature:(union pattern_data *data)
c_ip2str	src/pattern.c	/^static int c_ip2str(union pattern_data *data)$/;"	f	file:	signature:(union pattern_data *data)
c_l	include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
c_str2int	src/pattern.c	/^static int c_str2int(union pattern_data *data)$/;"	f	file:	signature:(union pattern_data *data)
c_str2ip	src/pattern.c	/^static int c_str2ip(union pattern_data *data)$/;"	f	file:	signature:(union pattern_data *data)
cache_idx	include/types/acl.h	/^	int cache_idx;              \/* ACL index in cache *\/$/;"	m	struct:acl	access:public
calls	include/types/task.h	/^	unsigned int calls;		\/* number of times ->process() was called *\/$/;"	m	struct:task	access:public
cap	include/types/proto_http.h	/^	char **cap;                            \/* array of captured headers (may be NULL) *\/$/;"	m	struct:http_msg	access:public
cap	include/types/proxy.h	/^	int cap;				\/* supported capabilities (PR_CAP_*) *\/$/;"	m	struct:proxy	access:public
cap	src/cfgparse.c	/^	unsigned int cap;$/;"	m	struct:cfg_opt	file:	access:public
cap	src/proxy.c	/^	int retval, cap;$/;"	l
cap_hdr	include/types/capture.h	/^struct cap_hdr {$/;"	s
cap_hdr::index	include/types/capture.h	/^    int index;				\/* index in the output array *\/$/;"	m	struct:cap_hdr	access:public
cap_hdr::len	include/types/capture.h	/^    int len;				\/* capture length, not including terminal zero *\/$/;"	m	struct:cap_hdr	access:public
cap_hdr::name	include/types/capture.h	/^    char *name;				\/* header name, case insensitive *\/$/;"	m	struct:cap_hdr	access:public
cap_hdr::namelen	include/types/capture.h	/^    int namelen;			\/* length of the header name, to speed-up lookups *\/$/;"	m	struct:cap_hdr	access:public
cap_hdr::next	include/types/capture.h	/^    struct cap_hdr *next;$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::cap_hdr	access:public
cap_hdr::pool	include/types/capture.h	/^    struct pool_head *pool;		\/* pool of pre-allocated memory area of (len+1) bytes *\/$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::pool_head	access:public
capture_headers	src/proto_http.c	/^void capture_headers(char *som, struct hdr_idx *idx,$/;"	f	signature:(char *som, struct hdr_idx *idx, char **cap, struct cap_hdr *cap_hdr)
capture_len	include/types/proxy.h	/^	int  capture_len;			\/* length of the string to be captured *\/$/;"	m	struct:proxy	access:public
capture_name	include/types/proxy.h	/^	char *capture_name;			\/* beginning of the name of the cookie to capture *\/$/;"	m	struct:proxy	access:public
capture_namelen	include/types/proxy.h	/^	int  capture_namelen;			\/* length of the cookie name to match *\/$/;"	m	struct:proxy	access:public
cb	include/types/fd.h	/^	} cb[DIR_SIZE];$/;"	m	struct:fdtab	typeref:struct:fdtab::__anon56	access:public
cfd	src/client.c	/^	int cfd;$/;"	l
cfd	src/proto_uxst.c	/^	int cfd;$/;"	l
cfg_cfgfiles	src/haproxy.c	/^static struct list cfg_cfgfiles = LIST_HEAD_INIT(cfg_cfgfiles);$/;"	v	typeref:struct:list	file:
cfg_keyword	include/common/cfgparse.h	/^struct cfg_keyword {$/;"	s
cfg_keyword::kw	include/common/cfgparse.h	/^	const char *kw;                         \/* the keyword itself *\/$/;"	m	struct:cfg_keyword	access:public
cfg_keyword::parse	include/common/cfgparse.h	/^	int (*parse)(                           \/* 0=OK, <0=Alert, >0=Warning *\/$/;"	m	struct:cfg_keyword	access:public
cfg_keyword::section	include/common/cfgparse.h	/^	int section;                            \/* section type for this keyword *\/$/;"	m	struct:cfg_keyword	access:public
cfg_keywords	src/cfgparse.c	/^static struct cfg_kw_list cfg_keywords = {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kw_list	include/common/cfgparse.h	/^struct cfg_kw_list {$/;"	s
cfg_kw_list::kw	include/common/cfgparse.h	/^	struct cfg_keyword kw[VAR_ARRAY];$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::cfg_keyword	access:public
cfg_kw_list::list	include/common/cfgparse.h	/^	struct list list;$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::list	access:public
cfg_kws	src/dumpstats.c	/^static struct cfg_kw_list cfg_kws = {{ },{$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kws	src/proto_tcp.c	/^static struct cfg_kw_list cfg_kws = {{ },{$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kws	src/proxy.c	/^static struct cfg_kw_list cfg_kws = {{ },{$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_maxconn	include/common/cfgparse.h	/^extern int cfg_maxconn;$/;"	x
cfg_maxconn	src/cfgparse.c	/^int cfg_maxconn = 0;			\/* # of simultaneous connections, (-n) *\/$/;"	v
cfg_maxpconn	include/common/cfgparse.h	/^extern int cfg_maxpconn;$/;"	x
cfg_maxpconn	src/cfgparse.c	/^int cfg_maxpconn = DEFAULT_MAXCONN;	\/* # of simultaneous connections per proxy (-N) *\/$/;"	v
cfg_opt	src/cfgparse.c	/^struct cfg_opt {$/;"	s	file:
cfg_opt::cap	src/cfgparse.c	/^	unsigned int cap;$/;"	m	struct:cfg_opt	file:	access:public
cfg_opt::checks	src/cfgparse.c	/^	unsigned int checks;$/;"	m	struct:cfg_opt	file:	access:public
cfg_opt::mode	src/cfgparse.c	/^	unsigned int mode;$/;"	m	struct:cfg_opt	file:	access:public
cfg_opt::name	src/cfgparse.c	/^	const char *name;$/;"	m	struct:cfg_opt	file:	access:public
cfg_opt::val	src/cfgparse.c	/^	unsigned int val;$/;"	m	struct:cfg_opt	file:	access:public
cfg_opts	src/cfgparse.c	/^static const struct cfg_opt cfg_opts[] =$/;"	v	typeref:struct:cfg_opt	file:
cfg_opts2	src/cfgparse.c	/^static const struct cfg_opt cfg_opts2[] =$/;"	v	typeref:struct:cfg_opt	file:
cfg_parse_global	include/common/cfgparse.h	/^int cfg_parse_global(const char *file, int linenum, char **args, int inv);$/;"	p	signature:(const char *file, int linenum, char **args, int inv)
cfg_parse_global	src/cfgparse.c	/^int cfg_parse_global(const char *file, int linenum, char **args, int kwm)$/;"	f	signature:(const char *file, int linenum, char **args, int kwm)
cfg_parse_listen	include/common/cfgparse.h	/^int cfg_parse_listen(const char *file, int linenum, char **args, int inv);$/;"	p	signature:(const char *file, int linenum, char **args, int inv)
cfg_parse_listen	src/cfgparse.c	/^int cfg_parse_listen(const char *file, int linenum, char **args, int kwm)$/;"	f	signature:(const char *file, int linenum, char **args, int kwm)
cfg_parse_users	src/cfgparse.c	/^cfg_parse_users(const char *file, int linenum, char **args, int kwm)$/;"	f	signature:(const char *file, int linenum, char **args, int kwm)
cfg_pidfile	src/haproxy.c	/^	char *cfg_pidfile = NULL;$/;"	l
cfg_register_keywords	include/common/cfgparse.h	/^void cfg_register_keywords(struct cfg_kw_list *kwl);$/;"	p	signature:(struct cfg_kw_list *kwl)
cfg_register_keywords	src/cfgparse.c	/^void cfg_register_keywords(struct cfg_kw_list *kwl)$/;"	f	signature:(struct cfg_kw_list *kwl)
cfg_unregister_keywords	include/common/cfgparse.h	/^void cfg_unregister_keywords(struct cfg_kw_list *kwl);$/;"	p	signature:(struct cfg_kw_list *kwl)
cfg_unregister_keywords	src/cfgparse.c	/^void cfg_unregister_keywords(struct cfg_kw_list *kwl)$/;"	f	signature:(struct cfg_kw_list *kwl)
cfgerr	src/acl.c	/^	int cfgerr = 0;$/;"	l
cfgerr	src/cfgparse.c	/^	int cfgerr = 0;$/;"	l
ch	src/pattern.c	/^	int saw_digit, octets, ch;$/;"	l
ch	src/standard.c	/^	int saw_digit, octets, ch;$/;"	l
chain_regex	include/common/regex.h	/^const char *chain_regex(struct hdr_exp **head, const regex_t *preg,$/;"	p	signature:(struct hdr_exp **head, const regex_t *preg, int action, const char *replace, void *cond)
chain_regex	src/regex.c	/^const char *chain_regex(struct hdr_exp **head, const regex_t *preg,$/;"	f	signature:(struct hdr_exp **head, const regex_t *preg, int action, const char *replace, void *cond)
changes	src/ev_kqueue.c	/^	int changes = 0;$/;"	l
chash	include/types/backend.h	/^	struct lb_chash chash;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_chash	access:public
chash_dequeue_srv	src/lb_chash.c	/^static inline void chash_dequeue_srv(struct server *s)$/;"	f	file:	signature:(struct server *s)
chash_get_next_server	include/proto/lb_chash.h	/^struct server *chash_get_next_server(struct proxy *p, struct server *srvtoavoid);$/;"	p	signature:(struct proxy *p, struct server *srvtoavoid)
chash_get_next_server	src/lb_chash.c	/^struct server *chash_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f	signature:(struct proxy *p, struct server *srvtoavoid)
chash_get_server_hash	include/proto/lb_chash.h	/^struct server *chash_get_server_hash(struct proxy *p, unsigned int hash);$/;"	p	signature:(struct proxy *p, unsigned int hash)
chash_get_server_hash	src/lb_chash.c	/^struct server *chash_get_server_hash(struct proxy *p, unsigned int hash)$/;"	f	signature:(struct proxy *p, unsigned int hash)
chash_hash	src/lb_chash.c	/^static inline unsigned int chash_hash(unsigned int a)$/;"	f	file:	signature:(unsigned int a)
chash_init_server_tree	include/proto/lb_chash.h	/^void chash_init_server_tree(struct proxy *p);$/;"	p	signature:(struct proxy *p)
chash_init_server_tree	src/lb_chash.c	/^void chash_init_server_tree(struct proxy *p)$/;"	f	signature:(struct proxy *p)
chash_queue_dequeue_srv	src/lb_chash.c	/^static inline void chash_queue_dequeue_srv(struct server *s)$/;"	f	file:	signature:(struct server *s)
chash_set_server_status_down	src/lb_chash.c	/^static void chash_set_server_status_down(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
chash_set_server_status_up	src/lb_chash.c	/^static void chash_set_server_status_up(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
chash_skip_node	src/lb_chash.c	/^static inline struct eb32_node *chash_skip_node(struct eb_root *root, struct eb32_node *node)$/;"	f	file:	signature:(struct eb_root *root, struct eb32_node *node)
chash_update_server_weight	src/lb_chash.c	/^static void chash_update_server_weight(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
check	include/types/proxy.h	/^		int check;                      \/* maximum time for complete check *\/$/;"	m	struct:proxy::__anon19	access:public
check	include/types/server.h	/^	struct task *check;                     \/* the task associated to the health check processing *\/$/;"	m	struct:server	typeref:struct:server::task	access:public
check_addr	include/types/server.h	/^	struct sockaddr_in check_addr;		\/* the address to check, if different from <addr> *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_in	access:public
check_bits	ebtree/ebtree.h	/^static forceinline int check_bits(const unsigned char *a,$/;"	f	signature:(const unsigned char *a, const unsigned char *b, int skip, int len)
check_code	include/types/server.h	/^	short check_status, check_code;		\/* check result, check code *\/$/;"	m	struct:server	access:public
check_config_validity	include/common/cfgparse.h	/^int check_config_validity();$/;"	p	signature:()
check_config_validity	src/cfgparse.c	/^int check_config_validity()$/;"	f
check_cttproxy_version	include/proto/cttproxy.h	/^int check_cttproxy_version();$/;"	p	signature:()
check_cttproxy_version	src/cttproxy.c	/^int check_cttproxy_version() {$/;"	f
check_data	include/types/server.h	/^	char *check_data;			\/* storage of partial check results *\/$/;"	m	struct:server	access:public
check_data_len	include/types/server.h	/^	int check_data_len;			\/* length of partial check results stored in check_data *\/$/;"	m	struct:server	access:public
check_desc	include/types/server.h	/^	char check_desc[HCHK_DESC_LEN];		\/* health check descritpion *\/$/;"	m	struct:server	access:public
check_duration	include/types/server.h	/^	long check_duration;			\/* time in ms took to finish last health check *\/$/;"	m	struct:server	access:public
check_for_pending	src/checks.c	/^static int check_for_pending(struct server *s)$/;"	f	file:	signature:(struct server *s)
check_len	include/types/proxy.h	/^	int check_len;				\/* Length of the HTTP or SSL3 request *\/$/;"	m	struct:proxy	access:public
check_len	src/checks.c	/^			int check_len = s->proxy->check_len;$/;"	l
check_port	include/types/server.h	/^	short check_port;			\/* the port to use for the health checks *\/$/;"	m	struct:server	access:public
check_replace_string	include/common/regex.h	/^const char *check_replace_string(const char *str);$/;"	p	signature:(const char *str)
check_replace_string	src/regex.c	/^const char *check_replace_string(const char *str)$/;"	f	signature:(const char *str)
check_req	include/types/proxy.h	/^	char *check_req;			\/* HTTP or SSL request to use for PR_O_HTTP_CHK|PR_O_SSL3_CHK *\/$/;"	m	struct:proxy	access:public
check_req	src/checks.c	/^			const char *check_req = s->proxy->check_req;$/;"	l
check_response_for_cacheability	include/proto/proto_http.h	/^void check_response_for_cacheability(struct session *t, struct buffer *rtr);$/;"	p	signature:(struct session *t, struct buffer *rtr)
check_response_for_cacheability	src/proto_http.c	/^void check_response_for_cacheability(struct session *t, struct buffer *rtr)$/;"	f	signature:(struct session *t, struct buffer *rtr)
check_start	include/types/server.h	/^	struct timeval check_start;		\/* last health check start time *\/$/;"	m	struct:server	typeref:struct:server::timeval	access:public
check_status	include/types/checks.h	/^struct check_status {$/;"	s
check_status	include/types/server.h	/^	short check_status, check_code;		\/* check result, check code *\/$/;"	m	struct:server	access:public
check_status::desc	include/types/checks.h	/^	char *desc;			\/* long description *\/$/;"	m	struct:check_status	access:public
check_status::info	include/types/checks.h	/^	char *info;			\/* human readable short info *\/$/;"	m	struct:check_status	access:public
check_status::result	include/types/checks.h	/^	short result;			\/* one of SRV_CHK_* *\/$/;"	m	struct:check_status	access:public
check_statuses	src/checks.c	/^const struct check_status check_statuses[HCHK_STATUS_SIZE] = {$/;"	v	typeref:struct:check_status
check_user	src/auth.c	/^check_user(struct userlist *ul, unsigned int group_mask, const char *user, const char *pass)$/;"	f	signature:(struct userlist *ul, unsigned int group_mask, const char *user, const char *pass)
checks	src/cfgparse.c	/^	unsigned int checks;$/;"	m	struct:cfg_opt	file:	access:public
chg	src/ev_epoll.c	/^	int chg, fd;$/;"	l
chg_list	src/ev_epoll.c	/^static struct fd_chg *chg_list = NULL;	\/\/ list of changes$/;"	v	typeref:struct:fd_chg	file:
chg_ptr	src/ev_epoll.c	/^static struct fd_chg **chg_ptr = NULL;	\/\/ per-fd changes$/;"	v	typeref:struct:fd_chg	file:
child	src/rbtree.c	/^	struct rb_node *child, *parent;$/;"	l
chk_rcv	include/types/stream_interface.h	/^	void (*chk_rcv)(struct stream_interface *);\/* chk_rcv function *\/$/;"	m	struct:stream_interface	access:public
chk_snd	include/types/stream_interface.h	/^	void (*chk_snd)(struct stream_interface *);\/* chk_snd function *\/$/;"	m	struct:stream_interface	access:public
chksize	include/types/global.h	/^		int chksize;       \/* check buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon16	access:public
chlen	src/proto_tcp.c	/^		int rlen, plen, cilen, silen, chlen;$/;"	l
chroot	include/types/global.h	/^	char *chroot;$/;"	m	struct:global	access:public
chunk	include/types/buffers.h	/^struct chunk {$/;"	s
chunk	src/proto_http.c	/^	unsigned int chunk = 0;$/;"	l
chunk::len	include/types/buffers.h	/^	int len;	\/* current size of the string from first to last char. <0 = uninit. *\/$/;"	m	struct:chunk	access:public
chunk::size	include/types/buffers.h	/^	size_t size;	\/* total size of the buffer, 0 if the *str is read-only *\/$/;"	m	struct:chunk	access:public
chunk::str	include/types/buffers.h	/^	char *str;	\/* beginning of the string itself. Might not be 0-terminated *\/$/;"	m	struct:chunk	access:public
chunk_asciiencode	include/proto/buffers.h	/^int chunk_asciiencode(struct chunk *dst, struct chunk *src, char qc);$/;"	p	signature:(struct chunk *dst, struct chunk *src, char qc)
chunk_asciiencode	src/buffers.c	/^int chunk_asciiencode(struct chunk *dst, struct chunk *src, char qc) {$/;"	f	signature:(struct chunk *dst, struct chunk *src, char qc)
chunk_destroy	include/proto/buffers.h	/^static inline void chunk_destroy(struct chunk *chk) {$/;"	f	signature:(struct chunk *chk)
chunk_dup	include/proto/buffers.h	/^static inline char *chunk_dup(struct chunk *dst, const struct chunk *src) {$/;"	f	signature:(struct chunk *dst, const struct chunk *src)
chunk_htmlencode	include/proto/buffers.h	/^int chunk_htmlencode(struct chunk *dst, struct chunk *src);$/;"	p	signature:(struct chunk *dst, struct chunk *src)
chunk_htmlencode	src/buffers.c	/^int chunk_htmlencode(struct chunk *dst, struct chunk *src) {$/;"	f	signature:(struct chunk *dst, struct chunk *src)
chunk_init	include/proto/buffers.h	/^static inline void chunk_init(struct chunk *chk, char *str, size_t size) {$/;"	f	signature:(struct chunk *chk, char *str, size_t size)
chunk_initlen	include/proto/buffers.h	/^static inline int chunk_initlen(struct chunk *chk, char *str, size_t size, int len) {$/;"	f	signature:(struct chunk *chk, char *str, size_t size, int len)
chunk_initstr	include/proto/buffers.h	/^static inline void chunk_initstr(struct chunk *chk, char *str) {$/;"	f	signature:(struct chunk *chk, char *str)
chunk_printf	include/proto/buffers.h	/^int chunk_printf(struct chunk *chk, const char *fmt, ...)$/;"	p	signature:(struct chunk *chk, const char *fmt, ...)
chunk_printf	src/buffers.c	/^int chunk_printf(struct chunk *chk, const char *fmt, ...)$/;"	f	signature:(struct chunk *chk, const char *fmt, ...)
chunk_reset	include/proto/buffers.h	/^static inline void chunk_reset(struct chunk *chk) {$/;"	f	signature:(struct chunk *chk)
chunk_strcpy	include/proto/buffers.h	/^static inline int chunk_strcpy(struct chunk *chk, const char *str) {$/;"	f	signature:(struct chunk *chk, const char *str)
cilen	src/proto_tcp.c	/^		int rlen, plen, cilen, silen, chlen;$/;"	l
cklen	include/types/server.h	/^	int cklen;				\/* the len of the cookie, to speed up checks *\/$/;"	m	struct:server	access:public
cl	src/proto_http.c	/^		signed long long cl;$/;"	l
cli	include/types/session.h	/^		} cli;$/;"	m	union:session::__anon9	typeref:struct:session::__anon9::__anon13	access:public
cli_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:pxcounters	access:public
cli_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters	access:public
cli_addr	include/types/session.h	/^	struct sockaddr_storage cli_addr;	\/* the client address *\/$/;"	m	struct:session	typeref:struct:session::sockaddr_storage	access:public
cli_cookie	include/types/proto_http.h	/^	char *cli_cookie;               \/* cookie presented by the client, in capture mode *\/$/;"	m	struct:http_txn	access:public
client	include/types/proxy.h	/^		int client;                     \/* client I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon19	access:public
client_rcvbuf	include/types/global.h	/^		int client_rcvbuf; \/* set client rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon16	access:public
client_sndbuf	include/types/global.h	/^		int client_sndbuf; \/* set client sndbuf to this value if not null *\/$/;"	m	struct:global::__anon16	access:public
clo	include/types/fd.h	/^	void REGPRM1    (*clo)(const int fd);                \/* mark <fd> as closed *\/$/;"	m	struct:poller	access:private
clr	include/types/fd.h	/^	int  REGPRM2    (*clr)(const int fd, int dir);       \/* clear polling on <fd> for <dir> *\/$/;"	m	struct:poller	access:private
clrall	src/dumpstats.c	/^			int clrall = 0;$/;"	l
cmp_bits	ebtree/ebtree.h	/^static forceinline int cmp_bits(const unsigned char *a, const unsigned char *b, unsigned int pos)$/;"	f	signature:(const unsigned char *a, const unsigned char *b, unsigned int pos)
cmp_len	src/proto_http.c	/^				int cmp_len, value_len;$/;"	l
cnt	src/proto_http.c	/^	int cnt;$/;"	l
cnt	src/time.c	/^	int cnt=2;				\/\/ print two numbers$/;"	l
code	include/types/proxy.h	/^	int code;$/;"	m	struct:redirect_rule	access:public
code	src/cfgparse.c	/^		int code = 302;$/;"	l
col	include/types/proto_http.h	/^	unsigned int col, sov;                 \/* current header: colon, start of value *\/$/;"	m	struct:http_msg	access:public
col	src/proto_http.c	/^	char *eol, *sol, *col, *sov;$/;"	l
color	src/rbtree.c	/^	int color;$/;"	l
cond	include/common/mini-clist.h	/^	void *cond;$/;"	m	struct:cond_wordlist	access:public
cond	include/common/regex.h	/^    void *cond;				\/* a possible condition or NULL *\/$/;"	m	struct:hdr_exp	access:public
cond	include/common/uri_auth.h	/^	struct acl_cond *cond;	\/* acl condition to meet *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::acl_cond	access:public
cond	include/types/auth.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:req_acl_rule	typeref:struct:req_acl_rule::acl_cond	access:public
cond	include/types/proto_tcp.h	/^	struct acl_cond *cond;$/;"	m	struct:tcp_rule	typeref:struct:tcp_rule::acl_cond	access:public
cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::acl_cond	access:public
cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::acl_cond	access:public
cond	include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::acl_cond	access:public
cond	include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::acl_cond	access:public
cond	src/acl.c	/^	struct acl_cond *cond = NULL;$/;"	l
cond	src/acl.c	/^	struct acl_cond *cond;$/;"	l
cond	src/auth.c	/^		struct acl_cond *cond;$/;"	l
cond	src/cfgparse.c	/^	struct acl_cond *cond = NULL;$/;"	l
cond	src/haproxy.c	/^	struct acl_cond *cond, *condb;$/;"	l
cond	src/proto_http.c	/^		struct acl_cond *cond;$/;"	l
cond	src/proto_http.c	/^	struct acl_cond *cond;$/;"	l
cond	src/proto_tcp.c	/^		struct acl_cond *cond;$/;"	l
cond_c	include/types/fd.h	/^	int  REGPRM2 (*cond_c)(const int fd, int dir);       \/* clear polling on <fd> for <dir> if set *\/$/;"	m	struct:poller	access:private
cond_find_require	include/proto/acl.h	/^struct acl *cond_find_require(const struct acl_cond *cond, unsigned int require);$/;"	p	signature:(const struct acl_cond *cond, unsigned int require)
cond_find_require	src/acl.c	/^struct acl *cond_find_require(const struct acl_cond *cond, unsigned int require)$/;"	f	signature:(const struct acl_cond *cond, unsigned int require)
cond_res	src/acl.c	/^	int acl_res, suite_res, cond_res;$/;"	l
cond_s	include/types/fd.h	/^	int  REGPRM2 (*cond_s)(const int fd, int dir);       \/* set   polling on <fd> for <dir> if unset *\/$/;"	m	struct:poller	access:private
cond_wordlist	include/common/mini-clist.h	/^struct cond_wordlist {$/;"	s
cond_wordlist::cond	include/common/mini-clist.h	/^	void *cond;$/;"	m	struct:cond_wordlist	access:public
cond_wordlist::list	include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:cond_wordlist	typeref:struct:cond_wordlist::list	access:public
cond_wordlist::s	include/common/mini-clist.h	/^	char *s;$/;"	m	struct:cond_wordlist	access:public
condb	src/haproxy.c	/^	struct acl_cond *cond, *condb;$/;"	l
conf	include/types/protocols.h	/^	} conf;				\/* config information *\/$/;"	m	struct:listener	typeref:struct:listener::__anon25	access:private
conf	include/types/proxy.h	/^	} conf;					\/* config information *\/$/;"	m	struct:proxy	typeref:struct:proxy::__anon20	access:public
conf	include/types/server.h	/^	} conf;					\/* config information *\/$/;"	m	struct:server	typeref:struct:server::__anon62	access:public
confsect	src/cfgparse.c	/^	int confsect = CFG_NONE;$/;"	l
conn_err	src/backend.c	/^	int conn_err;$/;"	l
conn_err	src/session.c	/^		int conn_err;$/;"	l
conn_max	include/types/counters.h	/^	unsigned int conn_max;			\/* max # of active listener sessions *\/$/;"	m	struct:licounters	access:public
conn_retries	include/types/proxy.h	/^	int conn_retries;			\/* maximum number of connect retries *\/$/;"	m	struct:proxy	access:public
conn_retries	include/types/session.h	/^	int conn_retries;			\/* number of connect retries left *\/$/;"	m	struct:session	access:public
conn_slot	src/backend.c	/^	struct server *conn_slot;$/;"	l
connect	include/types/proxy.h	/^		int connect;                    \/* connect timeout (in ticks) *\/$/;"	m	struct:proxy::__anon19	access:public
connect	include/types/stream_interface.h	/^	int (*connect)(struct stream_interface *, struct proxy *, struct server *,$/;"	m	struct:stream_interface	access:public
connect_server	include/proto/backend.h	/^int connect_server(struct session *s);$/;"	p	signature:(struct session *s)
connect_server	src/backend.c	/^int connect_server(struct session *s)$/;"	f	signature:(struct session *s)
conns	tests/filltab25.c	/^	int conns;$/;"	l
cons	include/types/buffers.h	/^	struct stream_interface *cons;  \/* consumer attached to this buffer *\/$/;"	m	struct:buffer	typeref:struct:buffer::stream_interface	access:public
cons	include/types/pipe.h	/^	int cons;	\/* FD the consumer must read from ; -1 if none *\/$/;"	m	struct:pipe	access:public
consecutive_errors	include/types/server.h	/^	int consecutive_errors;			\/* current number of consecutive errors *\/$/;"	m	struct:server	access:public
consecutive_errors_limit	include/types/server.h	/^	int consecutive_errors_limit;		\/* number of consecutive errors that triggers an event *\/$/;"	m	struct:server	access:public
container_of	ebtree/ebtree.h	331;"	d
container_of	include/common/rbtree.h	118;"	d
contentptr	src/checks.c	/^	char *contentptr;$/;"	l
context	include/types/task.h	/^	void *context;			\/* the task's context *\/$/;"	m	struct:task	access:public
conv	include/types/pattern.h	/^	struct pattern_conv *conv;                \/* pattern conversion *\/$/;"	m	struct:pattern_conv_expr	typeref:struct:pattern_conv_expr::pattern_conv	access:public
conv	src/pattern.c	/^	struct pattern_conv *conv;$/;"	l
conv_expr	src/pattern.c	/^		struct pattern_conv_expr *conv_expr;$/;"	l
conv_expr	src/pattern.c	/^	struct pattern_conv_expr *conv_expr;$/;"	l
conv_exprs	include/types/pattern.h	/^	struct list conv_exprs;                   \/* list of conversion expression to apply *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::list	access:public
convert_date	contrib/halog/halog.c	/^int convert_date(const char *field)$/;"	f	signature:(const char *field)
convlen	src/base64.c	/^	int convlen = 0, i = 0, pad = 0;$/;"	l
convlen	src/base64.c	/^	int convlen;$/;"	l
cookie	include/types/server.h	/^	char *cookie;				\/* the id set in the cookie *\/$/;"	m	struct:server	access:public
cookie	src/cfgparse.c	/^		char *cookie = NULL;$/;"	l
cookie_domain	include/types/proxy.h	/^	char *cookie_domain;			\/* domain used to insert the cookie *\/$/;"	m	struct:proxy	access:public
cookie_first_date	include/types/proto_http.h	/^	int cookie_first_date;          \/* if non-zero, first date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn	access:public
cookie_last_date	include/types/proto_http.h	/^	int cookie_last_date;           \/* if non-zero, last date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn	access:public
cookie_len	include/types/proxy.h	/^	int  cookie_len;			\/* strlen(cookie_name), computed only once *\/$/;"	m	struct:proxy	access:public
cookie_len	include/types/proxy.h	/^	int cookie_len;$/;"	m	struct:redirect_rule	access:public
cookie_maxidle	include/types/proxy.h	/^	unsigned int cookie_maxidle;		\/* max idle time for this cookie *\/$/;"	m	struct:proxy	access:public
cookie_maxlife	include/types/proxy.h	/^	unsigned int cookie_maxlife;		\/* max life time for this cookie *\/$/;"	m	struct:proxy	access:public
cookie_name	include/types/proxy.h	/^	char *cookie_name;			\/* name of the cookie to look for *\/$/;"	m	struct:proxy	access:public
cookie_set	src/cfgparse.c	/^		int cookie_set = 0;$/;"	l
cookie_str	include/types/proxy.h	/^	char *cookie_str;$/;"	m	struct:redirect_rule	access:public
count	contrib/halog/halog.c	/^	unsigned int count;$/;"	m	struct:timer	file:	access:public
count	include/types/signal.h	/^	int count;  \/* number of times raised *\/$/;"	m	struct:signal_descriptor	access:public
count	src/ev_epoll.c	/^	int count;$/;"	l
count	src/ev_kqueue.c	/^	int count, fd, delta_ms;$/;"	l
count	src/ev_poll.c	/^	int fds, count;$/;"	l
count	src/ev_select.c	/^	char count;$/;"	l
count	src/ev_sepoll.c	/^	int count;$/;"	l
count	tests/test_pools.c	/^	unsigned count;$/;"	l
count_hash_results	tests/ip-hash.c	/^void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {$/;"	f	signature:(unsigned long hash, int counts[NSERV][NSERV])
count_hash_results	tests/uri_hash.c	/^void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {$/;"	f	signature:(unsigned long hash, int counts[NSERV][NSERV])
counters	include/types/protocols.h	/^	struct licounters *counters;	\/* statistics counters *\/$/;"	m	struct:listener	typeref:struct:listener::licounters	access:public
counters	include/types/proxy.h	/^	struct pxcounters counters;		\/* statistics counters *\/$/;"	m	struct:proxy	typeref:struct:proxy::pxcounters	access:public
counters	include/types/server.h	/^	struct srvcounters counters;		\/* statistics counters *\/$/;"	m	struct:server	typeref:struct:server::srvcounters	access:public
counts_SuperFastHash	tests/uri_hash.c	/^	count_hash_results(SuperFastHash(line, strlen(line)), counts_SuperFastHash);$/;"	l
counts_SuperFastHash	tests/uri_hash.c	/^int counts_SuperFastHash[NSERV][NSERV];$/;"	v
counts_SuperFastHash2	tests/uri_hash.c	/^	count_hash_results(SuperFastHash2(line, strlen(line)), counts_SuperFastHash2);$/;"	l
counts_SuperFastHash2	tests/uri_hash.c	/^int counts_SuperFastHash2[NSERV][NSERV];$/;"	v
counts_bj6	tests/ip-hash.c	/^		count_hash_results(hash_bj6(address & mask), counts_bj6);  \/\/ 1.07s \/ 100M$/;"	l
counts_bj6	tests/ip-hash.c	/^int counts_bj6[NSERV][NSERV];$/;"	v
counts_bj6x	tests/ip-hash.c	/^int counts_bj6x[NSERV][NSERV];$/;"	v
counts_bj7	tests/ip-hash.c	/^		count_hash_results(hash_bj7(address & mask), counts_bj7);  \/\/ 1.20s \/ 100M$/;"	l
counts_bj7	tests/ip-hash.c	/^int counts_bj7[NSERV][NSERV];$/;"	v
counts_bj7x	tests/ip-hash.c	/^int counts_bj7x[NSERV][NSERV];$/;"	v
counts_gd1	tests/uri_hash.c	/^	count_hash_results(hash_gd1(line), counts_gd1);$/;"	l
counts_gd1	tests/uri_hash.c	/^int counts_gd1[NSERV][NSERV];$/;"	v
counts_gd2	tests/uri_hash.c	/^	count_hash_results(hash_gd2(line), counts_gd2);$/;"	l
counts_gd2	tests/uri_hash.c	/^int counts_gd2[NSERV][NSERV];$/;"	v
counts_gd3	tests/uri_hash.c	/^	count_hash_results(hash_gd3(line), counts_gd3);$/;"	l
counts_gd3	tests/uri_hash.c	/^int counts_gd3[NSERV][NSERV];$/;"	v
counts_gd4	tests/uri_hash.c	/^	count_hash_results(hash_gd4(line), counts_gd4);$/;"	l
counts_gd4	tests/uri_hash.c	/^int counts_gd4[NSERV][NSERV];$/;"	v
counts_gd5	tests/uri_hash.c	/^	count_hash_results(hash_gd5(line), counts_gd5);$/;"	l
counts_gd5	tests/uri_hash.c	/^int counts_gd5[NSERV][NSERV];$/;"	v
counts_gd6	tests/uri_hash.c	/^	count_hash_results(hash_gd6(line), counts_gd6);$/;"	l
counts_gd6	tests/uri_hash.c	/^int counts_gd6[NSERV][NSERV];$/;"	v
counts_id	tests/ip-hash.c	/^		count_hash_results(hash_id (address & mask), counts_id);   \/\/ 0.69s \/ 100M$/;"	l
counts_id	tests/ip-hash.c	/^int counts_id[NSERV][NSERV];$/;"	v
counts_srv	tests/uri_hash.c	/^	count_hash_results(haproxy_server_hash(line, strlen(line)), counts_srv);$/;"	l
counts_srv	tests/uri_hash.c	/^int counts_srv[NSERV][NSERV];$/;"	v
counts_tw1	tests/ip-hash.c	/^		count_hash_results(hash_tw1(address & mask), counts_tw1);  \/\/ 1.04s \/ 100M$/;"	l
counts_tw1	tests/ip-hash.c	/^int counts_tw1[NSERV][NSERV];$/;"	v
counts_tw2	tests/ip-hash.c	/^		count_hash_results(hash_tw2(address & mask), counts_tw2);  \/\/ 1.13s \/ 100M$/;"	l
counts_tw2	tests/ip-hash.c	/^int counts_tw2[NSERV][NSERV];$/;"	v
counts_tw3	tests/ip-hash.c	/^		count_hash_results(hash_tw3(address & mask), counts_tw3);  \/\/ 1.01s \/ 100M$/;"	l
counts_tw3	tests/ip-hash.c	/^int counts_tw3[NSERV][NSERV];$/;"	v
counts_wt1	tests/uri_hash.c	/^int counts_wt1[NSERV][NSERV];$/;"	v
counts_wt2	tests/uri_hash.c	/^	count_hash_results(hash_wt2(line, strlen(line)), counts_wt2);$/;"	l
counts_wt2	tests/uri_hash.c	/^int counts_wt2[NSERV][NSERV];$/;"	v
cover	ebtree/ebmbtree.h	/^	eb_troot_t *troot, *cover;$/;"	l
cp	src/pattern.c	/^	const char *cp = buf;$/;"	l
cp	src/standard.c	/^	const char *cp = addr;$/;"	l
cp	src/standard.c	/^	const char *curr = url, *cp = url;$/;"	l
cr	include/types/hdr_idx.h	/^        unsigned cr   : 1; \/* CR present (1=CRLF, 0=LF). Total line size=len+cr+1. *\/$/;"	m	struct:hdr_idx_elem	access:public
create_cond_regex_rule	src/cfgparse.c	/^static int create_cond_regex_rule(const char *file, int line,$/;"	f	file:	signature:(const char *file, int line, struct proxy *px, int dir, int action, int flags, const char *cmd, const char *reg, const char *repl, const char **cond_start)
create_pool	include/common/memory.h	/^struct pool_head *create_pool(char *name, unsigned int size, unsigned int flags);$/;"	p	signature:(char *name, unsigned int size, unsigned int flags)
create_pool	src/memory.c	/^struct pool_head *create_pool(char *name, unsigned int size, unsigned int flags)$/;"	f	signature:(char *name, unsigned int size, unsigned int flags)
create_uxst_socket	src/proto_uxst.c	/^static int create_uxst_socket(const char *path, uid_t uid, gid_t gid, mode_t mode)$/;"	f	file:	signature:(const char *path, uid_t uid, gid_t gid, mode_t mode)
crlf	src/checks.c	/^	int crlf;$/;"	l
cto	include/types/buffers.h	/^	int cto;                        \/* connect timeout, in ticks *\/$/;"	m	struct:buffer	access:public
ctx	include/types/acl.h	/^	} ctx;$/;"	m	struct:acl_test	typeref:union:acl_test::__anon53	access:public
ctx	src/backend.c	/^	struct hdr_ctx   ctx;$/;"	l
ctx	src/proto_http.c	/^			struct hdr_ctx ctx;$/;"	l
ctx	src/proto_http.c	/^	struct hdr_ctx *ctx = (struct hdr_ctx *)test->ctx.a;$/;"	l
ctx	src/proto_http.c	/^	struct hdr_ctx ctx;$/;"	l
ctx	tests/test_pools.c	/^	void *ctx = pool_alloc(talloc);$/;"	l
cum	contrib/halog/halog.c	/^		unsigned long cum[5];$/;"	l
cum_beconn	include/types/counters.h	/^	long long cum_feconn, cum_beconn;	\/* cumulated number of processed sessions *\/$/;"	m	struct:pxcounters	access:public
cum_conn	include/types/counters.h	/^	long long cum_conn;			\/* cumulated number of processed sessions *\/$/;"	m	struct:licounters	access:public
cum_ct	contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:	access:public
cum_fe_req	include/types/counters.h	/^	long long cum_fe_req;			\/* cumulated number of processed HTTP requests *\/$/;"	m	struct:pxcounters	access:public
cum_feconn	include/types/counters.h	/^	long long cum_feconn, cum_beconn;	\/* cumulated number of processed sessions *\/$/;"	m	struct:pxcounters	access:public
cum_lbconn	include/types/counters.h	/^	long long cum_lbconn;			\/* cumulated number of sessions directed by load balancing *\/$/;"	m	struct:srvcounters	access:public
cum_lbconn	include/types/counters.h	/^	long long cum_lbconn;			\/* cumulated number of sessions processed by load balancing *\/$/;"	m	struct:pxcounters	access:public
cum_rt	contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:	access:public
cum_sess	include/types/counters.h	/^	long long cum_sess;			\/* cumulated number of sessions really sent to this server *\/$/;"	m	struct:srvcounters	access:public
cur	src/haproxy.c	/^		struct proxy *cur;$/;"	l
cur	src/lb_map.c	/^	struct server *cur, *best;$/;"	l
cur_acl	src/acl.c	/^	struct acl *cur_acl;$/;"	l
cur_arg	src/auth.c	/^	int cur_arg;$/;"	l
cur_arg	src/cfgparse.c	/^				int cur_arg = 2;$/;"	l
cur_arg	src/cfgparse.c	/^			int cur_arg;$/;"	l
cur_arg	src/cfgparse.c	/^		int cur_arg = 1;$/;"	l
cur_arg	src/cfgparse.c	/^		int cur_arg, i;$/;"	l
cur_arg	src/cfgparse.c	/^		int cur_arg;$/;"	l
cur_arg	src/dumpstats.c	/^		int cur_arg;$/;"	l
cur_end	src/proto_http.c	/^	char *cur_end;$/;"	l
cur_end	src/proto_http.c	/^	char *cur_ptr, *cur_end, *cur_next;$/;"	l
cur_end	src/proto_http.c	/^	char *cur_ptr, *cur_end;$/;"	l
cur_hdr	src/proto_http.c	/^		struct hdr_idx_elem *cur_hdr;$/;"	l
cur_hdr	src/proto_http.c	/^	struct hdr_idx_elem *cur_hdr;$/;"	l
cur_idx	src/proto_http.c	/^	int cur_idx = ctx->idx;$/;"	l
cur_idx	src/proto_http.c	/^	int cur_idx, old_idx, delta;$/;"	l
cur_idx	src/proto_http.c	/^	int cur_idx, old_idx, last_hdr;$/;"	l
cur_idx	src/proto_http.c	/^	int cur_idx, old_idx;$/;"	l
cur_idx	src/proto_http.c	/^	int cur_idx;$/;"	l
cur_next	src/proto_http.c	/^	char *cur_ptr, *cur_end, *cur_next;$/;"	l
cur_param	src/proto_http.c	/^	char *end_params, *first_param, *cur_param, *next_param;$/;"	l
cur_param	src/proto_http.c	/^	char *first_param, *cur_param, *next_param, *end_params;$/;"	l
cur_poller	include/types/fd.h	/^extern struct poller cur_poller; \/* the current poller *\/$/;"	x
cur_poller	src/fd.c	/^struct poller cur_poller;$/;"	v	typeref:struct:poller
cur_pos	src/signal.c	/^	int sig, cur_pos = 0;$/;"	l
cur_proxy	src/proto_http.c	/^	struct proxy *cur_proxy;$/;"	l
cur_ptr	src/proto_http.c	/^	char *cur_ptr, *cur_end, *cur_next;$/;"	l
cur_ptr	src/proto_http.c	/^	char *cur_ptr, *cur_end;$/;"	l
cur_read	src/stream_sock.c	/^	int ret, max, retval, cur_read;$/;"	l
cur_sess	include/types/server.h	/^	int cur_sess;				\/* number of currently active sessions (including syn_sent) *\/$/;"	m	struct:server	access:public
cur_sess_max	include/types/counters.h	/^	unsigned int cur_sess_max;		\/* max number of currently active sessions *\/$/;"	m	struct:srvcounters	access:public
cur_suite	src/acl.c	/^	struct acl_term_suite *cur_suite;$/;"	l
cur_term	src/acl.c	/^	struct acl_term *cur_term;$/;"	l
curfd	include/types/server.h	/^	int curfd;				\/* file desc used for current test, or -1 if not in test *\/$/;"	m	struct:server	access:public
curproxy	src/cfgparse.c	/^	static struct proxy *curproxy = NULL;$/;"	l	file:
curproxy	src/cfgparse.c	/^	struct proxy *curproxy = NULL;$/;"	l
curproxy	src/proxy.c	/^	struct proxy *curproxy, *target = NULL;$/;"	l
curproxy	src/proxy.c	/^	struct proxy *curproxy;$/;"	l
curr	include/types/lb_fwrr.h	/^	struct eb_root curr;    \/* tree for servers in "current" time range *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root	access:public
curr	src/freq_ctr.c	/^	unsigned int curr, past;$/;"	l
curr	src/standard.c	/^	const char *curr = url, *cp = url;$/;"	l
curr_ctr	include/types/freq_ctr.h	/^	unsigned int curr_ctr; \/* cumulated value for current period *\/$/;"	m	struct:freq_ctr	access:public
curr_pos	include/types/lb_fwrr.h	/^	int curr_pos;           \/* current position in the tree *\/$/;"	m	struct:fwrr_group	access:public
curr_sec	include/types/freq_ctr.h	/^	unsigned int curr_sec; \/* start date of current period (seconds from now.tv_sec) *\/$/;"	m	struct:freq_ctr	access:public
curr_sec_ms	include/common/time.h	/^extern unsigned int   curr_sec_ms;      \/* millisecond of current second (0..999) *\/$/;"	x
curr_sec_ms	src/time.c	/^unsigned int   curr_sec_ms;      \/* millisecond of current second (0..999) *\/$/;"	v
curr_sec_ms_scaled	include/common/time.h	/^extern unsigned int   curr_sec_ms_scaled;  \/* millisecond of current second (0..2^32-1) *\/$/;"	x
curr_sec_ms_scaled	src/time.c	/^unsigned int   curr_sec_ms_scaled;  \/* millisecond of current second (0..2^32-1) *\/$/;"	v
curr_sess	src/dumpstats.c	/^			struct session *curr_sess;$/;"	l
curr_weight	include/types/lb_fwrr.h	/^	int curr_weight;        \/* total weight of the current time range *\/$/;"	m	struct:fwrr_group	access:public
current	include/types/stick_table.h	/^	unsigned int current;     \/* number of stuck session in table *\/$/;"	m	struct:stktable	access:public
cursection	src/cfgparse.c	/^static char *cursection = NULL;$/;"	v	file:
cursrv	src/proxy.c	/^	struct server *cursrv, *target = NULL;$/;"	l
curuser	src/cfgparse.c	/^		struct auth_users *curuser;$/;"	l
curuserlist	src/cfgparse.c	/^	struct userlist *curuserlist = NULL;$/;"	l
cut_crlf	include/common/standard.h	/^static inline char *cut_crlf(char *s) {$/;"	f	signature:(char *s)
cwl	src/haproxy.c	/^	struct cond_wordlist *cwl, *cwlb;$/;"	l
cwlb	src/haproxy.c	/^	struct cond_wordlist *cwl, *cwlb;$/;"	l
d	contrib/halog/halog.c	/^				double d;$/;"	l
d	contrib/halog/halog.c	/^			unsigned int d, h, m, s, ms;$/;"	l
d	ebtree/ebtree.h	/^		unsigned char d;$/;"	l
d	include/types/acl.h	/^		double d;       \/* any float or double *\/$/;"	m	union:acl_test::__anon53	access:public
d	src/cfgparse.c	/^				char *d;$/;"	l
d	src/cfgparse.c	/^		char *d;$/;"	l
d	src/standard.c	/^	const char *p, *d;$/;"	l
d	tests/sessionhash_test.c	/^	appsess *a, *b, *c, *d, *tmp;$/;"	l
data	include/common/epoll.h	/^	} data;$/;"	m	struct:epoll_event	typeref:union:epoll_event::__anon65	access:public
data	include/types/buffers.h	/^	char data[0];                   \/* <size> bytes *\/$/;"	m	struct:buffer	access:public
data	include/types/pattern.h	/^	union pattern_data data;  \/* data *\/$/;"	m	struct:pattern	typeref:union:pattern::pattern_data	access:public
data	include/types/pipe.h	/^	int data;	\/* number of bytes present in the pipe  *\/$/;"	m	struct:pipe	access:public
data	include/types/stick_table.h	/^	union stktable_key_data data;   \/* data *\/$/;"	m	struct:stktable_key	typeref:union:stktable_key::stktable_key_data	access:public
data	src/proto_tcp.c	/^	const unsigned char *data;$/;"	l
data	tests/uri_hash.c	/^    unsigned long data, val;$/;"	l
data_ctx	include/types/session.h	/^	} data_ctx;				\/* used by stats I\/O handlers to dump the stats *\/$/;"	m	struct:session	typeref:union:session::__anon9	access:public
data_left	include/proto/buffers.h	/^	unsigned long data_left;$/;"	l
data_len	src/log.c	/^	int hdr_len, data_len;$/;"	l
data_source	include/types/session.h	/^	short int data_source;			\/* where to get the data we generate ourselves *\/$/;"	m	struct:session	access:public
data_state	include/types/session.h	/^	short int data_state;			\/* where to get the data we generate ourselves *\/$/;"	m	struct:session	access:public
dataptr	src/log.c	/^	static char *dataptr = NULL;$/;"	l	file:
date	include/common/time.h	/^extern struct timeval date;             \/* the real current date *\/$/;"	x
date	src/time.c	/^struct timeval date;            \/* the real current date *\/$/;"	v	typeref:struct:timeval
deadline	src/time.c	/^	struct timeval adjusted, deadline;$/;"	l
debug_hdr	include/proto/proto_http.h	/^void debug_hdr(const char *dir, struct session *t, const char *start, const char *end);$/;"	p	signature:(const char *dir, struct session *t, const char *start, const char *end)
debug_hdr	src/proto_http.c	/^void debug_hdr(const char *dir, struct session *t, const char *start, const char *end)$/;"	f	signature:(const char *dir, struct session *t, const char *start, const char *end)
default_acl_list	src/acl.c	/^} default_acl_list[] = {$/;"	v	typeref:struct:__anon66
default_size	include/types/stick_table.h	/^	size_t default_size;  \/* default key size *\/$/;"	m	struct:stktable_type	access:public
default_srv_error	include/proto/session.h	/^void default_srv_error(struct session *s, struct stream_interface *si);$/;"	p	signature:(struct session *s, struct stream_interface *si)
default_srv_error	src/session.c	/^void default_srv_error(struct session *s, struct stream_interface *si)$/;"	f	signature:(struct session *s, struct stream_interface *si)
defbe	include/types/proxy.h	/^	} defbe;$/;"	m	struct:proxy	typeref:union:proxy::__anon17	access:public
defproxy	src/cfgparse.c	/^static struct proxy defproxy;		\/* fake proxy used to assign default values on all instances *\/$/;"	v	typeref:struct:proxy	file:
defsrv	include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
defsrv	src/cfgparse.c	/^		int do_check = 0, defsrv = (*args[0] == 'd');$/;"	l
deinit	src/haproxy.c	/^void deinit(void)$/;"	f	signature:(void)
deinit_pollers	include/proto/fd.h	/^void deinit_pollers();$/;"	p	signature:()
deinit_pollers	src/fd.c	/^void deinit_pollers() {$/;"	f
del	include/types/proto_http.h	/^	int  del;  \/* relative to line *\/$/;"	m	struct:hdr_ctx	access:public
del_cl	src/proto_http.c	/^	int del_ka, del_cl, do_stats;$/;"	l
del_from	src/proto_http.c	/^	char *hdr_beg, *hdr_end, *hdr_next, *del_from;$/;"	l
del_hdr_value	src/proto_http.c	/^int del_hdr_value(struct buffer *buf, char **from, char *next)$/;"	f	signature:(struct buffer *buf, char **from, char *next)
del_ka	src/proto_http.c	/^	int del_ka, del_cl, do_stats;$/;"	l
delete_listener	include/proto/protocols.h	/^void delete_listener(struct listener *listener);$/;"	p	signature:(struct listener *listener)
delete_listener	src/protocols.c	/^void delete_listener(struct listener *listener)$/;"	f	signature:(struct listener *listener)
delete_unlink	ebtree/ebtree.h	/^	__label__ delete_unlink;$/;"	l
delim	src/proto_http.c	/^				char *delim;$/;"	l
delta	src/buffers.c	/^	int delta;$/;"	l
delta	src/ev_select.c	/^	struct timeval delta;$/;"	l
delta	src/proto_http.c	/^						int delta = del_hdr_value(res, &prev, next);$/;"	l
delta	src/proto_http.c	/^					int delta = del_hdr_value(req, &del_from, prev);$/;"	l
delta	src/proto_http.c	/^					int delta; \/* negative *\/$/;"	l
delta	src/proto_http.c	/^			int delta;$/;"	l
delta	src/proto_http.c	/^	int cur_idx, old_idx, delta;$/;"	l
delta	src/proto_http.c	/^	int delta, skip_comma;$/;"	l
delta	src/proto_http.c	/^	int delta;$/;"	l
delta	src/proto_http.c	/^	int len, delta;$/;"	l
delta_ms	src/ev_kqueue.c	/^	int count, fd, delta_ms;$/;"	l
delta_ms	src/ev_select.c	/^	int delta_ms;$/;"	l
denied_req	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters	access:public
denied_req	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters	access:public
denied_resp	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters	access:public
denied_resp	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters	access:public
dequeue_srv	tests/filltab25.c	/^static inline void dequeue_srv(struct srv *s) {$/;"	f	file:	signature:(struct srv *s)
desc	include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth	access:public
desc	include/types/checks.h	/^	char *desc;				\/* description *\/$/;"	m	struct:analyze_status	access:public
desc	include/types/checks.h	/^	char *desc;			\/* long description *\/$/;"	m	struct:check_status	access:public
desc	include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global	access:public
desc	include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy	access:public
desc	src/cfgparse.c	/^			char *desc = NULL;$/;"	l
desc	src/checks.c	/^	char *desc;$/;"	l
desc	src/checks.c	/^	const char *desc;$/;"	l
desc	src/signal.c	/^	struct signal_descriptor *desc;$/;"	l
desc_copy	src/uri_auth.c	/^	char *desc_copy = NULL;$/;"	l
destination	src/cfgparse.c	/^		char *destination = NULL;$/;"	l
destroy	include/common/appsession.h	/^void destroy(appsess *data);$/;"	p	signature:(appsess *data)
destroy	include/common/sessionhash.h	/^	void (*destroy)(appsess *);$/;"	m	struct:appsession_hash	access:public
destroy	src/appsession.c	/^					htbl->destroy(element);$/;"	p	file:
destroy	src/appsession.c	/^void destroy(appsess *temp1) {$/;"	f	signature:(appsess *temp1)
destroy	src/proto_http.c	/^				t->be->htbl_proxy.destroy(asession);$/;"	p	file:
destroy	src/sessionhash.c	/^			hash->destroy(item);$/;"	p	file:
destroy_uxst_socket	src/proto_uxst.c	/^static void destroy_uxst_socket(const char *path)$/;"	f	file:	signature:(const char *path)
die	contrib/halog/halog.c	/^void die(const char *msg)$/;"	f	signature:(const char *msg)
diff	ebtree/ebimtree.h	/^	int diff;$/;"	l
diff	ebtree/ebistree.h	/^	int diff;$/;"	l
diff	ebtree/ebmbtree.h	/^	int diff;$/;"	l
diff	ebtree/ebsttree.h	/^	int diff;$/;"	l
dig1	src/standard.c	/^	register unsigned int dig100, dig10, dig1;$/;"	l
dig10	src/standard.c	/^	register unsigned int dig100, dig10, dig1;$/;"	l
dig100	src/standard.c	/^	register unsigned int dig100, dig10, dig1;$/;"	l
digit	src/pattern.c	/^		unsigned char digit = (ch = *addr) - '0';$/;"	l
digit	src/standard.c	/^		unsigned char digit = (ch = *addr++) - '0';$/;"	l
digit	src/standard.c	/^	int digit = 0;$/;"	l
dir	include/types/pattern.h	/^	int dir;                                  \/* usable directions *\/$/;"	m	struct:pattern_fetch	access:public
dir2filt	src/ev_kqueue.c	/^static const int dir2filt[2] = { EVFILT_READ, EVFILT_WRITE };$/;"	v	file:
disable_all	include/types/protocols.h	/^	int (*disable_all)(struct protocol *proto);	\/* disable all bound listeners *\/$/;"	m	struct:protocol	access:public
disable_all_listeners	include/proto/protocols.h	/^int disable_all_listeners(struct protocol *proto);$/;"	p	signature:(struct protocol *proto)
disable_all_listeners	src/protocols.c	/^int disable_all_listeners(struct protocol *proto)$/;"	f	signature:(struct protocol *proto)
disable_listener	include/proto/protocols.h	/^void disable_listener(struct listener *listener);$/;"	p	signature:(struct listener *listener)
disable_listener	src/protocols.c	/^		disable_listener(listener);$/;"	p	file:
disable_listener	src/protocols.c	/^void disable_listener(struct listener *listener)$/;"	f	signature:(struct listener *listener)
disable_poller	include/proto/fd.h	/^void disable_poller(const char *poller_name);$/;"	p	signature:(const char *poller_name)
disable_poller	src/fd.c	/^void disable_poller(const char *poller_name)$/;"	f	signature:(const char *poller_name)
dispatch_addr	include/types/proxy.h	/^	struct sockaddr_in dispatch_addr;	\/* the default address to connect to *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_in	access:public
display_build_opts	src/haproxy.c	/^void display_build_opts()$/;"	f
display_version	src/haproxy.c	/^void display_version()$/;"	f
dmsk	src/ev_epoll.c	/^	uint32_t dmsk = DIR2MSK(dir);$/;"	l
dmsk2event	src/ev_epoll.c	/^static int dmsk2event[4] = { 0, EPOLLIN, EPOLLOUT, EPOLLIN | EPOLLOUT };$/;"	v	file:
dn	src/lb_chash.c	/^	unsigned int dn, dp;$/;"	l
do_check	src/cfgparse.c	/^		int do_check = 0, defsrv = (*args[0] == 'd');$/;"	l
do_log	include/types/session.h	/^	void (*do_log)(struct session *s);	\/* the function to call in order to log (or NULL) *\/$/;"	m	struct:session	access:public
do_log	src/client.c	/^						s->do_log(s);$/;"	p	file:
do_log	src/proto_http.c	/^				s->do_log(s);$/;"	p	file:
do_log	src/proto_http.c	/^			t->do_log(t);$/;"	p	file:
do_log	src/proto_http.c	/^		s->do_log(s);$/;"	p	file:
do_log	src/session.c	/^			s->do_log(s);$/;"	p	file:
do_log	src/session.c	/^		s->do_log(s);$/;"	p	file:
do_stats	src/proto_http.c	/^	int del_ka, del_cl, do_stats;$/;"	l
dohash	src/backend.c	/^		int dohash = 0;$/;"	l
done	src/checks.c	/^	int done;$/;"	l
done	src/ev_sepoll.c	/^		int done;$/;"	l
done	src/proto_http.c	/^	int done;$/;"	l
dow	include/types/acl.h	/^	int dow:7;              \/* 1 bit per day of week: 0-6 *\/$/;"	m	struct:acl_time	access:public
down_time	include/types/proxy.h	/^	unsigned down_time;			\/* total time the proxy was down *\/$/;"	m	struct:proxy	access:public
down_time	include/types/server.h	/^	unsigned down_time;			\/* total time the server was down *\/$/;"	m	struct:server	access:public
down_trans	include/types/counters.h	/^	long long down_trans;			\/* up->down transitions *\/$/;"	m	struct:srvcounters	access:public
down_trans	include/types/proxy.h	/^	unsigned down_trans;			\/* up-down transitions *\/$/;"	m	struct:proxy	access:public
downinter	include/types/server.h	/^	int inter, fastinter, downinter;	\/* checks: time in milliseconds *\/$/;"	m	struct:server	access:public
dp	src/lb_chash.c	/^	unsigned int dn, dp;$/;"	l
dump	src/haproxy.c	/^void dump(int sig)$/;"	f	signature:(int sig)
dump_hash_results	tests/ip-hash.c	/^void dump_hash_results(char *name, int counts[NSERV][NSERV]) {$/;"	f	signature:(char *name, int counts[NSERV][NSERV])
dump_hash_results	tests/uri_hash.c	/^void dump_hash_results(char *name, int counts[NSERV][NSERV]) {$/;"	f	signature:(char *name, int counts[NSERV][NSERV])
dump_pools	include/common/memory.h	/^void dump_pools(void);$/;"	p	signature:(void)
dump_pools	src/memory.c	/^void dump_pools(void)$/;"	f	signature:(void)
dump_text_line	src/dumpstats.c	/^static int dump_text_line(struct chunk *out, const char *buf, int bsize, int len,$/;"	f	file:	signature:(struct chunk *out, const char *buf, int bsize, int len, int *line, int ptr)
dupstr	src/cfgparse.c	/^	char *c, *next, *range, *dupstr;$/;"	l
e	contrib/halog/halog.c	/^	const char *b, *e, *p;$/;"	l
e	contrib/halog/halog.c	/^	const char *b, *e;$/;"	l
e	include/proto/hdr_idx.h	/^		register struct hdr_idx_elem e = { .len=0, .cr=0, .next=0};$/;"	l
e	include/types/fd.h	/^		unsigned char e;             \/* read and write events status. 4 bits, may be merged into flags' lower bits *\/$/;"	m	struct:fdtab::__anon57	access:public
e	src/ev_sepoll.c	/^		int e = epoll_events[count].events;$/;"	l
e	src/hdr_idx.c	/^	register struct hdr_idx_elem e = { .len=0, .cr=0, .next=0};$/;"	l
eb	src/stick_table.c	/^	struct eb32_node *eb;$/;"	l
eb	src/stick_table.c	/^	struct ebmb_node *eb;$/;"	l
eb	src/task.c	/^	struct eb32_node *eb;$/;"	l
eb32_delete	ebtree/eb32tree.h	/^static inline void eb32_delete(struct eb32_node *eb32)$/;"	f	signature:(struct eb32_node *eb32)
eb32_entry	ebtree/eb32tree.h	28;"	d
eb32_first	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_first(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
eb32_insert	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_insert(struct eb_root *root, struct eb32_node *new)$/;"	f	signature:(struct eb_root *root, struct eb32_node *new)
eb32_insert	ebtree/eb32tree.h	/^REGPRM2 struct eb32_node *eb32_insert(struct eb_root *root, struct eb32_node *new);$/;"	p	signature:(struct eb_root *root, struct eb32_node *new)
eb32_last	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_last(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
eb32_lookup	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup(struct eb_root *root, u32 x)$/;"	f	signature:(struct eb_root *root, u32 x)
eb32_lookup	ebtree/eb32tree.h	/^REGPRM2 struct eb32_node *eb32_lookup(struct eb_root *root, u32 x);$/;"	p	signature:(struct eb_root *root, u32 x)
eb32_lookup_ge	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup_ge(struct eb_root *root, u32 x)$/;"	f	signature:(struct eb_root *root, u32 x)
eb32_lookup_ge	ebtree/eb32tree.h	/^REGPRM2 struct eb32_node *eb32_lookup_ge(struct eb_root *root, u32 x);$/;"	p	signature:(struct eb_root *root, u32 x)
eb32_lookup_le	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup_le(struct eb_root *root, u32 x)$/;"	f	signature:(struct eb_root *root, u32 x)
eb32_lookup_le	ebtree/eb32tree.h	/^REGPRM2 struct eb32_node *eb32_lookup_le(struct eb_root *root, u32 x);$/;"	p	signature:(struct eb_root *root, u32 x)
eb32_next	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next(struct eb32_node *eb32)$/;"	f	signature:(struct eb32_node *eb32)
eb32_next_unique	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next_unique(struct eb32_node *eb32)$/;"	f	signature:(struct eb32_node *eb32)
eb32_node	ebtree/eb32tree.h	/^struct eb32_node {$/;"	s
eb32_node::key	ebtree/eb32tree.h	/^	u32 key;$/;"	m	struct:eb32_node	access:public
eb32_node::node	ebtree/eb32tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb32_node	typeref:struct:eb32_node::eb_node	access:public
eb32_prev	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev(struct eb32_node *eb32)$/;"	f	signature:(struct eb32_node *eb32)
eb32_prev_unique	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev_unique(struct eb32_node *eb32)$/;"	f	signature:(struct eb32_node *eb32)
eb32i_insert	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32i_insert(struct eb_root *root, struct eb32_node *new)$/;"	f	signature:(struct eb_root *root, struct eb32_node *new)
eb32i_insert	ebtree/eb32tree.h	/^REGPRM2 struct eb32_node *eb32i_insert(struct eb_root *root, struct eb32_node *new);$/;"	p	signature:(struct eb_root *root, struct eb32_node *new)
eb32i_lookup	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32i_lookup(struct eb_root *root, s32 x)$/;"	f	signature:(struct eb_root *root, s32 x)
eb32i_lookup	ebtree/eb32tree.h	/^REGPRM2 struct eb32_node *eb32i_lookup(struct eb_root *root, s32 x);$/;"	p	signature:(struct eb_root *root, s32 x)
eb64_delete	ebtree/eb64tree.h	/^static inline void eb64_delete(struct eb64_node *eb64)$/;"	f	signature:(struct eb64_node *eb64)
eb64_entry	ebtree/eb64tree.h	28;"	d
eb64_first	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_first(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
eb64_insert	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_insert(struct eb_root *root, struct eb64_node *new)$/;"	f	signature:(struct eb_root *root, struct eb64_node *new)
eb64_insert	ebtree/eb64tree.h	/^REGPRM2 struct eb64_node *eb64_insert(struct eb_root *root, struct eb64_node *new);$/;"	p	signature:(struct eb_root *root, struct eb64_node *new)
eb64_last	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_last(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
eb64_lookup	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup(struct eb_root *root, u64 x)$/;"	f	signature:(struct eb_root *root, u64 x)
eb64_lookup	ebtree/eb64tree.h	/^REGPRM2 struct eb64_node *eb64_lookup(struct eb_root *root, u64 x);$/;"	p	signature:(struct eb_root *root, u64 x)
eb64_lookup_ge	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup_ge(struct eb_root *root, u64 x)$/;"	f	signature:(struct eb_root *root, u64 x)
eb64_lookup_ge	ebtree/eb64tree.h	/^REGPRM2 struct eb64_node *eb64_lookup_ge(struct eb_root *root, u64 x);$/;"	p	signature:(struct eb_root *root, u64 x)
eb64_lookup_le	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup_le(struct eb_root *root, u64 x)$/;"	f	signature:(struct eb_root *root, u64 x)
eb64_lookup_le	ebtree/eb64tree.h	/^REGPRM2 struct eb64_node *eb64_lookup_le(struct eb_root *root, u64 x);$/;"	p	signature:(struct eb_root *root, u64 x)
eb64_next	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next(struct eb64_node *eb64)$/;"	f	signature:(struct eb64_node *eb64)
eb64_next_unique	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next_unique(struct eb64_node *eb64)$/;"	f	signature:(struct eb64_node *eb64)
eb64_node	ebtree/eb64tree.h	/^struct eb64_node {$/;"	s
eb64_node::key	ebtree/eb64tree.h	/^	u64 key;$/;"	m	struct:eb64_node	access:public
eb64_node::node	ebtree/eb64tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb64_node	typeref:struct:eb64_node::eb_node	access:public
eb64_prev	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev(struct eb64_node *eb64)$/;"	f	signature:(struct eb64_node *eb64)
eb64_prev_unique	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev_unique(struct eb64_node *eb64)$/;"	f	signature:(struct eb64_node *eb64)
eb64i_insert	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64i_insert(struct eb_root *root, struct eb64_node *new)$/;"	f	signature:(struct eb_root *root, struct eb64_node *new)
eb64i_insert	ebtree/eb64tree.h	/^REGPRM2 struct eb64_node *eb64i_insert(struct eb_root *root, struct eb64_node *new);$/;"	p	signature:(struct eb_root *root, struct eb64_node *new)
eb64i_lookup	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64i_lookup(struct eb_root *root, s64 x)$/;"	f	signature:(struct eb_root *root, s64 x)
eb64i_lookup	ebtree/eb64tree.h	/^REGPRM2 struct eb64_node *eb64i_lookup(struct eb_root *root, s64 x);$/;"	p	signature:(struct eb_root *root, s64 x)
eb_clrtag	ebtree/ebtree.h	/^static inline struct eb_root *eb_clrtag(const eb_troot_t *troot)$/;"	f	signature:(const eb_troot_t *troot)
eb_delete	ebtree/ebtree.c	/^void eb_delete(struct eb_node *node)$/;"	f	signature:(struct eb_node *node)
eb_delete	ebtree/ebtree.h	/^void eb_delete(struct eb_node *node);$/;"	p	signature:(struct eb_node *node)
eb_dotag	ebtree/ebtree.h	/^static inline eb_troot_t *eb_dotag(const struct eb_root *root, const int tag)$/;"	f	signature:(const struct eb_root *root, const int tag)
eb_entry	ebtree/ebtree.h	383;"	d
eb_first	ebtree/ebtree.h	/^static inline struct eb_node *eb_first(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
eb_gettag	ebtree/ebtree.h	/^static inline int eb_gettag(eb_troot_t *troot)$/;"	f	signature:(eb_troot_t *troot)
eb_insert_dup	ebtree/ebtree.c	/^REGPRM1 struct eb_node *eb_insert_dup(struct eb_node *sub, struct eb_node *new)$/;"	f	signature:(struct eb_node *sub, struct eb_node *new)
eb_insert_dup	ebtree/ebtree.h	/^REGPRM1 struct eb_node *eb_insert_dup(struct eb_node *sub, struct eb_node *new);$/;"	p	signature:(struct eb_node *sub, struct eb_node *new)
eb_is_empty	ebtree/ebtree.h	/^static inline int eb_is_empty(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
eb_last	ebtree/ebtree.h	/^static inline struct eb_node *eb_last(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
eb_next	ebtree/ebtree.h	/^static inline struct eb_node *eb_next(struct eb_node *node)$/;"	f	signature:(struct eb_node *node)
eb_next_unique	ebtree/ebtree.h	/^static inline struct eb_node *eb_next_unique(struct eb_node *node)$/;"	f	signature:(struct eb_node *node)
eb_node	ebtree/ebtree.h	/^struct eb_node {$/;"	s
eb_node::bit	ebtree/ebtree.h	/^	short int      bit;     \/* link's bit position. *\/$/;"	m	struct:eb_node	access:public
eb_node::branches	ebtree/ebtree.h	/^	struct eb_root branches; \/* branches, must be at the beginning *\/$/;"	m	struct:eb_node	typeref:struct:eb_node::eb_root	access:public
eb_node::leaf_p	ebtree/ebtree.h	/^	eb_troot_t    *leaf_p;  \/* leaf node's parent *\/$/;"	m	struct:eb_node	access:public
eb_node::node_p	ebtree/ebtree.h	/^	eb_troot_t    *node_p;  \/* link node's parent *\/$/;"	m	struct:eb_node	access:public
eb_node::pfx	ebtree/ebtree.h	/^	short int      pfx;     \/* data prefix length, always related to leaf *\/$/;"	m	struct:eb_node	access:public
eb_prev	ebtree/ebtree.h	/^static inline struct eb_node *eb_prev(struct eb_node *node)$/;"	f	signature:(struct eb_node *node)
eb_prev_unique	ebtree/ebtree.h	/^static inline struct eb_node *eb_prev_unique(struct eb_node *node)$/;"	f	signature:(struct eb_node *node)
eb_root	ebtree/ebtree.h	/^struct eb_root {$/;"	s
eb_root::b	ebtree/ebtree.h	/^	eb_troot_t    *b[EB_NODE_BRANCHES]; \/* left and right branches *\/$/;"	m	struct:eb_root	access:public
eb_root_to_node	ebtree/ebtree.h	/^static inline struct eb_node *eb_root_to_node(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
eb_troot_t	ebtree/ebtree.h	/^typedef void eb_troot_t;$/;"	t
eb_untag	ebtree/ebtree.h	/^static inline struct eb_root *eb_untag(const eb_troot_t *troot, const int tag)$/;"	f	signature:(const eb_troot_t *troot, const int tag)
eb_walk_down	ebtree/ebtree.h	/^static inline struct eb_node *eb_walk_down(eb_troot_t *start, unsigned int side)$/;"	f	signature:(eb_troot_t *start, unsigned int side)
ebim_insert	ebtree/ebimtree.c	/^ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)$/;"	f	signature:(struct eb_root *root, struct ebpt_node *new, unsigned int len)
ebim_insert	ebtree/ebimtree.h	/^REGPRM3 struct ebpt_node *ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len);$/;"	p	signature:(struct eb_root *root, struct ebpt_node *new, unsigned int len)
ebim_lookup	ebtree/ebimtree.c	/^ebim_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f	signature:(struct eb_root *root, const void *x, unsigned int len)
ebim_lookup	ebtree/ebimtree.h	/^REGPRM3 struct ebpt_node *ebim_lookup(struct eb_root *root, const void *x, unsigned int len);$/;"	p	signature:(struct eb_root *root, const void *x, unsigned int len)
ebis_insert	ebtree/ebistree.c	/^REGPRM2 struct ebpt_node *ebis_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f	signature:(struct eb_root *root, struct ebpt_node *new)
ebis_insert	ebtree/ebistree.h	/^REGPRM2 struct ebpt_node *ebis_insert(struct eb_root *root, struct ebpt_node *new);$/;"	p	signature:(struct eb_root *root, struct ebpt_node *new)
ebis_lookup	ebtree/ebistree.c	/^REGPRM2 struct ebpt_node *ebis_lookup(struct eb_root *root, const char *x)$/;"	f	signature:(struct eb_root *root, const char *x)
ebis_lookup	ebtree/ebistree.h	/^REGPRM2 struct ebpt_node *ebis_lookup(struct eb_root *root, const char *x);$/;"	p	signature:(struct eb_root *root, const char *x)
ebis_lookup_len	ebtree/ebistree.c	/^REGPRM3 struct ebpt_node *ebis_lookup_len(struct eb_root *root, const char *x, unsigned int len)$/;"	f	signature:(struct eb_root *root, const char *x, unsigned int len)
ebis_lookup_len	ebtree/ebistree.h	/^REGPRM3 struct ebpt_node *ebis_lookup_len(struct eb_root *root, const char *x, unsigned int len);$/;"	p	signature:(struct eb_root *root, const char *x, unsigned int len)
ebmb_delete	ebtree/ebmbtree.h	/^static forceinline void ebmb_delete(struct ebmb_node *ebmb)$/;"	f	signature:(struct ebmb_node *ebmb)
ebmb_entry	ebtree/ebmbtree.h	28;"	d
ebmb_first	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_first(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
ebmb_insert	ebtree/ebmbtree.c	/^ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f	signature:(struct eb_root *root, struct ebmb_node *new, unsigned int len)
ebmb_insert	ebtree/ebmbtree.h	/^REGPRM3 struct ebmb_node *ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len);$/;"	p	signature:(struct eb_root *root, struct ebmb_node *new, unsigned int len)
ebmb_insert_prefix	ebtree/ebmbtree.c	/^ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f	signature:(struct eb_root *root, struct ebmb_node *new, unsigned int len)
ebmb_insert_prefix	ebtree/ebmbtree.h	/^REGPRM3 struct ebmb_node *ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len);$/;"	p	signature:(struct eb_root *root, struct ebmb_node *new, unsigned int len)
ebmb_last	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_last(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
ebmb_lookup	ebtree/ebmbtree.c	/^ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f	signature:(struct eb_root *root, const void *x, unsigned int len)
ebmb_lookup	ebtree/ebmbtree.h	/^REGPRM3 struct ebmb_node *ebmb_lookup(struct eb_root *root, const void *x, unsigned int len);$/;"	p	signature:(struct eb_root *root, const void *x, unsigned int len)
ebmb_lookup_longest	ebtree/ebmbtree.c	/^ebmb_lookup_longest(struct eb_root *root, const void *x)$/;"	f	signature:(struct eb_root *root, const void *x)
ebmb_lookup_longest	ebtree/ebmbtree.h	/^REGPRM2 struct ebmb_node *ebmb_lookup_longest(struct eb_root *root, const void *x);$/;"	p	signature:(struct eb_root *root, const void *x)
ebmb_lookup_prefix	ebtree/ebmbtree.c	/^ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)$/;"	f	signature:(struct eb_root *root, const void *x, unsigned int pfx)
ebmb_lookup_prefix	ebtree/ebmbtree.h	/^REGPRM3 struct ebmb_node *ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx);$/;"	p	signature:(struct eb_root *root, const void *x, unsigned int pfx)
ebmb_next	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_next(struct ebmb_node *ebmb)$/;"	f	signature:(struct ebmb_node *ebmb)
ebmb_next_unique	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_next_unique(struct ebmb_node *ebmb)$/;"	f	signature:(struct ebmb_node *ebmb)
ebmb_node	ebtree/ebmbtree.h	/^struct ebmb_node {$/;"	s
ebmb_node::key	ebtree/ebmbtree.h	/^	unsigned char key[0]; \/* the key, its size depends on the application *\/$/;"	m	struct:ebmb_node	access:public
ebmb_node::node	ebtree/ebmbtree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebmb_node	typeref:struct:ebmb_node::eb_node	access:public
ebmb_prev	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_prev(struct ebmb_node *ebmb)$/;"	f	signature:(struct ebmb_node *ebmb)
ebmb_prev_unique	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_prev_unique(struct ebmb_node *ebmb)$/;"	f	signature:(struct ebmb_node *ebmb)
ebpt_delete	ebtree/ebpttree.h	/^static forceinline void ebpt_delete(struct ebpt_node *ebpt)$/;"	f	signature:(struct ebpt_node *ebpt)
ebpt_entry	ebtree/ebpttree.h	30;"	d
ebpt_first	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_first(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
ebpt_insert	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f	signature:(struct eb_root *root, struct ebpt_node *new)
ebpt_insert	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f	signature:(struct eb_root *root, struct ebpt_node *new)
ebpt_last	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_last(struct eb_root *root)$/;"	f	signature:(struct eb_root *root)
ebpt_lookup	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)$/;"	f	signature:(struct eb_root *root, void *x)
ebpt_lookup	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)$/;"	f	signature:(struct eb_root *root, void *x)
ebpt_lookup_ge	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)$/;"	f	signature:(struct eb_root *root, void *x)
ebpt_lookup_ge	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)$/;"	f	signature:(struct eb_root *root, void *x)
ebpt_lookup_le	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)$/;"	f	signature:(struct eb_root *root, void *x)
ebpt_lookup_le	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)$/;"	f	signature:(struct eb_root *root, void *x)
ebpt_next	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_next(struct ebpt_node *ebpt)$/;"	f	signature:(struct ebpt_node *ebpt)
ebpt_next_unique	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_next_unique(struct ebpt_node *ebpt)$/;"	f	signature:(struct ebpt_node *ebpt)
ebpt_node	ebtree/ebpttree.h	/^struct ebpt_node {$/;"	s
ebpt_node::key	ebtree/ebpttree.h	/^	void *key;$/;"	m	struct:ebpt_node	access:public
ebpt_node::node	ebtree/ebpttree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebpt_node	typeref:struct:ebpt_node::eb_node	access:public
ebpt_old	contrib/halog/halog.c	/^	struct ebpt_node *ebpt_old;$/;"	l
ebpt_prev	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_prev(struct ebpt_node *ebpt)$/;"	f	signature:(struct ebpt_node *ebpt)
ebpt_prev_unique	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_prev_unique(struct ebpt_node *ebpt)$/;"	f	signature:(struct ebpt_node *ebpt)
ebst_insert	ebtree/ebsttree.c	/^REGPRM2 struct ebmb_node *ebst_insert(struct eb_root *root, struct ebmb_node *new)$/;"	f	signature:(struct eb_root *root, struct ebmb_node *new)
ebst_insert	ebtree/ebsttree.h	/^REGPRM2 struct ebmb_node *ebst_insert(struct eb_root *root, struct ebmb_node *new);$/;"	p	signature:(struct eb_root *root, struct ebmb_node *new)
ebst_lookup	ebtree/ebsttree.c	/^REGPRM2 struct ebmb_node *ebst_lookup(struct eb_root *root, const char *x)$/;"	f	signature:(struct eb_root *root, const char *x)
ebst_lookup	ebtree/ebsttree.h	/^REGPRM2 struct ebmb_node *ebst_lookup(struct eb_root *root, const char *x);$/;"	p	signature:(struct eb_root *root, const char *x)
ebst_lookup_len	ebtree/ebsttree.c	/^REGPRM3 struct ebmb_node *ebst_lookup_len(struct eb_root *root, const char *x, unsigned int len)$/;"	f	signature:(struct eb_root *root, const char *x, unsigned int len)
ebst_lookup_len	ebtree/ebsttree.h	/^REGPRM3 struct ebmb_node *ebst_lookup_len(struct eb_root *root, const char *x, unsigned int len);$/;"	p	signature:(struct eb_root *root, const char *x, unsigned int len)
element	src/appsession.c	/^	appsess                *element, *back;$/;"	l
enable_all	include/types/protocols.h	/^	int (*enable_all)(struct protocol *proto);	\/* enable all bound listeners *\/$/;"	m	struct:protocol	access:public
enable_all_listeners	include/proto/protocols.h	/^int enable_all_listeners(struct protocol *proto);$/;"	p	signature:(struct protocol *proto)
enable_all_listeners	src/protocols.c	/^int enable_all_listeners(struct protocol *proto)$/;"	f	signature:(struct protocol *proto)
enable_listener	include/proto/protocols.h	/^void enable_listener(struct listener *listener);$/;"	p	signature:(struct listener *listener)
enable_listener	src/protocols.c	/^		enable_listener(listener);$/;"	p	file:
enable_listener	src/protocols.c	/^void enable_listener(struct listener *listener)$/;"	f	signature:(struct listener *listener)
encode_string	include/common/standard.h	/^char *encode_string(char *start, char *stop,$/;"	p	signature:(char *start, char *stop, const char escape, const fd_set *map, const char *string)
encode_string	src/standard.c	/^char *encode_string(char *start, char *stop,$/;"	f	signature:(char *start, char *stop, const char escape, const fd_set *map, const char *string)
end	contrib/halog/fgets2-64.c	/^	static char *end = buffer;$/;"	l	file:
end	contrib/halog/fgets2.c	/^	static char *end = buffer;$/;"	l	file:
end	src/acl.c	/^		char *end, *arg2;$/;"	l
end	src/acl.c	/^	char *c, *end;$/;"	l
end	src/acl.c	/^	char *end;$/;"	l
end	src/backend.c	/^			const char *beg, *end;$/;"	l
end	src/backend.c	/^		const char *beg, *end;$/;"	l
end	src/cfgparse.c	/^							char *name, *end;$/;"	l
end	src/cfgparse.c	/^					char *name, *end;$/;"	l
end	src/cfgparse.c	/^				const char *beg, *end;$/;"	l
end	src/cfgparse.c	/^		char *end;$/;"	l
end	src/cfgparse.c	/^	int port, end;$/;"	l
end	src/dumpstats.c	/^	int end;$/;"	l
end	src/pattern.c	/^	const char *end;$/;"	l
end	src/proto_http.c	/^	char *end = buf->data + buf->size;$/;"	l
end	src/proto_http.c	/^	char *ptr, *end;$/;"	l
end	src/proto_http.c	/^	register char *ptr, *end; \/* request pointers, to avoid dereferences *\/$/;"	l
end_params	src/proto_http.c	/^	char *end_params, *first_param, *cur_param, *next_param;$/;"	l
end_params	src/proto_http.c	/^	char *first_param, *cur_param, *next_param, *end_params;$/;"	l
endw	src/pattern.c	/^	const char *endw;$/;"	l
entry	src/memory.c	/^	struct pool_head *entry;$/;"	l
eo	src/ev_sepoll.c	/^	int status, eo;$/;"	l
eoh	include/types/proto_http.h	/^	unsigned int eoh;                      \/* End Of Headers, relative to buffer *\/$/;"	m	struct:http_msg	access:public
eol	include/types/proto_http.h	/^	char *eol;                             \/* end of line *\/$/;"	m	struct:http_msg	access:public
eol	src/proto_http.c	/^		char *eol, *sol;$/;"	l
eol	src/proto_http.c	/^	char *eol, *sol, *col, *sov;$/;"	l
eol	src/proto_http.c	/^	char *eol, *sov;$/;"	l
ep	src/auth.c	/^	const char *ep;$/;"	l
epoll_create	include/common/epoll.h	/^static int epoll_create(int size);$/;"	p	signature:(int size)
epoll_ctl	include/common/epoll.h	/^static int epoll_ctl(int epfd, int op, int fd, struct epoll_event * event);$/;"	p	signature:(int epfd, int op, int fd, struct epoll_event * event)
epoll_event	include/common/epoll.h	/^struct epoll_event {$/;"	s
epoll_event::__anon65::fd	include/common/epoll.h	/^		int fd;$/;"	m	union:epoll_event::__anon65	access:public
epoll_event::__anon65::ptr	include/common/epoll.h	/^		void *ptr;$/;"	m	union:epoll_event::__anon65	access:public
epoll_event::__anon65::u32	include/common/epoll.h	/^		uint32_t u32;$/;"	m	union:epoll_event::__anon65	access:public
epoll_event::__anon65::u64	include/common/epoll.h	/^		uint64_t u64;$/;"	m	union:epoll_event::__anon65	access:public
epoll_event::data	include/common/epoll.h	/^	} data;$/;"	m	struct:epoll_event	typeref:union:epoll_event::__anon65	access:public
epoll_event::events	include/common/epoll.h	/^	uint32_t events;$/;"	m	struct:epoll_event	access:public
epoll_events	src/ev_epoll.c	/^static struct epoll_event *epoll_events;$/;"	v	typeref:struct:epoll_event	file:
epoll_events	src/ev_sepoll.c	/^static struct epoll_event *epoll_events;$/;"	v	typeref:struct:epoll_event	file:
epoll_fd	src/ev_epoll.c	/^static int epoll_fd;$/;"	v	file:
epoll_fd	src/ev_sepoll.c	/^static int epoll_fd;$/;"	v	file:
epoll_wait	include/common/epoll.h	/^static int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);$/;"	p	signature:(int epfd, struct epoll_event * events, int maxevents, int timeout)
equal	src/proto_http.c	/^	char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;$/;"	l
equal_bits	ebtree/ebtree.h	/^static forceinline int equal_bits(const unsigned char *a,$/;"	f	signature:(const unsigned char *a, const unsigned char *b, int ignore, int len)
err	contrib/halog/halog.c	/^	int f, tot, last, linenum, err, parse_err;$/;"	l
err	src/backend.c	/^	int err;$/;"	l
err	src/cfgparse.c	/^				const char *err = parse_time_err(args[cur_arg + 1], &val, TIME_UNIT_MS);$/;"	l
err	src/cfgparse.c	/^			const char *err;$/;"	l
err	src/cfgparse.c	/^		char *err;$/;"	l
err	src/cfgparse.c	/^		const char *err;$/;"	l
err	src/cfgparse.c	/^	const char *err;$/;"	l
err	src/checks.c	/^		int skerr, err = errno;$/;"	l
err	src/haproxy.c	/^	int err, retry;$/;"	l
err	src/log.c	/^	int tolog, level, err;$/;"	l
err	src/proto_http.c	/^	int tolog, level, err;$/;"	l
err	src/proto_tcp.c	/^	int err = ERR_NONE;$/;"	l
err	src/proto_tcp.c	/^	int fd, err;$/;"	l
err	src/proto_uxst.c	/^	int err = ERR_NONE;$/;"	l
err	src/protocols.c	/^	int err;$/;"	l
err	src/proxy.c	/^	int err;$/;"	l
err	src/proxy.c	/^	int lerr, err = ERR_NONE;$/;"	l
err	src/regex.c	/^		const char *err;$/;"	l
err	src/regex.c	/^	const char *err = NULL;$/;"	l
err	src/session.c	/^	int err = 0, fin = 0;$/;"	l
err	src/standard.c	/^		char *err;$/;"	l
err	tests/ip-hash.c	/^	double err, total_err, max_err;$/;"	l
err_code	src/cfgparse.c	/^	int err_code = 0;$/;"	l
err_code	src/haproxy.c	/^	int err_code = 0;$/;"	l
err_loc	include/types/stream_interface.h	/^	void *err_loc;          \/* commonly the server, NULL when SI_ET_NONE *\/$/;"	m	struct:stream_interface	access:public
err_pos	include/types/proto_http.h	/^	int err_pos;                           \/* err handling: -2=block, -1=pass, 0+=detected *\/$/;"	m	struct:http_msg	access:public
err_type	include/types/stream_interface.h	/^	unsigned int err_type;  \/* first error detected, one of SI_ET_* *\/$/;"	m	struct:stream_interface	access:public
err_type	src/proto_http.c	/^	int err_type = si->err_type;$/;"	l
err_type	src/session.c	/^	int err_type = si->err_type;$/;"	l
errlen	src/cfgparse.c	/^		int errnum, errlen, fd;$/;"	l
errlen	src/cfgparse.c	/^		int errnum, errlen;$/;"	l
errmsg	include/types/proxy.h	/^	struct chunk errmsg[HTTP_ERR_SIZE];	\/* default or customized error messages for known errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::chunk	access:public
errnum	src/cfgparse.c	/^		int errnum, errlen, fd;$/;"	l
errnum	src/cfgparse.c	/^		int errnum, errlen;$/;"	l
error_message	include/proto/httperr.h	/^struct chunk *error_message(struct session *s, int msgnum);$/;"	p	signature:(struct session *s, int msgnum)
error_message	src/proto_http.c	/^struct chunk *error_message(struct session *s, int msgnum)$/;"	f	signature:(struct session *s, int msgnum)
error_snapshot	include/types/proxy.h	/^struct error_snapshot {$/;"	s
error_snapshot::buf	include/types/proxy.h	/^	char buf[BUFSIZE];		\/* copy of the beginning of the message *\/$/;"	m	struct:error_snapshot	access:public
error_snapshot::len	include/types/proxy.h	/^	unsigned int len;		\/* original length of the last invalid request\/response *\/$/;"	m	struct:error_snapshot	access:public
error_snapshot::oe	include/types/proxy.h	/^	struct proxy *oe;		\/* other end = frontend or backend involved *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::proxy	access:public
error_snapshot::pos	include/types/proxy.h	/^	unsigned int pos;		\/* position of the first invalid character *\/$/;"	m	struct:error_snapshot	access:public
error_snapshot::sid	include/types/proxy.h	/^	unsigned int sid;		\/* ID of the faulty session *\/$/;"	m	struct:error_snapshot	access:public
error_snapshot::src	include/types/proxy.h	/^	struct sockaddr_storage src;	\/* client's address *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::sockaddr_storage	access:public
error_snapshot::srv	include/types/proxy.h	/^	struct server *srv;		\/* server associated with the error (or NULL) *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::server	access:public
error_snapshot::when	include/types/proxy.h	/^	struct timeval when;		\/* date of this event, (tv_sec == 0) means "never" *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::timeval	access:public
errors	include/types/session.h	/^		} errors;$/;"	m	union:session::__anon9	typeref:struct:session::__anon9::__anon12	access:public
es	src/dumpstats.c	/^		struct error_snapshot *es;$/;"	l
ev	include/types/fd.h	/^	unsigned char ev;                    \/* event seen in return of poll() : FD_POLL_* *\/$/;"	m	struct:fdtab	access:public
ev	src/ev_epoll.c	/^static struct epoll_event ev;$/;"	v	typeref:struct:epoll_event	file:
ev	src/ev_sepoll.c	/^static struct epoll_event ev;$/;"	v	typeref:struct:epoll_event	file:
event_accept	include/proto/client.h	/^int event_accept(int fd);$/;"	p	signature:(int fd)
event_accept	include/proto/proto_http.h	/^int event_accept(int fd);$/;"	p	signature:(int fd)
event_accept	src/client.c	/^int event_accept(int fd) {$/;"	f	signature:(int fd)
event_srv_chk_r	src/checks.c	/^static int event_srv_chk_r(int fd)$/;"	f	file:	signature:(int fd)
event_srv_chk_w	src/checks.c	/^static int event_srv_chk_w(int fd)$/;"	f	file:	signature:(int fd)
events	include/common/epoll.h	/^	uint32_t events;$/;"	m	struct:epoll_event	access:public
eweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server	access:public
except_mask	include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
except_mask_to	include/types/proxy.h	/^	struct in_addr except_mask_to;		\/* the netmask for except_to. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr	access:public
except_net	include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr	access:public
except_to	include/types/proxy.h	/^	struct in_addr except_to;		\/* don't x-original-to for this address. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr	access:public
exp	include/types/stream_interface.h	/^	unsigned int exp;       \/* wake up time for connect, queue, turn-around, ... *\/$/;"	m	struct:stream_interface	access:public
exp	src/cfgparse.c	/^			struct hdr_exp *exp;$/;"	l
exp	src/haproxy.c	/^	struct hdr_exp *exp, *expb;$/;"	l
exp	src/proto_http.c	/^	struct hdr_exp *exp;$/;"	l
exp	src/regex.c	/^	struct hdr_exp *exp;$/;"	l
exp_next	include/types/stick_table.h	/^	int exp_next;             \/* next epiration date *\/$/;"	m	struct:stktable	access:public
exp_replace	include/common/regex.h	/^int exp_replace(char *dst, char *src, const char *str,	const regmatch_t *matches);$/;"	p	signature:(char *dst, char *src, const char *str, const regmatch_t *matches)
exp_replace	src/regex.c	/^int exp_replace(char *dst, char *src, const char *str, const regmatch_t *matches)$/;"	f	signature:(char *dst, char *src, const char *str, const regmatch_t *matches)
exp_task	include/types/stick_table.h	/^	struct task *exp_task;    \/* expiration task *\/$/;"	m	struct:stktable	typeref:struct:stktable::task	access:public
expb	src/haproxy.c	/^	struct hdr_exp *exp, *expb;$/;"	l
expect_regex	include/types/proxy.h	/^	regex_t *expect_regex;			\/* http-check expected content *\/$/;"	m	struct:proxy	access:public
expect_str	include/types/proxy.h	/^	char *expect_str;			\/* http-check expected content *\/$/;"	m	struct:proxy	access:public
expire	include/common/appsession.h	/^	int   expire;		\/* next expiration time for this application session (in tick) *\/$/;"	m	struct:appsessions	access:public
expire	include/types/stick_table.h	/^	int expire;               \/* duration before expiration of stuck session *\/$/;"	m	struct:stktable	access:public
expire	include/types/stick_table.h	/^	unsigned int expire;      \/* session expiration date *\/$/;"	m	struct:stksess	access:public
expire	include/types/task.h	/^	int expire;			\/* next expiration date for this task, in ticks *\/$/;"	m	struct:task	access:public
expire	src/checks.c	/^	int expire;$/;"	l
expire	src/task.c	/^	int expire;$/;"	l
expr	include/types/acl.h	/^	struct list expr;	    \/* list of acl_exprs *\/$/;"	m	struct:acl	typeref:struct:acl::list	access:public
expr	include/types/proxy.h	/^	struct pattern_expr *expr;              \/* fetch expr to fetch key *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::pattern_expr	access:public
expr	src/acl.c	/^	const char *expr[4]; \/* put enough for longest expression *\/$/;"	m	struct:__anon66	file:	access:public
expr	src/acl.c	/^	struct acl_expr *expr, *exprb;$/;"	l
expr	src/acl.c	/^	struct acl_expr *expr;$/;"	l
expr	src/backend.c	/^	struct acl_expr  expr;$/;"	l
expr	src/cfgparse.c	/^		struct pattern_expr *expr;$/;"	l
expr	src/pattern.c	/^	struct pattern_expr *expr;$/;"	l
expr	src/proto_tcp.c	/^	struct acl_expr  expr;$/;"	l
exprb	src/acl.c	/^	struct acl_expr *expr, *exprb;$/;"	l
exps	include/types/stick_table.h	/^	struct eb32_node exps;    \/* ebtree node used to hold the session in expiration tree *\/$/;"	m	struct:stksess	typeref:struct:stksess::eb32_node	access:public
exps	include/types/stick_table.h	/^	struct eb_root exps;      \/* head of stuck session expiration tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root	access:public
f	contrib/halog/halog.c	/^			int f;$/;"	l
f	contrib/halog/halog.c	/^	int f, tot, last, linenum, err, parse_err;$/;"	l
f	include/types/fd.h	/^		int (*f)(int fd);            \/* read\/write function *\/$/;"	m	struct:fdtab::__anon56	access:public
f	src/cfgparse.c	/^	FILE *f;$/;"	l
f	src/ev_epoll.c	/^				fdtab[fd].cb[DIR_RD].f(fd);$/;"	p	file:
f	src/ev_epoll.c	/^				fdtab[fd].cb[DIR_WR].f(fd);$/;"	p	file:
f	src/ev_kqueue.c	/^				fdtab[fd].cb[DIR_RD].f(fd);$/;"	p	file:
f	src/ev_kqueue.c	/^				fdtab[fd].cb[DIR_WR].f(fd);$/;"	p	file:
f	src/ev_poll.c	/^				fdtab[fd].cb[DIR_RD].f(fd);$/;"	p	file:
f	src/ev_poll.c	/^				fdtab[fd].cb[DIR_WR].f(fd);$/;"	p	file:
f	src/ev_select.c	/^				fdtab[fd].cb[DIR_RD].f(fd);$/;"	p	file:
f	src/ev_select.c	/^				fdtab[fd].cb[DIR_WR].f(fd);$/;"	p	file:
f	src/ev_sepoll.c	/^				fdtab[fd].cb[DIR_RD].f(fd);$/;"	p	file:
f	src/ev_sepoll.c	/^				fdtab[fd].cb[DIR_WR].f(fd);$/;"	p	file:
fac_level	src/log.c	/^	int fac_level;$/;"	l
facilities	src/log.c	/^	int facilities[2], loglevel[2], minlvl[2];$/;"	l
facility	src/cfgparse.c	/^		int facility, level, minlvl;$/;"	l
facility	src/cfgparse.c	/^		int facility;$/;"	l
facility	src/log.c	/^	int facility;$/;"	l
faddr	include/import/ip_tproxy.h	/^	struct in_addr	faddr;$/;"	m	struct:in_tproxy_addr	typeref:struct:in_tproxy_addr::in_addr	access:public
fail_chg_list	src/ev_epoll.c	/^	__label__ fail_chg_ptr, fail_chg_list, fail_fdevt, fail_ee, fail_fd;$/;"	l
fail_chg_ptr	src/ev_epoll.c	/^	__label__ fail_chg_ptr, fail_chg_list, fail_fdevt, fail_ee, fail_fd;$/;"	l
fail_ee	src/ev_epoll.c	/^	__label__ fail_chg_ptr, fail_chg_list, fail_fdevt, fail_ee, fail_fd;$/;"	l
fail_ee	src/ev_sepoll.c	/^	__label__ fail_spec, fail_ee, fail_fd;$/;"	l
fail_fd	src/ev_epoll.c	/^	__label__ fail_chg_ptr, fail_chg_list, fail_fdevt, fail_ee, fail_fd;$/;"	l
fail_fd	src/ev_kqueue.c	/^	__label__ fail_wevt, fail_revt, fail_fd;$/;"	l
fail_fd	src/ev_sepoll.c	/^	__label__ fail_spec, fail_ee, fail_fd;$/;"	l
fail_fdevt	src/ev_epoll.c	/^	__label__ fail_chg_ptr, fail_chg_list, fail_fdevt, fail_ee, fail_fd;$/;"	l
fail_pe	src/ev_poll.c	/^	__label__ fail_swevt, fail_srevt, fail_pe;$/;"	l
fail_revt	src/ev_kqueue.c	/^	__label__ fail_wevt, fail_revt, fail_fd;$/;"	l
fail_revt	src/ev_select.c	/^	__label__ fail_swevt, fail_srevt, fail_wevt, fail_revt;$/;"	l
fail_spec	src/ev_sepoll.c	/^	__label__ fail_spec, fail_ee, fail_fd;$/;"	l
fail_srevt	src/ev_poll.c	/^	__label__ fail_swevt, fail_srevt, fail_pe;$/;"	l
fail_srevt	src/ev_select.c	/^	__label__ fail_swevt, fail_srevt, fail_wevt, fail_revt;$/;"	l
fail_swevt	src/ev_poll.c	/^	__label__ fail_swevt, fail_srevt, fail_pe;$/;"	l
fail_swevt	src/ev_select.c	/^	__label__ fail_swevt, fail_srevt, fail_wevt, fail_revt;$/;"	l
fail_wevt	src/ev_kqueue.c	/^	__label__ fail_wevt, fail_revt, fail_fd;$/;"	l
fail_wevt	src/ev_select.c	/^	__label__ fail_swevt, fail_srevt, fail_wevt, fail_revt;$/;"	l
failed	src/checks.c	/^	int failed;$/;"	l
failed_checks	include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters	access:public
failed_conns	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:pxcounters	access:public
failed_conns	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters	access:public
failed_hana	include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters	access:public
failed_req	include/types/counters.h	/^	long long failed_req;			\/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:licounters	access:public
failed_req	include/types/counters.h	/^	long long failed_req;			\/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:pxcounters	access:public
failed_resp	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:pxcounters	access:public
failed_resp	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters	access:public
failed_secu	include/types/counters.h	/^	long long failed_secu;			\/* blocked responses because of security concerns *\/$/;"	m	struct:srvcounters	access:public
fall	include/types/server.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:server	access:public
fall	src/checks.c	/^		int health, rise, fall, state;$/;"	l
fast_stop	src/haproxy.c	/^static void fast_stop(void)$/;"	f	file:	signature:(void)
fastinter	include/types/server.h	/^	int inter, fastinter, downinter;	\/* checks: time in milliseconds *\/$/;"	m	struct:server	access:public
fbck	include/types/backend.h	/^	struct server *fbck;		\/* first backup server when !PR_O_USE_ALL_BK, or NULL *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::server	access:public
fd	include/common/epoll.h	/^		int fd;$/;"	m	union:epoll_event::__anon65	access:public
fd	include/types/protocols.h	/^	int fd;				\/* the listen socket *\/$/;"	m	struct:listener	access:public
fd	include/types/stream_interface.h	/^	int fd;                 \/* file descriptor for a stream driver when known *\/$/;"	m	struct:stream_interface	access:public
fd	src/cfgparse.c	/^		int errnum, errlen, fd;$/;"	l
fd	src/checks.c	/^	int fd;$/;"	l
fd	src/cttproxy.c	/^	int fd, ret;$/;"	l
fd	src/ev_epoll.c	/^	int chg, fd;$/;"	l
fd	src/ev_epoll.c	/^	int fd;$/;"	l
fd	src/ev_epoll.c	/^	unsigned int fd:30;	\/\/ file descriptor$/;"	m	struct:fd_chg	file:	access:public
fd	src/ev_kqueue.c	/^	int count, fd, delta_ms;$/;"	l
fd	src/ev_kqueue.c	/^	int fd;$/;"	l
fd	src/ev_poll.c	/^	int fd, nbfd;$/;"	l
fd	src/ev_select.c	/^	int fd, i;$/;"	l
fd	src/ev_sepoll.c	/^	int fd, opcode;$/;"	l
fd	src/ev_sepoll.c	/^	int fd;$/;"	l
fd	src/proto_tcp.c	/^	int fd, err;$/;"	l
fd	src/proto_tcp.c	/^	int fd;$/;"	l
fd	src/proto_uxst.c	/^	int fd;$/;"	l
fd	src/stream_sock.c	/^	int fd = si->fd;$/;"	l
fd_chg	src/ev_epoll.c	/^struct fd_chg {$/;"	s	file:
fd_chg::fd	src/ev_epoll.c	/^	unsigned int fd:30;	\/\/ file descriptor$/;"	m	struct:fd_chg	file:	access:public
fd_chg::prev	src/ev_epoll.c	/^	unsigned int prev:2;	\/\/ previous state mask. New one is in fd_evts.$/;"	m	struct:fd_chg	file:	access:public
fd_created	src/ev_sepoll.c	/^static int fd_created = 0;      \/\/ fd creation detector, reset upon poll() entry.$/;"	v	file:
fd_delete	include/proto/fd.h	/^void fd_delete(int fd);$/;"	p	signature:(int fd)
fd_delete	src/fd.c	/^void fd_delete(int fd)$/;"	f	signature:(int fd)
fd_evts	src/ev_epoll.c	/^static uint32_t *fd_evts;$/;"	v	file:
fd_evts	src/ev_kqueue.c	/^static fd_set *fd_evts[2];$/;"	v	file:
fd_evts	src/ev_poll.c	/^static fd_set *fd_evts[2];$/;"	v	file:
fd_evts	src/ev_select.c	/^static fd_set *fd_evts[2];$/;"	v	file:
fd_flush_changes	src/ev_epoll.c	/^REGPRM2 static void fd_flush_changes()$/;"	f	file:
fd_insert	include/proto/fd.h	/^static inline void fd_insert(int fd)$/;"	f	signature:(int fd)
fd_set_bytes	src/ev_epoll.c	/^	int fd_set_bytes;$/;"	l
fd_set_bytes	src/ev_kqueue.c	/^	int fd_set_bytes;$/;"	l
fd_set_bytes	src/ev_poll.c	/^	int fd_set_bytes;$/;"	l
fd_set_bytes	src/ev_select.c	/^	int fd_set_bytes;$/;"	l
fdinfo	include/types/fd.h	/^extern struct fdinfo *fdinfo;           \/* less-often used infos for file descriptors *\/$/;"	x
fdinfo	include/types/fd.h	/^struct fdinfo {$/;"	s
fdinfo	src/fd.c	/^struct fdinfo *fdinfo = NULL;   \/* less-often used infos for file descriptors *\/$/;"	v	typeref:struct:fdinfo
fdinfo::local_port	include/types/fd.h	/^	int local_port;                      \/* optional local port *\/$/;"	m	struct:fdinfo	access:public
fdinfo::peeraddr	include/types/fd.h	/^	struct sockaddr *peeraddr;   \/* pointer to peer's network address, or NULL if unset *\/$/;"	m	struct:fdinfo	typeref:struct:fdinfo::sockaddr	access:public
fdinfo::peerlen	include/types/fd.h	/^	socklen_t peerlen;           \/* peer's address length, or 0 if unset *\/$/;"	m	struct:fdinfo	access:public
fdinfo::port_range	include/types/fd.h	/^	struct port_range *port_range;       \/* optional port range to bind to *\/$/;"	m	struct:fdinfo	typeref:struct:fdinfo::port_range	access:public
fds	src/ev_poll.c	/^	int fds, count;$/;"	l
fds	src/ev_select.c	/^	int fds;$/;"	l
fdtab	include/types/fd.h	/^extern struct fdtab *fdtab;             \/* array of all the file descriptors *\/$/;"	x
fdtab	include/types/fd.h	/^struct fdtab {$/;"	s
fdtab	src/fd.c	/^struct fdtab *fdtab = NULL;     \/* array of all the file descriptors *\/$/;"	v	typeref:struct:fdtab
fdtab::__anon56::b	include/types/fd.h	/^		struct buffer *b;            \/* read\/write buffer *\/$/;"	m	struct:fdtab::__anon56	typeref:struct:fdtab::__anon56::buffer	access:public
fdtab::__anon56::f	include/types/fd.h	/^		int (*f)(int fd);            \/* read\/write function *\/$/;"	m	struct:fdtab::__anon56	access:public
fdtab::__anon57::e	include/types/fd.h	/^		unsigned char e;             \/* read and write events status. 4 bits, may be merged into flags' lower bits *\/$/;"	m	struct:fdtab::__anon57	access:public
fdtab::__anon57::s1	include/types/fd.h	/^		unsigned int s1;             \/* Position in spec list+1. 0=not in list. *\/$/;"	m	struct:fdtab::__anon57	access:public
fdtab::cb	include/types/fd.h	/^	} cb[DIR_SIZE];$/;"	m	struct:fdtab	typeref:struct:fdtab::__anon56	access:public
fdtab::ev	include/types/fd.h	/^	unsigned char ev;                    \/* event seen in return of poll() : FD_POLL_* *\/$/;"	m	struct:fdtab	access:public
fdtab::flags	include/types/fd.h	/^	unsigned short flags;                \/* various flags precising the exact status of this fd *\/$/;"	m	struct:fdtab	access:public
fdtab::owner	include/types/fd.h	/^	void *owner;                         \/* the session (or proxy) associated with this fd *\/$/;"	m	struct:fdtab	access:public
fdtab::spec	include/types/fd.h	/^	} spec;$/;"	m	struct:fdtab	typeref:struct:fdtab::__anon57	access:public
fdtab::state	include/types/fd.h	/^	unsigned char state;                 \/* the state of this fd *\/$/;"	m	struct:fdtab	access:public
fe	include/types/counters.h	/^	} fe, be;				\/* FE and BE stats *\/$/;"	m	struct:pxcounters	typeref:union:pxcounters::__anon58	access:public
fe	include/types/session.h	/^	struct proxy *fe;			\/* the proxy this session depends on for the client side *\/$/;"	m	struct:session	typeref:struct:session::proxy	access:public
fe	src/dumpstats.c	/^	struct proxy *fe;$/;"	l
fe	src/log.c	/^	struct proxy *fe = s->fe;$/;"	l
fe	src/proto_http.c	/^	struct proxy *fe = s->fe;$/;"	l
fe	src/session.c	/^	struct proxy *fe = s->fe;$/;"	l
fe_req_ana	include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy	access:public
fe_req_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_req_per_sec;		\/* HTTP requests per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr	access:public
fe_rps_max	include/types/counters.h	/^	unsigned int fe_rps_max;		\/* maximum of new sessions per second seen on the frontend *\/$/;"	m	struct:pxcounters	access:public
fe_rsp_ana	include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy	access:public
fe_sess_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_sess_per_sec;	\/* sessions per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr	access:public
fe_sps_lim	include/types/proxy.h	/^	unsigned int fe_sps_lim;		\/* limit on new sessions per second on the frontend *\/$/;"	m	struct:proxy	access:public
fe_sps_max	include/types/counters.h	/^	unsigned int fe_sps_max;		\/* maximum of new sessions per second seen on the frontend *\/$/;"	m	struct:pxcounters	access:public
feconn	include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends sessions *\/$/;"	m	struct:proxy	access:public
feconn_max	include/types/counters.h	/^	unsigned int feconn_max, beconn_max;	\/* max # of active frontend and backend sessions *\/$/;"	m	struct:pxcounters	access:public
fetch	include/types/acl.h	/^	int (*fetch)(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	m	struct:acl_keyword	access:public
fetch	include/types/pattern.h	/^	struct pattern_fetch *fetch;              \/* pattern fetch *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::pattern_fetch	access:public
fetch	src/pattern.c	/^	struct pattern_fetch *fetch;$/;"	l
fetch_next	src/acl.c	/^	__label__ fetch_next;$/;"	l
fgets2	contrib/halog/fgets2-64.c	/^const char *fgets2(FILE *stream)$/;"	f	signature:(FILE *stream)
fgets2	contrib/halog/fgets2.c	/^const char *fgets2(FILE *stream)$/;"	f	signature:(FILE *stream)
fgets2	contrib/halog/halog.c	/^const char *fgets2(FILE *stream);$/;"	p	file:	signature:(FILE *stream)
field_start	contrib/halog/halog.c	/^const char *field_start(const char *p, int field)$/;"	f	signature:(const char *p, int field)
field_stop	contrib/halog/halog.c	/^const char *field_stop(const char *p)$/;"	f	signature:(const char *p)
file	include/types/acl.h	/^	const char *file;           \/* config file where the condition is declared *\/$/;"	m	struct:acl_cond	access:public
file	include/types/protocols.h	/^		const char *file;	\/* file where the section appears *\/$/;"	m	struct:listener::__anon25	access:public
file	include/types/proxy.h	/^		const char *file;		\/* file where the section appears *\/$/;"	m	struct:proxy::__anon20	access:public
file	include/types/server.h	/^		const char *file;		\/* file where the section appears *\/$/;"	m	struct:server::__anon62	access:public
file	src/acl.c	/^	FILE *file;$/;"	l
filt_cap	src/acl.c	/^const unsigned int filt_cap[] = {$/;"	v
filter	contrib/halog/halog.c	/^unsigned int filter = 0;$/;"	v
filter_acc_count	contrib/halog/halog.c	/^	int filter_acc_delay = 0, filter_acc_count = 0;$/;"	l
filter_acc_delay	contrib/halog/halog.c	/^	int filter_acc_delay = 0, filter_acc_count = 0;$/;"	l
filter_invert	contrib/halog/halog.c	/^unsigned int filter_invert = 0;$/;"	v
filter_time_resp	contrib/halog/halog.c	/^	int filter_time_resp = 0;$/;"	l
fin	src/session.c	/^	int err = 0, fin = 0;$/;"	l
final	tests/test_hashes.c	389;"	d	file:
find_acl_by_name	include/proto/acl.h	/^struct acl *find_acl_by_name(const char *name, struct list *head);$/;"	p	signature:(const char *name, struct list *head)
find_acl_by_name	src/acl.c	/^struct acl *find_acl_by_name(const char *name, struct list *head)$/;"	f	signature:(const char *name, struct list *head)
find_acl_default	src/acl.c	/^struct acl *find_acl_default(const char *acl_name, struct list *known_acl)$/;"	f	signature:(const char *acl_name, struct list *known_acl)
find_acl_kw	include/proto/acl.h	/^struct acl_keyword *find_acl_kw(const char *kw);$/;"	p	signature:(const char *kw)
find_acl_kw	src/acl.c	/^struct acl_keyword *find_acl_kw(const char *kw)$/;"	f	signature:(const char *kw)
find_cookie_value_end	src/proto_http.c	/^char *find_cookie_value_end(char *s, const char *e)$/;"	f	signature:(char *s, const char *e)
find_hdr_value_end	src/proto_http.c	/^char *find_hdr_value_end(char *s, const char *e)$/;"	f	signature:(char *s, const char *e)
find_http_meth	src/proto_http.c	/^static http_meth_t find_http_meth(const char *str, const int len)$/;"	f	file:	signature:(const char *str, const int len)
find_next_stat_id	contrib/netsnmp-perl/haproxy.pl	/^sub find_next_stat_id {$/;"	s
find_pattern_conv	src/pattern.c	/^struct pattern_conv *find_pattern_conv(const char *kw, int len)$/;"	f	signature:(const char *kw, int len)
find_pattern_fetch	src/pattern.c	/^struct pattern_fetch *find_pattern_fetch(const char *kw, int len)$/;"	f	signature:(const char *kw, int len)
findproxy	include/proto/proxy.h	/^struct proxy *findproxy(const char *name, int cap);$/;"	p	signature:(const char *name, int cap)
findproxy	src/proxy.c	/^struct proxy *findproxy(const char *name, int cap) {$/;"	f	signature:(const char *name, int cap)
findproxy_mode	include/proto/proxy.h	/^struct proxy *findproxy_mode(const char *name, int mode, int cap);$/;"	p	signature:(const char *name, int mode, int cap)
findproxy_mode	src/proxy.c	/^struct proxy *findproxy_mode(const char *name, int mode, int cap) {$/;"	f	signature:(const char *name, int mode, int cap)
findserver	include/proto/proxy.h	/^struct server *findserver(const struct proxy *px, const char *name);$/;"	p	signature:(const struct proxy *px, const char *name)
findserver	src/proxy.c	/^struct server *findserver(const struct proxy *px, const char *name) {$/;"	f	signature:(const struct proxy *px, const char *name)
first_packet_len	src/checks.c	/^			unsigned int first_packet_len = ((unsigned int) *s->check_data) +$/;"	l
first_param	src/proto_http.c	/^	char *end_params, *first_param, *cur_param, *next_param;$/;"	l
first_param	src/proto_http.c	/^	char *first_param, *cur_param, *next_param, *end_params;$/;"	l
flag	src/haproxy.c	/^		char *flag;$/;"	l
flag	src/lb_map.c	/^	int o, tot, flag;$/;"	l
flags	include/common/memory.h	/^	unsigned int flags;	\/* MEM_F_* *\/$/;"	m	struct:pool_head	access:public
flags	include/common/uri_auth.h	/^	int flags;			\/* some flags describing the statistics page *\/$/;"	m	struct:uri_auth	access:public
flags	include/import/ip_tproxy.h	/^		u_int32_t		flags;$/;"	m	union:in_tproxy::_in_args	access:public
flags	include/types/acl.h	/^	int flags;                      \/* expr or pattern flags. *\/$/;"	m	struct:acl_pattern	access:public
flags	include/types/acl.h	/^	int flags;              \/* ACL_TEST_F_* set to 0 on first call *\/$/;"	m	struct:acl_test	access:public
flags	include/types/auth.h	/^	unsigned int flags;$/;"	m	struct:auth_users	access:public
flags	include/types/buffers.h	/^	unsigned int flags;             \/* BF_* *\/$/;"	m	struct:buffer	access:public
flags	include/types/fd.h	/^	unsigned short flags;                \/* various flags precising the exact status of this fd *\/$/;"	m	struct:fdtab	access:public
flags	include/types/proto_http.h	/^	unsigned int flags;             \/* transaction flags *\/$/;"	m	struct:http_txn	access:public
flags	include/types/proxy.h	/^	int flags;                              \/* STK_* *\/$/;"	m	struct:sticking_rule	access:public
flags	include/types/proxy.h	/^	unsigned int flags;$/;"	m	struct:redirect_rule	access:public
flags	include/types/session.h	/^			unsigned int flags;	\/* STAT_* *\/$/;"	m	struct:session::__anon9::__anon10	access:public
flags	include/types/session.h	/^		int flags;$/;"	m	struct:session::__anon7	access:public
flags	include/types/session.h	/^	int flags;				\/* some flags describing the session *\/$/;"	m	struct:session	access:public
flags	include/types/stick_table.h	/^	int flags;            \/* type flags *\/$/;"	m	struct:stktable_type	access:public
flags	include/types/stream_interface.h	/^	unsigned int flags;$/;"	m	struct:stream_interface	access:public
flags	src/cfgparse.c	/^		int flags;$/;"	l
flags	src/cfgparse.c	/^		unsigned int flags = REDIRECT_FLAG_NONE;$/;"	l
flags	src/checks.c	/^					int ret, flags = 0;$/;"	l
flags	src/proto_tcp.c	/^		int ret, flags = 0;$/;"	l
flags	src/session.c	/^		unsigned int flags = s->rep->flags;$/;"	l
flags	src/session.c	/^		unsigned int flags = s->req->flags;$/;"	l
fls64	ebtree/ebtree.h	/^static inline int fls64(unsigned long long x)$/;"	f	signature:(unsigned long long x)
fls_auto	ebtree/ebtree.h	325;"	d
flsnz	ebtree/ebtree.h	/^static inline int flsnz(int x)$/;"	f	signature:(int x)
flsnz	ebtree/ebtree.h	293;"	d
flsnz8	ebtree/ebtree.h	/^static inline int flsnz8(unsigned char x)$/;"	f	signature:(unsigned char x)
flsnz8	ebtree/ebtree.h	/^static inline int flsnz8(unsigned int x)$/;"	f	signature:(unsigned int x)
flsnz8_generic	ebtree/ebtree.h	/^static inline int flsnz8_generic(unsigned int x)$/;"	f	signature:(unsigned int x)
fmt	src/dumpstats.c	/^						char str[INET6_ADDRSTRLEN], *fmt = NULL;$/;"	l
fnv_32a_str	tests/test_hashes.c	/^fnv_32a_str(char *str, Fnv32_t hval)$/;"	f	signature:(char *str, Fnv32_t hval)
fnv_hash	tests/test_hashes.c	/^unsigned fnv_hash ( void *key, int len )$/;"	f	signature:( void *key, int len )
forceinline	include/common/compiler.h	74;"	d
forceinline	include/common/compiler.h	76;"	d
foreach_dlist_item	include/common/mini-clist.h	94;"	d
foreach_dlist_item_cst	include/common/mini-clist.h	88;"	d
foreign_ok	src/proto_tcp.c	/^	int foreign_ok = 0;$/;"	l
fork	include/types/fd.h	/^	int  REGPRM1   (*fork)(struct poller *p);            \/* post-fork re-opening *\/$/;"	m	struct:poller	access:private
fork_poller	include/proto/fd.h	/^int fork_poller();$/;"	p	signature:()
fork_poller	src/fd.c	/^int fork_poller()$/;"	f
found	src/proto_http.c	/^	int found = 0;$/;"	l
fport	include/import/ip_tproxy.h	/^	u_int16_t	fport;$/;"	m	struct:in_tproxy_addr	access:public
free	src/acl.c	/^			free(term);$/;"	p	file:
free	src/buffers.c	/^	int olen, free;$/;"	l
free_list	include/common/memory.h	/^	void **free_list;$/;"	m	struct:pool_head	access:public
free_pattern	src/acl.c	/^static void free_pattern(struct acl_pattern *pat)$/;"	f	file:	signature:(struct acl_pattern *pat)
free_pattern_list	src/acl.c	/^static void free_pattern_list(struct list *head)$/;"	f	file:	signature:(struct list *head)
free_pattern_tree	src/acl.c	/^static void free_pattern_tree(struct eb_root *root)$/;"	f	file:	signature:(struct eb_root *root)
freeptrbuf	include/types/acl.h	/^	void(*freeptrbuf)(void *ptr);	\/* a destructor able to free objects from the ptr *\/$/;"	m	struct:acl_pattern	access:public
freq_ctr	include/types/freq_ctr.h	/^struct freq_ctr {$/;"	s
freq_ctr::curr_ctr	include/types/freq_ctr.h	/^	unsigned int curr_ctr; \/* cumulated value for current period *\/$/;"	m	struct:freq_ctr	access:public
freq_ctr::curr_sec	include/types/freq_ctr.h	/^	unsigned int curr_sec; \/* start date of current period (seconds from now.tv_sec) *\/$/;"	m	struct:freq_ctr	access:public
freq_ctr::prev_ctr	include/types/freq_ctr.h	/^	unsigned int prev_ctr; \/* value for last period *\/$/;"	m	struct:freq_ctr	access:public
freq_ctr_remain	include/proto/freq_ctr.h	/^unsigned int freq_ctr_remain(struct freq_ctr *ctr, unsigned int freq, unsigned int pend);$/;"	p	signature:(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)
freq_ctr_remain	src/freq_ctr.c	/^unsigned int freq_ctr_remain(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)$/;"	f	signature:(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)
from	src/buffers.c	/^	char *from, *to;$/;"	l
from_addr	include/types/session.h	/^	struct sockaddr_in from_addr;		\/* the address to spoof when connecting to the server (transparent mode) *\/$/;"	m	struct:session	typeref:struct:session::sockaddr_in	access:public
frt_addr	include/types/session.h	/^	struct sockaddr_storage frt_addr;	\/* the frontend address reached by the client if SN_FRT_ADDR_SET is set *\/$/;"	m	struct:session	typeref:struct:session::sockaddr_storage	access:public
full	src/lb_fwrr.c	/^	struct server *srv, *full, *avoided;$/;"	l
fullconn	include/types/proxy.h	/^	unsigned int fullconn;			\/* #conns on backend above which servers are used at full load *\/$/;"	m	struct:proxy	access:public
fwd	src/buffers.c	/^		unsigned long fwd = len;$/;"	l
fwd	src/stream_sock.c	/^				unsigned long fwd = ret;$/;"	l
fwdfor_hdr_len	include/types/proxy.h	/^	int fwdfor_hdr_len;			\/* length of "x-forwarded-for" header *\/$/;"	m	struct:proxy	access:public
fwdfor_hdr_name	include/types/proxy.h	/^	char *fwdfor_hdr_name;			\/* header to use - default: "x-forwarded-for" *\/$/;"	m	struct:proxy	access:public
fwlc	include/types/backend.h	/^	struct lb_fwlc fwlc;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwlc	access:public
fwlc_dequeue_srv	src/lb_fwlc.c	/^static inline void fwlc_dequeue_srv(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwlc_get_next_server	include/proto/lb_fwlc.h	/^struct server *fwlc_get_next_server(struct proxy *p, struct server *srvtoavoid);$/;"	p	signature:(struct proxy *p, struct server *srvtoavoid)
fwlc_get_next_server	src/lb_fwlc.c	/^struct server *fwlc_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f	signature:(struct proxy *p, struct server *srvtoavoid)
fwlc_init_server_tree	include/proto/lb_fwlc.h	/^void fwlc_init_server_tree(struct proxy *p);$/;"	p	signature:(struct proxy *p)
fwlc_init_server_tree	src/lb_fwlc.c	/^void fwlc_init_server_tree(struct proxy *p)$/;"	f	signature:(struct proxy *p)
fwlc_queue_srv	src/lb_fwlc.c	/^static inline void fwlc_queue_srv(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwlc_remove_from_tree	src/lb_fwlc.c	/^static inline void fwlc_remove_from_tree(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwlc_set_server_status_down	src/lb_fwlc.c	/^static void fwlc_set_server_status_down(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
fwlc_set_server_status_up	src/lb_fwlc.c	/^static void fwlc_set_server_status_up(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
fwlc_srv_reposition	src/lb_fwlc.c	/^static void fwlc_srv_reposition(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwlc_update_server_weight	src/lb_fwlc.c	/^static void fwlc_update_server_weight(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
fwrr	include/types/backend.h	/^	struct lb_fwrr fwrr;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwrr	access:public
fwrr_dequeue_srv	src/lb_fwrr.c	/^static inline void fwrr_dequeue_srv(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwrr_dequeue_srv	src/lb_fwrr.c	/^static inline void fwrr_dequeue_srv(struct server *s);$/;"	p	file:	signature:(struct server *s)
fwrr_get_next_server	include/proto/lb_fwrr.h	/^struct server *fwrr_get_next_server(struct proxy *p, struct server *srvtoavoid);$/;"	p	signature:(struct proxy *p, struct server *srvtoavoid)
fwrr_get_next_server	src/lb_fwrr.c	/^struct server *fwrr_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f	signature:(struct proxy *p, struct server *srvtoavoid)
fwrr_get_server_from_group	src/lb_fwrr.c	/^static struct server *fwrr_get_server_from_group(struct fwrr_group *grp)$/;"	f	file:	signature:(struct fwrr_group *grp)
fwrr_get_srv	src/lb_fwrr.c	/^static void fwrr_get_srv(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwrr_get_srv	src/lb_fwrr.c	/^static void fwrr_get_srv(struct server *s);$/;"	p	file:	signature:(struct server *s)
fwrr_get_srv_down	src/lb_fwrr.c	/^static inline void fwrr_get_srv_down(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwrr_get_srv_init	src/lb_fwrr.c	/^static inline void fwrr_get_srv_init(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwrr_get_srv_next	src/lb_fwrr.c	/^static inline void fwrr_get_srv_next(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwrr_group	include/types/lb_fwrr.h	/^struct fwrr_group {$/;"	s
fwrr_group::curr	include/types/lb_fwrr.h	/^	struct eb_root curr;    \/* tree for servers in "current" time range *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root	access:public
fwrr_group::curr_pos	include/types/lb_fwrr.h	/^	int curr_pos;           \/* current position in the tree *\/$/;"	m	struct:fwrr_group	access:public
fwrr_group::curr_weight	include/types/lb_fwrr.h	/^	int curr_weight;        \/* total weight of the current time range *\/$/;"	m	struct:fwrr_group	access:public
fwrr_group::init	include/types/lb_fwrr.h	/^	struct eb_root *init;   \/* servers waiting to be placed *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root	access:public
fwrr_group::next	include/types/lb_fwrr.h	/^	struct eb_root *next;   \/* servers to be placed at next run *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root	access:public
fwrr_group::next_weight	include/types/lb_fwrr.h	/^	int next_weight;        \/* total weight of the next time range *\/$/;"	m	struct:fwrr_group	access:public
fwrr_group::t0	include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root	access:public
fwrr_group::t1	include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::	access:public
fwrr_init_server_groups	include/proto/lb_fwrr.h	/^void fwrr_init_server_groups(struct proxy *p);$/;"	p	signature:(struct proxy *p)
fwrr_init_server_groups	src/lb_fwrr.c	/^void fwrr_init_server_groups(struct proxy *p)$/;"	f	signature:(struct proxy *p)
fwrr_queue_by_weight	src/lb_fwrr.c	/^static inline void fwrr_queue_by_weight(struct eb_root *root, struct server *s)$/;"	f	file:	signature:(struct eb_root *root, struct server *s)
fwrr_queue_by_weight	src/lb_fwrr.c	/^static inline void fwrr_queue_by_weight(struct eb_root *root, struct server *s);$/;"	p	file:	signature:(struct eb_root *root, struct server *s)
fwrr_queue_srv	src/lb_fwrr.c	/^static void fwrr_queue_srv(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwrr_queue_srv	src/lb_fwrr.c	/^static void fwrr_queue_srv(struct server *s);$/;"	p	file:	signature:(struct server *s)
fwrr_remove_from_tree	src/lb_fwrr.c	/^static inline void fwrr_remove_from_tree(struct server *s)$/;"	f	file:	signature:(struct server *s)
fwrr_remove_from_tree	src/lb_fwrr.c	/^static inline void fwrr_remove_from_tree(struct server *s);$/;"	p	file:	signature:(struct server *s)
fwrr_set_server_status_down	src/lb_fwrr.c	/^static void fwrr_set_server_status_down(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
fwrr_set_server_status_up	src/lb_fwrr.c	/^static void fwrr_set_server_status_up(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
fwrr_switch_trees	src/lb_fwrr.c	/^static inline void fwrr_switch_trees(struct fwrr_group *grp)$/;"	f	file:	signature:(struct fwrr_group *grp)
fwrr_update_position	src/lb_fwrr.c	/^static inline void fwrr_update_position(struct fwrr_group *grp, struct server *s)$/;"	f	file:	signature:(struct fwrr_group *grp, struct server *s)
fwrr_update_server_weight	src/lb_fwrr.c	/^static void fwrr_update_server_weight(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
g	src/auth.c	/^	unsigned int g, group_mask = 0;$/;"	l
g	src/cfgparse.c	/^		int g;$/;"	l
get	examples/check	/^sub get$/;"	s
get	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range	access:public
get16bits	tests/test_hashes.c	150;"	d	file:
get16bits	tests/test_hashes.c	153;"	d	file:
get16bits	tests/test_hashes.c	157;"	d	file:
get16bits	tests/uri_hash.c	184;"	d	file:
get16bits	tests/uri_hash.c	187;"	d	file:
get16bits	tests/uri_hash.c	191;"	d	file:
getRawStat	examples/stats_haproxy.sh	/^getRawStat ()$/;"	f
getStat	examples/stats_haproxy.sh	/^getStat ()$/;"	f
get_analyze_status	src/checks.c	/^const char *get_analyze_status(short analyze_status) {$/;"	f	signature:(short analyze_status)
get_backend_server	include/proto/proxy.h	/^int get_backend_server(const char *bk_name, const char *sv_name,$/;"	p	signature:(const char *bk_name, const char *sv_name, struct proxy **bk, struct server **sv)
get_backend_server	src/proxy.c	/^int get_backend_server(const char *bk_name, const char *sv_name,$/;"	f	signature:(const char *bk_name, const char *sv_name, struct proxy **bk, struct server **sv)
get_bit	ebtree/ebtree.h	/^static forceinline int get_bit(const unsigned char *a, unsigned int pos)$/;"	f	signature:(const unsigned char *a, unsigned int pos)
get_check_status_description	include/proto/checks.h	/^const char *get_check_status_description(short check_status);$/;"	p	signature:(short check_status)
get_check_status_description	src/checks.c	/^const char *get_check_status_description(short check_status) {$/;"	f	signature:(short check_status)
get_check_status_info	include/proto/checks.h	/^const char *get_check_status_info(short check_status);$/;"	p	signature:(short check_status)
get_check_status_info	src/checks.c	/^const char *get_check_status_info(short check_status) {$/;"	f	signature:(short check_status)
get_frt_addr	include/proto/client.h	/^void get_frt_addr(struct session *s);$/;"	p	signature:(struct session *s)
get_frt_addr	src/client.c	/^void get_frt_addr(struct session *s)$/;"	f	signature:(struct session *s)
get_gmtime	include/common/standard.h	/^static inline void get_gmtime(const time_t now, struct tm *tm)$/;"	f	signature:(const time_t now, struct tm *tm)
get_http_auth	src/proto_http.c	/^get_http_auth(struct session *s)$/;"	f	signature:(struct session *s)
get_http_auth_buff	src/proto_http.c	/^char get_http_auth_buff[BUFSIZE];$/;"	v
get_ip_from_hdr2	include/proto/proto_http.h	/^unsigned int get_ip_from_hdr2(struct http_msg *msg, const char *hname, int hlen,$/;"	p	signature:(struct http_msg *msg, const char *hname, int hlen, struct hdr_idx *idx, int occ)
get_ip_from_hdr2	src/proto_http.c	/^unsigned int get_ip_from_hdr2(struct http_msg *msg, const char *hname, int hlen, struct hdr_idx *idx, int occ)$/;"	f	signature:(struct http_msg *msg, const char *hname, int hlen, struct hdr_idx *idx, int occ)
get_localtime	include/common/standard.h	/^static inline void get_localtime(const time_t now, struct tm *tm)$/;"	f	signature:(const time_t now, struct tm *tm)
get_log_facility	include/proto/log.h	/^int get_log_facility(const char *fac);$/;"	p	signature:(const char *fac)
get_log_facility	src/log.c	/^int get_log_facility(const char *fac)$/;"	f	signature:(const char *fac)
get_log_level	include/proto/log.h	/^int get_log_level(const char *lev);$/;"	p	signature:(const char *lev)
get_log_level	src/log.c	/^int get_log_level(const char *lev)$/;"	f	signature:(const char *lev)
get_next_id	include/common/standard.h	/^unsigned int get_next_id(struct eb_root *root, unsigned int key);$/;"	p	signature:(struct eb_root *root, unsigned int key)
get_next_id	src/standard.c	/^unsigned int get_next_id(struct eb_root *root, unsigned int key)$/;"	f	signature:(struct eb_root *root, unsigned int key)
get_next_server	tests/filltab25.c	/^struct srv *get_next_server() {$/;"	f
get_original_dst	include/proto/stream_sock.h	/^static inline int get_original_dst(int fd, struct sockaddr_in *sa, socklen_t *salen) {$/;"	f	signature:(int fd, struct sockaddr_in *sa, socklen_t *salen)
get_pipe	include/proto/pipe.h	/^struct pipe *get_pipe();$/;"	p	signature:()
get_pipe	src/pipe.c	/^struct pipe *get_pipe()$/;"	f
get_server_hh	src/backend.c	/^struct server *get_server_hh(struct session *s)$/;"	f	signature:(struct session *s)
get_server_ph	src/backend.c	/^struct server *get_server_ph(struct proxy *px, const char *uri, int uri_len)$/;"	f	signature:(struct proxy *px, const char *uri, int uri_len)
get_server_ph_post	src/backend.c	/^struct server *get_server_ph_post(struct session *s)$/;"	f	signature:(struct session *s)
get_server_rch	src/backend.c	/^struct server *get_server_rch(struct session *s)$/;"	f	signature:(struct session *s)
get_server_sh	include/proto/backend.h	/^struct server *get_server_sh(struct proxy *px, const char *addr, int len);$/;"	p	signature:(struct proxy *px, const char *addr, int len)
get_server_sh	src/backend.c	/^struct server *get_server_sh(struct proxy *px, const char *addr, int len)$/;"	f	signature:(struct proxy *px, const char *addr, int len)
get_server_uh	include/proto/backend.h	/^struct server *get_server_uh(struct proxy *px, char *uri, int uri_len);$/;"	p	signature:(struct proxy *px, char *uri, int uri_len)
get_server_uh	src/backend.c	/^struct server *get_server_uh(struct proxy *px, char *uri, int uri_len)$/;"	f	signature:(struct proxy *px, char *uri, int uri_len)
get_srv	tests/filltab25.c	/^void get_srv(struct srv *s) {$/;"	f	signature:(struct srv *s)
get_srv_down	tests/filltab25.c	/^static inline void get_srv_down(struct srv *s) {$/;"	f	file:	signature:(struct srv *s)
get_srv_from_appsession	include/proto/proto_http.h	/^void get_srv_from_appsession(struct session *t, const char *begin, int len);$/;"	p	signature:(struct session *t, const char *begin, int len)
get_srv_from_appsession	src/proto_http.c	/^void get_srv_from_appsession(struct session *t, const char *begin, int len)$/;"	f	signature:(struct session *t, const char *begin, int len)
get_srv_init	tests/filltab25.c	/^static inline void get_srv_init(struct srv *s) {$/;"	f	file:	signature:(struct srv *s)
get_srv_next	tests/filltab25.c	/^static inline void get_srv_next(struct srv *s) {$/;"	f	file:	signature:(struct srv *s)
get_trash_chunk	src/pattern.c	/^static struct chunk *get_trash_chunk(void)$/;"	f	file:	signature:(void)
gid	include/types/global.h	/^	int gid;$/;"	m	struct:global	access:public
gid	include/types/protocols.h	/^			gid_t gid;	\/* -1 to leave unchanged *\/$/;"	m	struct:listener::__anon23::__anon24	access:public
global	include/types/global.h	/^extern struct global global;$/;"	x
global	include/types/global.h	/^struct global {$/;"	s
global	src/haproxy.c	/^struct global global = {$/;"	v	typeref:struct:global
global::__anon16::bufsize	include/types/global.h	/^		int bufsize;       \/* buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::chksize	include/types/global.h	/^		int chksize;       \/* check buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::client_rcvbuf	include/types/global.h	/^		int client_rcvbuf; \/* set client rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::client_sndbuf	include/types/global.h	/^		int client_sndbuf; \/* set client sndbuf to this value if not null *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::maxaccept	include/types/global.h	/^		int maxaccept;     \/* max number of consecutive accept() *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::maxpollevents	include/types/global.h	/^		int maxpollevents; \/* max number of poll events at once *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::maxrewrite	include/types/global.h	/^		int maxrewrite;    \/* buffer max rewrite size in bytes, defaults to MAXREWRITE *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::options	include/types/global.h	/^		int options;       \/* various tuning options *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::recv_enough	include/types/global.h	/^		int recv_enough;   \/* how many input bytes at once are "enough" *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::server_rcvbuf	include/types/global.h	/^		int server_rcvbuf; \/* set server rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon16	access:public
global::__anon16::server_sndbuf	include/types/global.h	/^		int server_sndbuf; \/* set server sndbuf to this value if not null *\/$/;"	m	struct:global::__anon16	access:public
global::chroot	include/types/global.h	/^	char *chroot;$/;"	m	struct:global	access:public
global::desc	include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global	access:public
global::gid	include/types/global.h	/^	int gid;$/;"	m	struct:global	access:public
global::last_checks	include/types/global.h	/^	int last_checks;$/;"	m	struct:global	access:public
global::logfac1	include/types/global.h	/^	int logfac1, logfac2;$/;"	m	struct:global	access:public
global::logfac2	include/types/global.h	/^	int logfac1, logfac2;$/;"	m	struct:global	access:public
global::loglev1	include/types/global.h	/^	int loglev1, loglev2;$/;"	m	struct:global	access:public
global::loglev2	include/types/global.h	/^	int loglev1, loglev2;$/;"	m	struct:global	access:public
global::logsrv1	include/types/global.h	/^	struct logsrv logsrv1, logsrv2;$/;"	m	struct:global	typeref:struct:global::logsrv	access:public
global::logsrv2	include/types/global.h	/^	struct logsrv logsrv1, logsrv2;$/;"	m	struct:global	typeref:struct:global::	access:public
global::maxconn	include/types/global.h	/^	int maxconn;$/;"	m	struct:global	access:public
global::maxpipes	include/types/global.h	/^	int maxpipes;		\/* max # of pipes *\/$/;"	m	struct:global	access:public
global::maxsock	include/types/global.h	/^	int maxsock;		\/* max # of sockets *\/$/;"	m	struct:global	access:public
global::minlvl1	include/types/global.h	/^	int minlvl1, minlvl2;$/;"	m	struct:global	access:public
global::minlvl2	include/types/global.h	/^	int minlvl1, minlvl2;$/;"	m	struct:global	access:public
global::mode	include/types/global.h	/^	int mode;$/;"	m	struct:global	access:public
global::nbproc	include/types/global.h	/^	int nbproc;$/;"	m	struct:global	access:public
global::node	include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global	access:public
global::pidfile	include/types/global.h	/^	char *pidfile;$/;"	m	struct:global	access:public
global::rlimit_memmax	include/types/global.h	/^	int rlimit_memmax;	\/* default ulimit-d in megs value : 0=unset *\/$/;"	m	struct:global	access:public
global::rlimit_nofile	include/types/global.h	/^	int rlimit_nofile;	\/* default ulimit-n value : 0=unset *\/$/;"	m	struct:global	access:public
global::spread_checks	include/types/global.h	/^	int spread_checks;$/;"	m	struct:global	access:public
global::stats_fe	include/types/global.h	/^	struct proxy *stats_fe;     \/* the frontend holding the stats settings *\/$/;"	m	struct:global	typeref:struct:global::proxy	access:public
global::stats_sock	include/types/global.h	/^	struct listener stats_sock; \/* unix socket listener for statistics *\/$/;"	m	struct:global	typeref:struct:global::listener	access:public
global::tune	include/types/global.h	/^	} tune;$/;"	m	struct:global	typeref:struct:global::__anon16	access:public
global::uid	include/types/global.h	/^	int uid;$/;"	m	struct:global	access:public
gmt_time	src/checks.c	/^				int gmt_time = htonl(date.tv_sec);$/;"	l
gparent	ebtree/ebtree.h	/^	struct eb_root *gparent;$/;"	l
gparent	src/rbtree.c	/^	struct rb_node *parent, *gparent;$/;"	l
gpside	ebtree/ebtree.h	/^	unsigned int pside, gpside, sibtype;$/;"	l
grace	include/types/proxy.h	/^	int grace;				\/* grace time after stop request *\/$/;"	m	struct:proxy	access:public
group	src/auth.c	/^	char *group = NULL;$/;"	l
group	src/cfgparse.c	/^			char *group = NULL;$/;"	l
group	src/dumpstats.c	/^				struct group *group;$/;"	l
group_mask	include/types/acl.h	/^		unsigned int group_mask;$/;"	m	union:acl_pattern::__anon49	access:public
group_mask	include/types/auth.h	/^		unsigned int group_mask;$/;"	m	union:auth_users::__anon28	access:public
group_mask	src/auth.c	/^	unsigned int g, group_mask = 0;$/;"	l
group_mask	src/auth.c	/^	unsigned int group_mask;$/;"	l
group_mask	src/cfgparse.c	/^			unsigned int group_mask = 0;$/;"	l
groups	include/types/auth.h	/^		char *groups;$/;"	m	union:auth_users::__anon28	access:public
groups	include/types/auth.h	/^	char *groups[MAX_AUTH_GROUPS];$/;"	m	struct:userlist	access:public
groupusers	include/types/auth.h	/^	char **groupusers;$/;"	m	struct:userlist	access:public
grp	src/lb_fwrr.c	/^	struct fwrr_group *grp = (s->state & SRV_BACKUP) ?$/;"	l
grp	src/lb_fwrr.c	/^	struct fwrr_group *grp;$/;"	l
grpcnt	include/types/auth.h	/^	int grpcnt;$/;"	m	struct:userlist	access:public
h	contrib/halog/halog.c	/^			unsigned int d, h, m, s, ms;$/;"	l
h	contrib/halog/halog.c	/^	unsigned int h, m, s, ms;$/;"	l
h	ebtree/ebtree.h	/^	unsigned int h;$/;"	l
h	src/backend.c	/^	unsigned int h, l;$/;"	l
h	src/haproxy.c	/^	struct cap_hdr *h,*h_next;$/;"	l
h	src/proto_http.c	/^		struct cap_hdr *h;$/;"	l
h	src/proto_http.c	/^	char *h, *p;$/;"	l
h	src/proto_http.c	/^	char *h;$/;"	l
h	src/proto_http.c	/^	char *uri, *h;$/;"	l
h	src/proto_http.c	/^	const struct http_method_desc *h;$/;"	l
h	src/proto_http.c	/^	struct cap_hdr *h;$/;"	l
h	src/sessionhash.c	/^	unsigned int h = 5381;$/;"	l
h	tests/sessionhash_test.c	/^	struct appsession_hash h;$/;"	l
h	tests/test_hashes.c	/^  unsigned h = 0;$/;"	l
h	tests/test_hashes.c	/^  unsigned h = 0x783c965aUL;$/;"	l
h	tests/test_hashes.c	/^  unsigned h = 2166136261;$/;"	l
h	tests/test_hashes.c	/^  unsigned int h, l;$/;"	l
h	tests/uri_hash.c	/^  unsigned int h, l;$/;"	l
h1	include/types/acl.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:acl_time	access:public
h2	include/types/acl.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:acl_time	access:public
h_next	src/haproxy.c	/^	struct cap_hdr *h,*h_next;$/;"	l
ha_group	src/cfgparse.c	/^		struct group *ha_group;$/;"	l
ha_user	src/cfgparse.c	/^		struct passwd *ha_user;$/;"	l
handler	include/types/protocols.h	/^	struct task * (*handler)(struct task *t); \/* protocol handler. It is a task *\/$/;"	m	struct:listener	typeref:struct:listener::handler	access:public
handler	include/types/signal.h	/^	void (*handler)(int sig);$/;"	m	struct:signal_descriptor	access:public
handler	src/signal.c	/^				desc->handler(sig);$/;"	p	file:
haproxy_info	contrib/netsnmp-perl/haproxy.pl	/^sub haproxy_info {$/;"	s
haproxy_server_hash	tests/test_hashes.c	/^unsigned int haproxy_server_hash(const char *addr, int len){$/;"	f	signature:(const char *addr, int len)
haproxy_server_hash	tests/uri_hash.c	/^	count_hash_results(haproxy_server_hash(line, strlen(line)), counts_srv);$/;"	p	file:	signature:(line, strlen(line))
haproxy_server_hash	tests/uri_hash.c	/^unsigned int haproxy_server_hash(const char *addr, int len){$/;"	f	signature:(const char *addr, int len)
haproxy_stat	contrib/netsnmp-perl/haproxy.pl	/^sub haproxy_stat {$/;"	s
haproxy_uri_hash	tests/test_hashes.c	/^unsigned long haproxy_uri_hash(char *uri, int uri_len){$/;"	f	signature:(char *uri, int uri_len)
has_zero	contrib/halog/fgets2-64.c	/^static inline unsigned int has_zero(unsigned int x)$/;"	f	file:	signature:(unsigned int x)
has_zero	contrib/halog/fgets2.c	/^static inline unsigned int has_zero(unsigned int x)$/;"	f	file:	signature:(unsigned int x)
has_zero64	contrib/halog/fgets2-64.c	/^static inline unsigned int has_zero64(unsigned long long x)$/;"	f	file:	signature:(unsigned long long x)
hash	src/backend.c	/^	unsigned long    hash = 0;$/;"	l
hash	src/backend.c	/^	unsigned long hash = 0;$/;"	l
hash	tests/test_hashes.c	/^    register unsigned long hash = 5381;$/;"	l
hash	tests/test_hashes.c	/^  ub4 hash = level;$/;"	l
hash	tests/test_hashes.c	/^  unsigned long hash = 0;$/;"	l
hash	tests/test_hashes.c	/^uint32_t hash = len, tmp;$/;"	l
hash	tests/uri_hash.c	/^    unsigned long hash = 0;$/;"	l
hash	tests/uri_hash.c	/^uint32_t hash = len, tmp;$/;"	l
hash_bj6	tests/ip-hash.c	/^		count_hash_results(hash_bj6(address & mask), counts_bj6);  \/\/ 1.07s \/ 100M$/;"	p	file:	signature:(address & mask)
hash_bj6	tests/ip-hash.c	/^uint32_t hash_bj6(uint32_t a)$/;"	f	signature:(uint32_t a)
hash_bj7	tests/ip-hash.c	/^		count_hash_results(hash_bj7(address & mask), counts_bj7);  \/\/ 1.20s \/ 100M$/;"	p	file:	signature:(address & mask)
hash_bj7	tests/ip-hash.c	/^uint32_t hash_bj7(uint32_t a)$/;"	f	signature:(uint32_t a)
hash_djbx33	tests/test_hashes.c	/^hash_djbx33($/;"	f	file:	signature:( register unsigned char *key, register size_t len)
hash_gd1	tests/uri_hash.c	/^	count_hash_results(hash_gd1(line), counts_gd1);$/;"	p	file:
hash_gd1	tests/uri_hash.c	/^static unsigned long hash_gd1(char *uri)$/;"	f	file:	signature:(char *uri)
hash_gd2	tests/uri_hash.c	/^	count_hash_results(hash_gd2(line), counts_gd2);$/;"	p	file:
hash_gd2	tests/uri_hash.c	/^static unsigned long hash_gd2(char *uri)$/;"	f	file:	signature:(char *uri)
hash_gd3	tests/uri_hash.c	/^	count_hash_results(hash_gd3(line), counts_gd3);$/;"	p	file:
hash_gd3	tests/uri_hash.c	/^static unsigned long hash_gd3(char *uri)$/;"	f	file:	signature:(char *uri)
hash_gd4	tests/uri_hash.c	/^	count_hash_results(hash_gd4(line), counts_gd4);$/;"	p	file:
hash_gd4	tests/uri_hash.c	/^static unsigned long hash_gd4(char *uri)$/;"	f	file:	signature:(char *uri)
hash_gd5	tests/uri_hash.c	/^	count_hash_results(hash_gd5(line), counts_gd5);$/;"	p	file:
hash_gd5	tests/uri_hash.c	/^static unsigned long hash_gd5(char *uri)$/;"	f	file:	signature:(char *uri)
hash_gd6	tests/uri_hash.c	/^	count_hash_results(hash_gd6(line), counts_gd6);$/;"	p	file:
hash_gd6	tests/uri_hash.c	/^static unsigned long hash_gd6(char *uri)$/;"	f	file:	signature:(char *uri)
hash_id	tests/ip-hash.c	/^		count_hash_results(hash_id (address & mask), counts_id);   \/\/ 0.69s \/ 100M$/;"	p	file:	signature:(address & mask)
hash_id	tests/ip-hash.c	/^uint32_t hash_id( uint32_t a)$/;"	f	signature:( uint32_t a)
hash_list	include/common/appsession.h	/^	struct list hash_list;$/;"	m	struct:appsessions	typeref:struct:appsessions::list	access:public
hash_tw1	tests/ip-hash.c	/^		count_hash_results(hash_tw1(address & mask), counts_tw1);  \/\/ 1.04s \/ 100M$/;"	p	file:	signature:(address & mask)
hash_tw1	tests/ip-hash.c	/^uint32_t hash_tw1(uint32_t a)$/;"	f	signature:(uint32_t a)
hash_tw2	tests/ip-hash.c	/^		count_hash_results(hash_tw2(address & mask), counts_tw2);  \/\/ 1.13s \/ 100M$/;"	p	file:	signature:(address & mask)
hash_tw2	tests/ip-hash.c	/^uint32_t hash_tw2(uint32_t a)$/;"	f	signature:(uint32_t a)
hash_tw3	tests/ip-hash.c	/^		count_hash_results(hash_tw3(address & mask), counts_tw3);  \/\/ 1.01s \/ 100M$/;"	p	file:	signature:(address & mask)
hash_tw3	tests/ip-hash.c	/^uint32_t hash_tw3(uint32_t a)$/;"	f	signature:(uint32_t a)
hash_wt1	tests/uri_hash.c	/^static unsigned long hash_wt1(int hsize, char *string) {$/;"	f	file:	signature:(int hsize, char *string)
hash_wt2	tests/uri_hash.c	/^	count_hash_results(hash_wt2(line, strlen(line)), counts_wt2);$/;"	p	file:	signature:(line, strlen(line))
hash_wt2	tests/uri_hash.c	/^int hash_wt2(const char *src, int len) {$/;"	f	signature:(const char *src, int len)
hashpjw	tests/test_hashes.c	/^int hashpjw(const void *key) {$/;"	f	signature:(const void *key)
hashval	tests/test_hashes.c	/^  unsigned hashval;$/;"	l
hashword	tests/test_hashes.c	/^uint32_t hashword($/;"	f	signature:( const uint32_t *k, size_t length, uint32_t initval)
have_appsession	include/common/appsession.h	/^extern int have_appsession;$/;"	x
have_appsession	src/appsession.c	/^int have_appsession;$/;"	v
hdr	src/cfgparse.c	/^			struct cap_hdr *hdr;$/;"	l
hdr	src/proto_http.c	/^	int hdr;$/;"	l
hdr	src/proto_http.c	/^	struct hdr_idx_elem *hdr;$/;"	l
hdr_beg	src/proto_http.c	/^	char *hdr_beg, *hdr_end, *hdr_next, *del_from;$/;"	l
hdr_beg	src/proto_http.c	/^	char *hdr_beg, *hdr_end, *hdr_next;$/;"	l
hdr_content_len	include/types/proto_http.h	/^	unsigned long long hdr_content_len;    \/* cache for parsed header value or for chunk-size if present *\/$/;"	m	struct:http_msg	access:public
hdr_ctx	include/types/proto_http.h	/^struct hdr_ctx {$/;"	s
hdr_ctx::del	include/types/proto_http.h	/^	int  del;  \/* relative to line *\/$/;"	m	struct:hdr_ctx	access:public
hdr_ctx::idx	include/types/proto_http.h	/^	int  idx;$/;"	m	struct:hdr_ctx	access:public
hdr_ctx::line	include/types/proto_http.h	/^	char *line;$/;"	m	struct:hdr_ctx	access:public
hdr_ctx::prev	include/types/proto_http.h	/^	int  prev; \/* index of previous header *\/$/;"	m	struct:hdr_ctx	access:public
hdr_ctx::val	include/types/proto_http.h	/^	int  val;  \/* relative to line *\/$/;"	m	struct:hdr_ctx	access:public
hdr_ctx::vlen	include/types/proto_http.h	/^	int  vlen; \/* relative to line+val *\/$/;"	m	struct:hdr_ctx	access:public
hdr_encode_map	src/proto_http.c	/^fd_set hdr_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
hdr_end	src/proto_http.c	/^	char *hdr_beg, *hdr_end, *hdr_next, *del_from;$/;"	l
hdr_end	src/proto_http.c	/^	char *hdr_beg, *hdr_end, *hdr_next;$/;"	l
hdr_exp	include/common/regex.h	/^struct hdr_exp {$/;"	s
hdr_exp::action	include/common/regex.h	/^    int action;				\/* ACT_ALLOW, ACT_REPLACE, ACT_REMOVE, ACT_DENY *\/$/;"	m	struct:hdr_exp	access:public
hdr_exp::cond	include/common/regex.h	/^    void *cond;				\/* a possible condition or NULL *\/$/;"	m	struct:hdr_exp	access:public
hdr_exp::next	include/common/regex.h	/^    struct hdr_exp *next;$/;"	m	struct:hdr_exp	typeref:struct:hdr_exp::hdr_exp	access:public
hdr_exp::preg	include/common/regex.h	/^    const regex_t *preg;		\/* expression to look for *\/$/;"	m	struct:hdr_exp	access:public
hdr_exp::replace	include/common/regex.h	/^    const char *replace;		\/* expression to set instead *\/$/;"	m	struct:hdr_exp	access:public
hdr_hist	src/proto_http.c	/^	unsigned int hdr_hist[MAX_HDR_HISTORY];$/;"	l
hdr_idx	include/types/hdr_idx.h	/^struct hdr_idx {$/;"	s
hdr_idx	include/types/proto_http.h	/^	struct hdr_idx hdr_idx;         \/* array of header indexes (max: MAX_HTTP_HDR) *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::hdr_idx	access:public
hdr_idx::last	include/types/hdr_idx.h	/^	short last;                 \/* length of the allocated area (1..size) *\/$/;"	m	struct:hdr_idx	access:public
hdr_idx::size	include/types/hdr_idx.h	/^	short size;                 \/* size of the array including the head *\/$/;"	m	struct:hdr_idx	access:public
hdr_idx::tail	include/types/hdr_idx.h	/^	signed short tail;          \/* last used element, 0..size-1 *\/$/;"	m	struct:hdr_idx	access:public
hdr_idx::used	include/types/hdr_idx.h	/^	short used;                 \/* # of elements really used (1..size) *\/$/;"	m	struct:hdr_idx	access:public
hdr_idx::v	include/types/hdr_idx.h	/^	struct hdr_idx_elem *v;     \/* the array itself *\/$/;"	m	struct:hdr_idx	typeref:struct:hdr_idx::hdr_idx_elem	access:public
hdr_idx_add	include/proto/hdr_idx.h	/^int hdr_idx_add(int len, int cr, struct hdr_idx *list, int after);$/;"	p	signature:(int len, int cr, struct hdr_idx *list, int after)
hdr_idx_add	src/hdr_idx.c	/^int hdr_idx_add(int len, int cr, struct hdr_idx *list, int after)$/;"	f	signature:(int len, int cr, struct hdr_idx *list, int after)
hdr_idx_elem	include/types/hdr_idx.h	/^struct hdr_idx_elem {$/;"	s
hdr_idx_elem::cr	include/types/hdr_idx.h	/^        unsigned cr   : 1; \/* CR present (1=CRLF, 0=LF). Total line size=len+cr+1. *\/$/;"	m	struct:hdr_idx_elem	access:public
hdr_idx_elem::len	include/types/hdr_idx.h	/^        unsigned len  :16; \/* length of this header not counting CRLF. 0=unused entry. *\/$/;"	m	struct:hdr_idx_elem	access:public
hdr_idx_elem::next	include/types/hdr_idx.h	/^        unsigned next :15; \/* offset of next header if len>0. 0=end of list. *\/$/;"	m	struct:hdr_idx_elem	access:public
hdr_idx_first_idx	include/proto/hdr_idx.h	/^static inline int hdr_idx_first_idx(struct hdr_idx *list)$/;"	f	signature:(struct hdr_idx *list)
hdr_idx_first_pos	include/proto/hdr_idx.h	/^static inline int hdr_idx_first_pos(struct hdr_idx *list)$/;"	f	signature:(struct hdr_idx *list)
hdr_idx_init	include/proto/hdr_idx.h	/^static inline void hdr_idx_init(struct hdr_idx *list)$/;"	f	signature:(struct hdr_idx *list)
hdr_idx_pool	include/types/proxy.h	/^	struct pool_head *hdr_idx_pool;         \/* pools of pre-allocated int* used for headers indexing *\/$/;"	m	struct:proxy	typeref:struct:proxy::pool_head	access:public
hdr_idx_set_start	include/proto/hdr_idx.h	/^static inline void hdr_idx_set_start(struct hdr_idx *list, int len, int cr)$/;"	f	signature:(struct hdr_idx *list, int len, int cr)
hdr_len	src/log.c	/^	int hdr_len, data_len;$/;"	l
hdr_len	src/proto_http.c	/^	int hdr_len = 10;$/;"	l
hdr_next	src/proto_http.c	/^	char *hdr_beg, *hdr_end, *hdr_next, *del_from;$/;"	l
hdr_next	src/proto_http.c	/^	char *hdr_beg, *hdr_end, *hdr_next;$/;"	l
hdr_val	src/proto_http.c	/^	const char *hdr_val = "Connection";$/;"	l
he	src/cfgparse.c	/^				struct hostent *he;$/;"	l
he	src/standard.c	/^		struct hostent *he = gethostbyname(str);$/;"	l
he	src/standard.c	/^		struct hostent *he;$/;"	l
head	ebtree/ebtree.h	/^	struct eb_node *head = sub;$/;"	l
health	include/types/server.h	/^	int health;				\/* 0->rise-1 = bad; rise->rise+fall-1 = good *\/$/;"	m	struct:server	access:public
health	src/checks.c	/^		int health, rise, fall, state;$/;"	l
health_adjust	include/proto/checks.h	/^void health_adjust(struct server *s, short status);$/;"	p	signature:(struct server *s, short status)
health_adjust	src/checks.c	/^void health_adjust(struct server *s, short status) {$/;"	f	signature:(struct server *s, short status)
hex1	src/cfgparse.c	/^						unsigned char hex1, hex2;$/;"	l
hex1	src/regex.c	/^				unsigned char hex1, hex2;$/;"	l
hex2	src/cfgparse.c	/^						unsigned char hex1, hex2;$/;"	l
hex2	src/regex.c	/^				unsigned char hex1, hex2;$/;"	l
hex2i	include/common/standard.h	/^extern int hex2i(int c);$/;"	p	signature:(int c)
hex2i	src/standard.c	/^int hex2i(int c)$/;"	f	signature:(int c)
hextab	include/common/standard.h	/^extern const char hextab[];$/;"	x
hextab	src/standard.c	/^const char hextab[16] = "0123456789ABCDEF";$/;"	v
hh_len	include/types/proxy.h	/^	int  hh_len;				\/* strlen(hh_name), computed only once *\/$/;"	m	struct:proxy	access:public
hh_match_domain	include/types/proxy.h	/^	int  hh_match_domain;			\/* toggle use of special match function *\/$/;"	m	struct:proxy	access:public
hh_name	include/types/proxy.h	/^	char *hh_name;				\/* name of the header parameter used for hashing *\/$/;"	m	struct:proxy	access:public
high	contrib/halog/halog.c	/^	int high;$/;"	l
hijacker	include/types/buffers.h	/^	void (*hijacker)(struct session *, struct buffer *); \/* alternative content producer *\/$/;"	m	struct:buffer	access:public
hist_ptr	src/proto_http.c	/^	unsigned int hist_ptr;$/;"	l
hlen	src/checks.c	/^	int hlen = 0;$/;"	l
hostname	include/types/global.h	/^extern char hostname[MAX_HOSTNAME_LEN];$/;"	x
hostname	src/haproxy.c	/^char hostname[MAX_HOSTNAME_LEN];$/;"	v
hsize	tests/uri_hash.c	/^            data >>= hsize;$/;"	l
htbl	src/appsession.c	/^	struct appsession_hash *htbl;$/;"	l
htbl_proxy	include/types/proxy.h	/^	struct appsession_hash htbl_proxy;	\/* Per Proxy hashtable *\/$/;"	m	struct:proxy	typeref:struct:proxy::appsession_hash	access:public
http	include/types/counters.h	/^		} http;$/;"	m	union:pxcounters::__anon58	typeref:struct:pxcounters::__anon58::__anon59	access:public
http	include/types/counters.h	/^		} http;$/;"	m	union:srvcounters::__anon60	typeref:struct:srvcounters::__anon60::__anon61	access:public
http_100_chunk	src/proto_http.c	/^const struct chunk http_100_chunk = {$/;"	v	typeref:struct:chunk
http_200_chunk	src/proto_http.c	/^const struct chunk http_200_chunk = {$/;"	v	typeref:struct:chunk
http_auth	include/types/auth.h	/^	} http_auth;$/;"	m	struct:req_acl_rule	typeref:struct:req_acl_rule::__anon27	access:public
http_auth_data	include/types/proto_http.h	/^struct http_auth_data {$/;"	s
http_auth_data::method	include/types/proto_http.h	/^	int method;			\/* one of HTTP_AUTH_* *\/$/;"	m	struct:http_auth_data	access:public
http_auth_data::method_data	include/types/proto_http.h	/^	struct chunk method_data;	\/* points to the creditial part from 'Authorization:' header *\/$/;"	m	struct:http_auth_data	typeref:struct:http_auth_data::chunk	access:public
http_auth_data::pass	include/types/proto_http.h	/^	char *user, *pass;		\/* extracted username & password *\/$/;"	m	struct:http_auth_data	access:public
http_auth_data::user	include/types/proto_http.h	/^	char *user, *pass;		\/* extracted username & password *\/$/;"	m	struct:http_auth_data	access:public
http_buffer_heavy_realign	src/proto_http.c	/^void http_buffer_heavy_realign(struct buffer *buf, struct http_msg *msg)$/;"	f	signature:(struct buffer *buf, struct http_msg *msg)
http_capture_bad_message	include/proto/proto_http.h	/^void http_capture_bad_message(struct error_snapshot *es, struct session *s,$/;"	p	signature:(struct error_snapshot *es, struct session *s, struct buffer *buf, struct http_msg *msg, struct proxy *other_end)
http_capture_bad_message	src/proto_http.c	/^void http_capture_bad_message(struct error_snapshot *es, struct session *s,$/;"	f	signature:(struct error_snapshot *es, struct session *s, struct buffer *buf, struct http_msg *msg, struct proxy *other_end)
http_change_connection_header	src/proto_http.c	/^void http_change_connection_header(struct http_txn *txn, struct http_msg *msg, struct buffer *buf, int wanted)$/;"	f	signature:(struct http_txn *txn, struct http_msg *msg, struct buffer *buf, int wanted)
http_code	src/standard.c	/^	unsigned int http_code = 0;$/;"	l
http_end_txn	include/proto/proto_http.h	/^void http_end_txn(struct session *s);$/;"	p	signature:(struct session *s)
http_end_txn	src/proto_http.c	/^void http_end_txn(struct session *s)$/;"	f	signature:(struct session *s)
http_end_txn_clean_session	src/proto_http.c	/^void http_end_txn_clean_session(struct session *s)$/;"	f	signature:(struct session *s)
http_err_chunks	include/proto/httperr.h	/^extern struct chunk http_err_chunks[HTTP_ERR_SIZE];$/;"	x
http_err_chunks	src/proto_http.c	/^struct chunk http_err_chunks[HTTP_ERR_SIZE];$/;"	v	typeref:struct:chunk
http_err_codes	include/proto/httperr.h	/^extern const int http_err_codes[HTTP_ERR_SIZE];$/;"	x
http_err_codes	src/proto_http.c	/^const int http_err_codes[HTTP_ERR_SIZE] = {$/;"	v
http_err_msgs	src/proto_http.c	/^static const char *http_err_msgs[HTTP_ERR_SIZE] = {$/;"	v	file:
http_find_header	src/proto_http.c	/^int http_find_header(const char *name,$/;"	f	signature:(const char *name, char *sol, struct hdr_idx *idx, struct hdr_ctx *ctx)
http_find_header2	include/proto/proto_http.h	/^int http_find_header2(const char *name, int len,$/;"	p	signature:(const char *name, int len, char *sol, struct hdr_idx *idx, struct hdr_ctx *ctx)
http_find_header2	src/proto_http.c	/^int http_find_header2(const char *name, int len,$/;"	f	signature:(const char *name, int len, char *sol, struct hdr_idx *idx, struct hdr_ctx *ctx)
http_forward_trailers	src/proto_http.c	/^int http_forward_trailers(struct buffer *buf, struct http_msg *msg)$/;"	f	signature:(struct buffer *buf, struct http_msg *msg)
http_get_path	src/proto_http.c	/^http_get_path(struct http_txn *txn)$/;"	f	file:	signature:(struct http_txn *txn)
http_header_add_tail	src/proto_http.c	/^int http_header_add_tail(struct buffer *b, struct http_msg *msg,$/;"	f	signature:(struct buffer *b, struct http_msg *msg, struct hdr_idx *hdr_idx, const char *text)
http_header_add_tail2	src/proto_http.c	/^int http_header_add_tail2(struct buffer *b, struct http_msg *msg,$/;"	f	signature:(struct buffer *b, struct http_msg *msg, struct hdr_idx *hdr_idx, const char *text, int len)
http_header_match2	src/proto_http.c	/^int http_header_match2(const char *hdr, const char *end,$/;"	f	signature:(const char *hdr, const char *end, const char *name, int len)
http_init_txn	include/proto/proto_http.h	/^void http_init_txn(struct session *s);$/;"	p	signature:(struct session *s)
http_init_txn	src/proto_http.c	/^void http_init_txn(struct session *s)$/;"	f	signature:(struct session *s)
http_is_crlf	include/proto/proto_http.h	/^extern const char http_is_crlf[256];$/;"	x
http_is_crlf	src/proto_http.c	/^const char http_is_crlf[256] = {$/;"	v
http_is_ctl	include/proto/proto_http.h	/^extern const char http_is_ctl[256];$/;"	x
http_is_ctl	src/proto_http.c	/^const char http_is_ctl[256] = {$/;"	v
http_is_lws	include/proto/proto_http.h	/^extern const char http_is_lws[256];$/;"	x
http_is_lws	src/proto_http.c	/^const char http_is_lws[256] = {$/;"	v
http_is_sep	include/proto/proto_http.h	/^extern const char http_is_sep[256];$/;"	x
http_is_sep	src/proto_http.c	/^const char http_is_sep[256] = {$/;"	v
http_is_spht	include/proto/proto_http.h	/^extern const char http_is_spht[256];$/;"	x
http_is_spht	src/proto_http.c	/^const char http_is_spht[256] = {$/;"	v
http_is_token	include/proto/proto_http.h	/^extern const char http_is_token[256];$/;"	x
http_is_token	src/proto_http.c	/^const char http_is_token[256] = {$/;"	v
http_is_ver_token	include/proto/proto_http.h	/^extern const char http_is_ver_token[256];$/;"	x
http_is_ver_token	src/proto_http.c	/^const char http_is_ver_token[256] = {$/;"	v
http_meth_t	include/types/proto_http.h	/^} http_meth_t;$/;"	t	typeref:enum:__anon34
http_method_desc	src/proto_http.c	/^struct http_method_desc {$/;"	s	file:
http_method_desc::len	src/proto_http.c	/^	int len;$/;"	m	struct:http_method_desc	file:	access:public
http_method_desc::meth	src/proto_http.c	/^	http_meth_t meth;$/;"	m	struct:http_method_desc	file:	access:public
http_method_desc::text	src/proto_http.c	/^	const char text[8];$/;"	m	struct:http_method_desc	file:	access:public
http_methods	src/proto_http.c	/^const struct http_method_desc http_methods[26][3] = {$/;"	v	typeref:struct:http_method_desc
http_msg	include/types/proto_http.h	/^struct http_msg {$/;"	s
http_msg::__anon36::__anon37::l	include/types/proto_http.h	/^			int l;                 \/* request line length (not including CR) *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
http_msg::__anon36::__anon37::m_l	include/types/proto_http.h	/^			int m_l;               \/* METHOD length (method starts at ->som) *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
http_msg::__anon36::__anon37::u	include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
http_msg::__anon36::__anon37::u_l	include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
http_msg::__anon36::__anon37::v	include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
http_msg::__anon36::__anon37::v_l	include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
http_msg::__anon36::__anon38::c	include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
http_msg::__anon36::__anon38::c_l	include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
http_msg::__anon36::__anon38::l	include/types/proto_http.h	/^			int l;                 \/* status line length (not including CR) *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
http_msg::__anon36::__anon38::r	include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
http_msg::__anon36::__anon38::r_l	include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
http_msg::__anon36::__anon38::v_l	include/types/proto_http.h	/^			int v_l;               \/* VERSION length (version starts at ->som) *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
http_msg::__anon36::rq	include/types/proto_http.h	/^		} rq;                          \/* request line : field, length *\/$/;"	m	union:http_msg::__anon36	typeref:struct:http_msg::__anon36::__anon37	access:public
http_msg::__anon36::st	include/types/proto_http.h	/^		} st;                          \/* status line : field, length *\/$/;"	m	union:http_msg::__anon36	typeref:struct:http_msg::__anon36::__anon38	access:public
http_msg::cap	include/types/proto_http.h	/^	char **cap;                            \/* array of captured headers (may be NULL) *\/$/;"	m	struct:http_msg	access:public
http_msg::col	include/types/proto_http.h	/^	unsigned int col, sov;                 \/* current header: colon, start of value *\/$/;"	m	struct:http_msg	access:public
http_msg::eoh	include/types/proto_http.h	/^	unsigned int eoh;                      \/* End Of Headers, relative to buffer *\/$/;"	m	struct:http_msg	access:public
http_msg::eol	include/types/proto_http.h	/^	char *eol;                             \/* end of line *\/$/;"	m	struct:http_msg	access:public
http_msg::err_pos	include/types/proto_http.h	/^	int err_pos;                           \/* err handling: -2=block, -1=pass, 0+=detected *\/$/;"	m	struct:http_msg	access:public
http_msg::hdr_content_len	include/types/proto_http.h	/^	unsigned long long hdr_content_len;    \/* cache for parsed header value or for chunk-size if present *\/$/;"	m	struct:http_msg	access:public
http_msg::msg_state	include/types/proto_http.h	/^	unsigned int msg_state;                \/* where we are in the current message parsing *\/$/;"	m	struct:http_msg	access:public
http_msg::sl	include/types/proto_http.h	/^	} sl;                                  \/* start line *\/$/;"	m	struct:http_msg	typeref:union:http_msg::__anon36	access:public
http_msg::sol	include/types/proto_http.h	/^	char *sol;                             \/* start of line, also start of message when fully parsed *\/$/;"	m	struct:http_msg	access:public
http_msg::som	include/types/proto_http.h	/^	unsigned int som;                      \/* Start Of Message, relative to buffer *\/$/;"	m	struct:http_msg	access:public
http_msg::sov	include/types/proto_http.h	/^	unsigned int col, sov;                 \/* current header: colon, start of value *\/$/;"	m	struct:http_msg	access:public
http_msg_analyzer	src/proto_http.c	/^void http_msg_analyzer(struct buffer *buf, struct http_msg *msg, struct hdr_idx *idx)$/;"	f	signature:(struct buffer *buf, struct http_msg *msg, struct hdr_idx *idx)
http_msg_move_end	include/proto/proto_http.h	103;"	d
http_parse_chunk_size	src/proto_http.c	/^int http_parse_chunk_size(struct buffer *buf, struct http_msg *msg)$/;"	f	signature:(struct buffer *buf, struct http_msg *msg)
http_parse_connection_header	src/proto_http.c	/^void http_parse_connection_header(struct http_txn *txn, struct http_msg *msg, struct buffer *buf, int to_del)$/;"	f	signature:(struct http_txn *txn, struct http_msg *msg, struct buffer *buf, int to_del)
http_parse_reqline	src/proto_http.c	/^const char *http_parse_reqline(struct http_msg *msg, const char *msg_buf,$/;"	f	signature:(struct http_msg *msg, const char *msg_buf, unsigned int state, const char *ptr, const char *end, char **ret_ptr, unsigned int *ret_state)
http_parse_stsline	src/proto_http.c	/^const char *http_parse_stsline(struct http_msg *msg, const char *msg_buf,$/;"	f	signature:(struct http_msg *msg, const char *msg_buf, unsigned int state, const char *ptr, const char *end, char **ret_ptr, unsigned int *ret_state)
http_process_req_common	include/proto/proto_http.h	/^int http_process_req_common(struct session *s, struct buffer *req, int an_bit, struct proxy *px);$/;"	p	signature:(struct session *s, struct buffer *req, int an_bit, struct proxy *px)
http_process_req_common	src/proto_http.c	/^int http_process_req_common(struct session *s, struct buffer *req, int an_bit, struct proxy *px)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit, struct proxy *px)
http_process_req_stat_post	src/proto_http.c	/^int http_process_req_stat_post(struct session *s, struct buffer *req)$/;"	f	signature:(struct session *s, struct buffer *req)
http_process_request	include/proto/proto_http.h	/^int http_process_request(struct session *t, struct buffer *req, int an_bit);$/;"	p	signature:(struct session *t, struct buffer *req, int an_bit)
http_process_request	src/proto_http.c	/^int http_process_request(struct session *s, struct buffer *req, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit)
http_process_request_body	include/proto/proto_http.h	/^int http_process_request_body(struct session *s, struct buffer *req, int an_bit);$/;"	p	signature:(struct session *s, struct buffer *req, int an_bit)
http_process_request_body	src/proto_http.c	/^int http_process_request_body(struct session *s, struct buffer *req, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit)
http_process_res_common	include/proto/proto_http.h	/^int http_process_res_common(struct session *t, struct buffer *rep, int an_bit, struct proxy *px);$/;"	p	signature:(struct session *t, struct buffer *rep, int an_bit, struct proxy *px)
http_process_res_common	src/proto_http.c	/^int http_process_res_common(struct session *t, struct buffer *rep, int an_bit, struct proxy *px)$/;"	f	signature:(struct session *t, struct buffer *rep, int an_bit, struct proxy *px)
http_process_tarpit	include/proto/proto_http.h	/^int http_process_tarpit(struct session *s, struct buffer *req, int an_bit);$/;"	p	signature:(struct session *s, struct buffer *req, int an_bit)
http_process_tarpit	src/proto_http.c	/^int http_process_tarpit(struct session *s, struct buffer *req, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit)
http_remove_header2	src/proto_http.c	/^int http_remove_header2(struct http_msg *msg, struct buffer *buf,$/;"	f	signature:(struct http_msg *msg, struct buffer *buf, struct hdr_idx *idx, struct hdr_ctx *ctx)
http_request_forward_body	include/proto/proto_http.h	/^int http_request_forward_body(struct session *s, struct buffer *req, int an_bit);$/;"	p	signature:(struct session *s, struct buffer *req, int an_bit)
http_request_forward_body	src/proto_http.c	/^int http_request_forward_body(struct session *s, struct buffer *req, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit)
http_reset_txn	include/proto/proto_http.h	/^void http_reset_txn(struct session *s);$/;"	p	signature:(struct session *s)
http_reset_txn	src/proto_http.c	/^void http_reset_txn(struct session *s)$/;"	f	signature:(struct session *s)
http_response_forward_body	include/proto/proto_http.h	/^int http_response_forward_body(struct session *s, struct buffer *res, int an_bit);$/;"	p	signature:(struct session *s, struct buffer *res, int an_bit)
http_response_forward_body	src/proto_http.c	/^int http_response_forward_body(struct session *s, struct buffer *res, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *res, int an_bit)
http_resync_states	src/proto_http.c	/^int http_resync_states(struct session *s)$/;"	f	signature:(struct session *s)
http_return_srv_error	include/proto/proto_http.h	/^void http_return_srv_error(struct session *s, struct stream_interface *si);$/;"	p	signature:(struct session *s, struct stream_interface *si)
http_return_srv_error	src/proto_http.c	/^void http_return_srv_error(struct session *s, struct stream_interface *si)$/;"	f	signature:(struct session *s, struct stream_interface *si)
http_server_error	src/proto_http.c	/^static void http_server_error(struct session *t, struct stream_interface *si,$/;"	f	file:	signature:(struct session *t, struct stream_interface *si, int err, int finst, int status, const struct chunk *msg)
http_sess_clflog	src/proto_http.c	/^void http_sess_clflog(struct session *s)$/;"	f	signature:(struct session *s)
http_sess_log	include/proto/proto_http.h	/^void http_sess_log(struct session *s);$/;"	p	signature:(struct session *s)
http_sess_log	src/proto_http.c	/^void http_sess_log(struct session *s)$/;"	f	signature:(struct session *s)
http_silent_debug	src/proto_http.c	/^static void http_silent_debug(int line, struct session *s)$/;"	f	file:	signature:(int line, struct session *s)
http_silent_debug	src/proto_http.c	398;"	d	file:
http_skip_chunk_crlf	src/proto_http.c	/^int http_skip_chunk_crlf(struct buffer *buf, struct http_msg *msg)$/;"	f	signature:(struct buffer *buf, struct http_msg *msg)
http_stats_io_handler	include/proto/dumpstats.h	/^void http_stats_io_handler(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
http_stats_io_handler	src/dumpstats.c	/^void http_stats_io_handler(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
http_sync_req_state	src/proto_http.c	/^int http_sync_req_state(struct session *s)$/;"	f	signature:(struct session *s)
http_sync_res_state	src/proto_http.c	/^int http_sync_res_state(struct session *s)$/;"	f	signature:(struct session *s)
http_txn	include/types/proto_http.h	/^struct http_txn {$/;"	s
http_txn::auth	include/types/proto_http.h	/^	struct http_auth_data auth;	\/* HTTP auth data *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_auth_data	access:public
http_txn::cli_cookie	include/types/proto_http.h	/^	char *cli_cookie;               \/* cookie presented by the client, in capture mode *\/$/;"	m	struct:http_txn	access:public
http_txn::cookie_first_date	include/types/proto_http.h	/^	int cookie_first_date;          \/* if non-zero, first date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn	access:public
http_txn::cookie_last_date	include/types/proto_http.h	/^	int cookie_last_date;           \/* if non-zero, last date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn	access:public
http_txn::flags	include/types/proto_http.h	/^	unsigned int flags;             \/* transaction flags *\/$/;"	m	struct:http_txn	access:public
http_txn::hdr_idx	include/types/proto_http.h	/^	struct hdr_idx hdr_idx;         \/* array of header indexes (max: MAX_HTTP_HDR) *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::hdr_idx	access:public
http_txn::meth	include/types/proto_http.h	/^	http_meth_t meth;               \/* HTTP method *\/$/;"	m	struct:http_txn	access:public
http_txn::req	include/types/proto_http.h	/^	struct http_msg req;            \/* HTTP request message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg	access:public
http_txn::rsp	include/types/proto_http.h	/^	struct http_msg rsp;            \/* HTTP response message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg	access:public
http_txn::sessid	include/types/proto_http.h	/^	char *sessid;                   \/* the appsession id, if found in the request or in the response *\/$/;"	m	struct:http_txn	access:public
http_txn::srv_cookie	include/types/proto_http.h	/^	char *srv_cookie;               \/* cookie presented by the server, in capture mode *\/$/;"	m	struct:http_txn	access:public
http_txn::status	include/types/proto_http.h	/^	int status;                     \/* HTTP status from the server, negative if from proxy *\/$/;"	m	struct:http_txn	access:public
http_txn::uri	include/types/proto_http.h	/^	char *uri;                      \/* first line if log needed, NULL otherwise *\/$/;"	m	struct:http_txn	access:public
http_upgrade_v09_to_v10	src/proto_http.c	/^static int http_upgrade_v09_to_v10(struct buffer *req, struct http_msg *msg, struct http_txn *txn)$/;"	f	file:	signature:(struct buffer *req, struct http_msg *msg, struct http_txn *txn)
http_wait_for_request	include/proto/proto_http.h	/^int http_wait_for_request(struct session *s, struct buffer *req, int an_bit);$/;"	p	signature:(struct session *s, struct buffer *req, int an_bit)
http_wait_for_request	src/proto_http.c	/^int http_wait_for_request(struct session *s, struct buffer *req, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit)
http_wait_for_response	include/proto/proto_http.h	/^int http_wait_for_response(struct session *s, struct buffer *rep, int an_bit);$/;"	p	signature:(struct session *s, struct buffer *rep, int an_bit)
http_wait_for_response	src/proto_http.c	/^int http_wait_for_response(struct session *s, struct buffer *rep, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *rep, int an_bit)
httpchk_build_status_header	src/checks.c	/^static int httpchk_build_status_header(struct server *s, char *buffer)$/;"	f	file:	signature:(struct server *s, char *buffer)
httpchk_expect	src/checks.c	/^static int httpchk_expect(struct server *s, int done)$/;"	f	file:	signature:(struct server *s, int done)
httpchk_expect	src/checks.c	/^static int httpchk_expect(struct server *s, int done);$/;"	p	file:	signature:(struct server *s, int done)
httpka	include/types/proxy.h	/^		int httpka;                     \/* maximum time for a new HTTP request when using keep-alive *\/$/;"	m	struct:proxy::__anon19	access:public
httpreq	include/types/proxy.h	/^		int httpreq;                    \/* maximum time for complete HTTP request *\/$/;"	m	struct:proxy::__anon19	access:public
human_time	include/common/time.h	/^char *human_time(int t, short hz_div);$/;"	p	signature:(int t, short hz_div)
human_time	src/time.c	/^char *human_time(int t, short hz_div) {$/;"	f	signature:(int t, short hz_div)
i	contrib/base64/base64rev-gen.c	/^	int i, min = 255, max = 0;$/;"	l
i	contrib/halog/halog.c	/^				int i;$/;"	l
i	contrib/halog/halog.c	/^	int i = 0;$/;"	l
i	contrib/halog/halog.c	/^	unsigned int i = 0;$/;"	l
i	include/common/standard.h	/^	unsigned int i = 0;$/;"	l
i	include/types/acl.h	/^		int i;                          \/* integer value *\/$/;"	m	union:acl_pattern::__anon49	access:public
i	include/types/acl.h	/^		int i;          \/* any integer *\/$/;"	m	union:acl_test::__anon53	access:public
i	include/types/acl.h	/^	int i;                  \/* integer value *\/$/;"	m	struct:acl_test	access:public
i	src/acl.c	/^	int len = 0, i;$/;"	l
i	src/acl.c	/^	signed long long i;$/;"	l
i	src/appsession.c	/^	int                    i;$/;"	l
i	src/auth.c	/^	int i;$/;"	l
i	src/base64.c	/^	int convlen = 0, i = 0, pad = 0;$/;"	l
i	src/base64.c	/^	int i, out;$/;"	l
i	src/base64.c	/^	int i;$/;"	l
i	src/buffers.c	/^	int i, l;$/;"	l
i	src/cfgparse.c	/^					int i;$/;"	l
i	src/cfgparse.c	/^				int i, len=0;$/;"	l
i	src/cfgparse.c	/^				int i;$/;"	l
i	src/cfgparse.c	/^			int i = 0;$/;"	l
i	src/cfgparse.c	/^		int cur_arg, i;$/;"	l
i	src/cfgparse.c	/^		int i, len=0;$/;"	l
i	src/cfgparse.c	/^		int i;$/;"	l
i	src/dumpstats.c	/^					int i;$/;"	l
i	src/ev_select.c	/^	int fd, i;$/;"	l
i	src/ev_sepoll.c	/^	unsigned int i;$/;"	l
i	src/haproxy.c	/^	int i;$/;"	l
i	src/pattern.c	/^			int i = end - endw - 2;$/;"	l
i	src/pattern.c	/^	int i;$/;"	l
i	src/proto_http.c	/^	int i;$/;"	l
i	src/session.c	/^		int i;$/;"	l
i	src/session.c	/^	int i;$/;"	l
i	src/sessionhash.c	/^	int i;$/;"	l
i	src/sessionhash.c	/^	unsigned int i;$/;"	l
i	src/standard.c	/^	int i = 0;$/;"	l
i	src/standard.c	/^	long long i = 0;$/;"	l
i	tests/filltab25.c	/^	int i;$/;"	l
i	tests/sessionhash_test.c	/^	int i;$/;"	l
i	tests/test_hashes.c	/^  int i;$/;"	l
i	tests/test_hashes.c	/^  ub4 i;$/;"	l
i	tests/test_pools.c	/^	int i;$/;"	l
i	tests/uri_hash.c	/^	unsigned int i = 0x3C964BA5; \/* as many ones as zeroes *\/$/;"	l
ib	include/types/stream_interface.h	/^	struct buffer *ib, *ob; \/* input and output buffers *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::buffer	access:public
ib	src/stream_interface.c	/^	struct buffer *ib = si->ib;$/;"	l
ib	src/stream_sock.c	/^	struct buffer *ib = si->ib;$/;"	l
icase	src/acl.c	/^	int icase;$/;"	l
icase	src/acl.c	/^	int may_match, icase;$/;"	l
icase	src/proto_http.c	/^	int icase;$/;"	l
id	include/types/protocols.h	/^		struct eb32_node id;	\/* place in the tree of used IDs *\/$/;"	m	struct:listener::__anon25	typeref:struct:listener::__anon25::eb32_node	access:public
id	include/types/proxy.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:proxy::__anon20	typeref:struct:proxy::__anon20::eb32_node	access:public
id	include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy	access:public
id	include/types/server.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:server::__anon62	typeref:struct:server::__anon62::eb32_node	access:public
id	include/types/server.h	/^	char *id;				\/* just for identification *\/$/;"	m	struct:server	access:public
idiv	src/standard.c	/^	unsigned imult, idiv;$/;"	l
idlen	src/appsession.c	/^	int                 idlen;$/;"	l
idx	include/types/proto_http.h	/^	int  idx;$/;"	m	struct:hdr_ctx	access:public
idx	src/proto_http.c	/^	struct hdr_idx *idx = &txn->hdr_idx;$/;"	l
idx	src/sessionhash.c	/^	unsigned int idx;$/;"	l
iface_len	include/types/proxy.h	/^	int iface_len;				\/* bind interface name length *\/$/;"	m	struct:proxy	access:public
iface_len	include/types/server.h	/^	int iface_len;				\/* bind interface name length *\/$/;"	m	struct:server	access:public
iface_name	include/types/proxy.h	/^	char *iface_name;			\/* bind interface name or NULL *\/$/;"	m	struct:proxy	access:public
iface_name	include/types/server.h	/^	char *iface_name;			\/* bind interface name or NULL *\/$/;"	m	struct:server	access:public
ignore_implicit	Makefile	/^ignore_implicit = $(patsubst %=implicit,,$(1)=$($(1)))$/;"	m
ih	tests/uri_hash.c	/^	unsigned int ih, il;$/;"	l
iid	include/types/session.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:session::__anon9::__anon10	access:public
iid	include/types/session.h	/^			int iid;		\/* if >= 0, ID of the proxy to filter on *\/$/;"	m	struct:session::__anon9::__anon12	access:public
il	tests/uri_hash.c	/^	unsigned int ih, il;$/;"	l
imult	src/standard.c	/^	unsigned imult, idiv;$/;"	l
in	include/types/log.h	/^		struct sockaddr_in in;	\/* AF_INET *\/$/;"	m	union:logsrv::__anon1	typeref:struct:logsrv::__anon1::sockaddr_in	access:public
in_origaddrs	include/import/ip_tproxy.h	/^struct in_origaddrs {$/;"	s
in_origaddrs::ioa_dstaddr	include/import/ip_tproxy.h	/^        struct in_addr ioa_dstaddr;$/;"	m	struct:in_origaddrs	typeref:struct:in_origaddrs::in_addr	access:public
in_origaddrs::ioa_dstport	include/import/ip_tproxy.h	/^        unsigned short int ioa_dstport;$/;"	m	struct:in_origaddrs	access:public
in_origaddrs::ioa_srcaddr	include/import/ip_tproxy.h	/^        struct in_addr ioa_srcaddr;$/;"	m	struct:in_origaddrs	typeref:struct:in_origaddrs::in_addr	access:public
in_origaddrs::ioa_srcport	include/import/ip_tproxy.h	/^        unsigned short int ioa_srcport;$/;"	m	struct:in_origaddrs	access:public
in_tproxy	include/import/ip_tproxy.h	/^struct in_tproxy {$/;"	s
in_tproxy::_in_args	include/import/ip_tproxy.h	/^	union _in_args {$/;"	u	struct:in_tproxy	access:public
in_tproxy::_in_args::addr	include/import/ip_tproxy.h	/^		struct in_tproxy_addr	addr;$/;"	m	union:in_tproxy::_in_args	typeref:struct:in_tproxy::_in_args::in_tproxy_addr	access:public
in_tproxy::_in_args::flags	include/import/ip_tproxy.h	/^		u_int32_t		flags;$/;"	m	union:in_tproxy::_in_args	access:public
in_tproxy::_in_args::version	include/import/ip_tproxy.h	/^		u_int32_t		version;$/;"	m	union:in_tproxy::_in_args	access:public
in_tproxy::op	include/import/ip_tproxy.h	/^	u_int32_t op;$/;"	m	struct:in_tproxy	access:public
in_tproxy::v	include/import/ip_tproxy.h	/^	} v;$/;"	m	struct:in_tproxy	typeref:union:in_tproxy::_in_args	access:public
in_tproxy_addr	include/import/ip_tproxy.h	/^struct in_tproxy_addr{$/;"	s
in_tproxy_addr::faddr	include/import/ip_tproxy.h	/^	struct in_addr	faddr;$/;"	m	struct:in_tproxy_addr	typeref:struct:in_tproxy_addr::in_addr	access:public
in_tproxy_addr::fport	include/import/ip_tproxy.h	/^	u_int16_t	fport;$/;"	m	struct:in_tproxy_addr	access:public
in_type	include/types/pattern.h	/^	unsigned int in_type;                     \/* input needed pattern type *\/$/;"	m	struct:pattern_conv	access:public
index	include/types/capture.h	/^    int index;				\/* index in the output array *\/$/;"	m	struct:cap_hdr	access:public
index	src/acl.c	/^	int index;$/;"	l
index	src/cfgparse.c	/^		int index;$/;"	l
index	src/pattern.c	/^	int index;$/;"	l
inetaddr_host	include/common/standard.h	/^unsigned int inetaddr_host(const char *text);$/;"	p	signature:(const char *text)
inetaddr_host	src/standard.c	/^unsigned int inetaddr_host(const char *text)$/;"	f	signature:(const char *text)
inetaddr_host_lim	include/common/standard.h	/^unsigned int inetaddr_host_lim(const char *text, const char *stop);$/;"	p	signature:(const char *text, const char *stop)
inetaddr_host_lim	src/standard.c	/^unsigned int inetaddr_host_lim(const char *text, const char *stop)$/;"	f	signature:(const char *text, const char *stop)
inetaddr_host_lim_ret	include/common/standard.h	/^unsigned int inetaddr_host_lim_ret(const char *text, char *stop, const char **ret);$/;"	p	signature:(const char *text, char *stop, const char **ret)
inetaddr_host_lim_ret	src/standard.c	/^unsigned int inetaddr_host_lim_ret(const char *text, char *stop, const char **ret)$/;"	f	signature:(const char *text, char *stop, const char **ret)
info	include/types/checks.h	/^	char *info;			\/* human readable short info *\/$/;"	m	struct:check_status	access:public
info	src/checks.c	/^	const char *info;$/;"	l
init	include/types/fd.h	/^	int  REGPRM1   (*init)(struct poller *p);            \/* poller initialization *\/$/;"	m	struct:poller	access:private
init	include/types/lb_fwrr.h	/^	struct eb_root *init;   \/* servers waiting to be placed *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root	access:public
init	src/haproxy.c	/^void init(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
init_buffer	include/proto/buffers.h	/^int init_buffer();$/;"	p	signature:()
init_buffer	src/buffers.c	/^int init_buffer()$/;"	f
init_default_instance	include/common/cfgparse.h	/^void init_default_instance();$/;"	p	signature:()
init_default_instance	src/cfgparse.c	/^void init_default_instance()$/;"	f
init_head	src/lb_chash.c	/^	struct eb_root init_head = EB_ROOT;$/;"	l
init_head	src/lb_fwlc.c	/^	struct eb_root init_head = EB_ROOT;$/;"	l
init_head	src/lb_fwrr.c	/^	struct eb_root init_head = EB_ROOT;$/;"	l
init_new_proxy	src/cfgparse.c	/^static void init_new_proxy(struct proxy *p)$/;"	f	file:	signature:(struct proxy *p)
init_pendconn	include/proto/queue.h	/^int init_pendconn();$/;"	p	signature:()
init_pendconn	src/queue.c	/^int init_pendconn()$/;"	f
init_pipe	src/pipe.c	/^static void init_pipe()$/;"	f	file:
init_pollers	include/proto/fd.h	/^int init_pollers();$/;"	p	signature:()
init_pollers	src/fd.c	/^int init_pollers()$/;"	f
init_proto_http	include/proto/proto_http.h	/^void init_proto_http();$/;"	p	signature:()
init_proto_http	src/proto_http.c	/^void init_proto_http()$/;"	f
init_server_map	include/proto/lb_map.h	/^void init_server_map(struct proxy *p);$/;"	p	signature:(struct proxy *p)
init_server_map	src/lb_map.c	/^void init_server_map(struct proxy *p)$/;"	f	signature:(struct proxy *p)
init_session	include/proto/session.h	/^int init_session();$/;"	p	signature:()
init_session	src/session.c	/^int init_session()$/;"	f
init_task	include/proto/task.h	/^int init_task();$/;"	p	signature:()
init_task	src/task.c	/^int init_task()$/;"	f
init_tree	tests/filltab25.c	/^struct eb_root *init_tree; \/* receives positions 0..sw-1 *\/$/;"	v	typeref:struct:eb_root
initialized	src/appsession.c	/^	static int          initialized = 0;$/;"	l	file:
initialized	src/appsession.c	/^	static int initialized = 0;$/;"	l	file:
insert_timer	contrib/halog/halog.c	/^struct timer *insert_timer(struct eb_root *r, struct timer **alloc, int v)$/;"	f	signature:(struct eb_root *r, struct timer **alloc, int v)
insert_value	contrib/halog/halog.c	/^struct timer *insert_value(struct eb_root *r, struct timer **alloc, int v)$/;"	f	signature:(struct eb_root *r, struct timer **alloc, int v)
inspect_delay	include/types/proxy.h	/^		unsigned int inspect_delay;     \/* inspection delay *\/$/;"	m	struct:proxy::__anon18	access:public
inspect_rules	include/types/proxy.h	/^		struct list inspect_rules;      \/* inspection rules *\/$/;"	m	struct:proxy::__anon18	typeref:struct:proxy::__anon18::list	access:public
integer	include/types/pattern.h	/^	uint32_t integer;  \/* used for unsigned 32bits integer type *\/$/;"	m	union:pattern_data	access:public
integer	include/types/stick_table.h	/^	uint32_t integer;         \/* used to store an integer key *\/$/;"	m	union:stktable_key_data	access:public
inter	include/types/server.h	/^	int inter, fastinter, downinter;	\/* checks: time in milliseconds *\/$/;"	m	struct:server	access:public
interface	include/types/protocols.h	/^	char *interface;		\/* interface name or NULL *\/$/;"	m	struct:listener	access:private
interval	src/cfgparse.c	/^			unsigned interval;$/;"	l
invalid_char	include/common/standard.h	/^extern const char *invalid_char(const char *name);$/;"	p	signature:(const char *name)
invalid_char	src/standard.c	/^const char *invalid_char(const char *name)$/;"	f	signature:(const char *name)
invalid_domainchar	include/common/standard.h	/^extern const char *invalid_domainchar(const char *name);$/;"	p	signature:(const char *name)
invalid_domainchar	src/standard.c	/^const char *invalid_domainchar(const char *name) {$/;"	f	signature:(const char *name)
invalid_rep	include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
invalid_req	include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::error_snapshot	access:public
ioa_dstaddr	include/import/ip_tproxy.h	/^        struct in_addr ioa_dstaddr;$/;"	m	struct:in_origaddrs	typeref:struct:in_origaddrs::in_addr	access:public
ioa_dstport	include/import/ip_tproxy.h	/^        unsigned short int ioa_dstport;$/;"	m	struct:in_origaddrs	access:public
ioa_srcaddr	include/import/ip_tproxy.h	/^        struct in_addr ioa_srcaddr;$/;"	m	struct:in_origaddrs	typeref:struct:in_origaddrs::in_addr	access:public
ioa_srcport	include/import/ip_tproxy.h	/^        unsigned short int ioa_srcport;$/;"	m	struct:in_origaddrs	access:public
iohandler	include/types/stream_interface.h	/^	void (*iohandler)(struct stream_interface *);  \/* internal I\/O handler when embedded *\/$/;"	m	struct:stream_interface	access:public
ip	include/types/pattern.h	/^	struct in_addr ip; \/* used for ipv4 type *\/$/;"	m	union:pattern_data	typeref:struct:pattern_data::in_addr	access:public
ip	include/types/stick_table.h	/^	struct in_addr ip;        \/* used to store an ip key *\/$/;"	m	union:stktable_key_data	typeref:struct:stktable_key_data::in_addr	access:public
ip_transp_working	src/proto_tcp.c	/^	static int ip_transp_working = 1;$/;"	l	file:
ipv4	include/types/acl.h	/^		} ipv4;                         \/* IPv4 address *\/$/;"	m	union:acl_pattern::__anon49	typeref:struct:acl_pattern::__anon49::__anon51	access:public
is_cookie2	src/proto_http.c	/^	int is_cookie2;$/;"	l
is_set	include/types/fd.h	/^	int  REGPRM2 (*is_set)(const int fd, int dir);       \/* check if <fd> is being polled for dir <dir> *\/$/;"	m	struct:poller	access:private
ishex	include/common/standard.h	/^extern int ishex(char s);$/;"	p	signature:(char s)
ishex	src/standard.c	/^int ishex(char s)$/;"	f	signature:(char s)
item	src/sessionhash.c	/^	appsess *item;$/;"	l
iterator	src/backend.c	/^	struct server *iterator;$/;"	l
itoa_str	include/common/standard.h	/^extern char itoa_str[][171];$/;"	x
itoa_str	src/standard.c	/^char itoa_str[10][171];$/;"	v
itp1	src/cttproxy.c	/^	struct in_tproxy itp1;$/;"	l
itp1	src/proto_tcp.c	/^		struct in_tproxy itp1, itp2;$/;"	l
itp2	src/proto_tcp.c	/^		struct in_tproxy itp1, itp2;$/;"	l
iweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server	access:public
j	contrib/halog/halog.c	/^	int j, k;$/;"	l
j	include/common/standard.h	/^	unsigned int j, k;$/;"	l
j	include/common/standard.h	/^	unsigned int j;$/;"	l
j	src/acl.c	/^	unsigned int j, last, skip = 0;$/;"	l
j	src/standard.c	/^		unsigned int j;$/;"	l
j	src/standard.c	/^	int j, k;$/;"	l
j	src/standard.c	/^	int j;$/;"	l
j	tests/uri_hash.c	/^	unsigned int j;$/;"	l
k	contrib/halog/halog.c	/^	int j, k;$/;"	l
k	include/common/standard.h	/^	unsigned int j, k;$/;"	l
k	src/standard.c	/^	int j, k;$/;"	l
k_int2int	src/pattern.c	/^static void *k_int2int(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)$/;"	f	file:	signature:(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
k_int2ip	src/pattern.c	/^static void *k_int2ip(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)$/;"	f	file:	signature:(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
k_int2str	src/pattern.c	/^static void *k_int2str(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)$/;"	f	file:	signature:(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
k_ip2int	src/pattern.c	/^static void *k_ip2int(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)$/;"	f	file:	signature:(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
k_ip2ip	src/pattern.c	/^static void *k_ip2ip(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)$/;"	f	file:	signature:(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
k_ip2str	src/pattern.c	/^static void *k_ip2str(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)$/;"	f	file:	signature:(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
k_str2int	src/pattern.c	/^static void *k_str2int(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)$/;"	f	file:	signature:(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
k_str2ip	src/pattern.c	/^static void *k_str2ip(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)$/;"	f	file:	signature:(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
k_str2str	src/pattern.c	/^static void *k_str2str(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)$/;"	f	file:	signature:(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
kev	src/ev_kqueue.c	/^static struct kevent *kev = NULL;$/;"	v	typeref:struct:kevent	file:
key	ebtree/eb32tree.h	/^	u32 key = x ^ 0x80000000;$/;"	l
key	ebtree/eb32tree.h	/^	u32 key;$/;"	m	struct:eb32_node	access:public
key	ebtree/eb64tree.h	/^	u64 key = x ^ (1ULL << 63);$/;"	l
key	ebtree/eb64tree.h	/^	u64 key;$/;"	m	struct:eb64_node	access:public
key	ebtree/ebmbtree.h	/^	unsigned char key[0]; \/* the key, its size depends on the application *\/$/;"	m	struct:ebmb_node	access:public
key	ebtree/ebpttree.h	/^	void *key;$/;"	m	struct:ebpt_node	access:public
key	include/types/stick_table.h	/^	void *key;                      \/* pointer on key buffer *\/$/;"	m	struct:stktable_key	access:public
key	src/pattern.c	/^	void *key;$/;"	l
key	src/proto_http.c	/^		char *key, *value;$/;"	l
key	src/session.c	/^			struct stktable_key *key;$/;"	l
key_len	include/types/stick_table.h	/^	size_t key_len;                 \/* data len to read in buff in case of null terminated string *\/$/;"	m	struct:stktable_key	access:public
key_size	include/types/stick_table.h	/^	size_t key_size;          \/* size of a key, maximum size in case of string *\/$/;"	m	struct:stktable	access:public
keys	include/types/stick_table.h	/^	struct eb_root keys;      \/* head of stuck session tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root	access:public
keys	include/types/stick_table.h	/^	struct ebmb_node keys;    \/* ebtree node used to hold the session in table *\/$/;"	m	struct:stksess	typeref:struct:stksess::ebmb_node	access:public
kill_pipe	include/proto/pipe.h	/^void kill_pipe(struct pipe *p);$/;"	p	signature:(struct pipe *p)
kill_pipe	src/pipe.c	/^void kill_pipe(struct pipe *p)$/;"	f	signature:(struct pipe *p)
kqev_del	src/ev_kqueue.c	/^REGPRM3 static int kqev_del(struct kevent *kev, const int fd, const int dir)$/;"	f	file:	signature:(struct kevent *kev, const int fd, const int dir)
kqueue_fd	src/ev_kqueue.c	/^static int kqueue_fd;$/;"	v	file:
kr_hash	tests/test_hashes.c	/^unsigned kr_hash(char *s){$/;"	f	signature:(char *s)
kw	include/common/cfgparse.h	/^	const char *kw;                         \/* the keyword itself *\/$/;"	m	struct:cfg_keyword	access:public
kw	include/common/cfgparse.h	/^	struct cfg_keyword kw[VAR_ARRAY];$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::cfg_keyword	access:public
kw	include/types/acl.h	/^	const char *kw;$/;"	m	struct:acl_keyword	access:public
kw	include/types/acl.h	/^	struct acl_keyword *kw;     \/* back-reference to the keyword *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::acl_keyword	access:public
kw	include/types/acl.h	/^	struct acl_keyword kw[VAR_ARRAY];$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::acl_keyword	access:public
kw	include/types/pattern.h	/^	const char *kw;                           \/* configuration keyword  *\/$/;"	m	struct:pattern_conv	access:public
kw	include/types/pattern.h	/^	const char *kw;                           \/* configuration keyword *\/$/;"	m	struct:pattern_fetch	access:public
kw	include/types/pattern.h	/^	struct pattern_conv kw[VAR_ARRAY];        \/* array of pattern ions *\/$/;"	m	struct:pattern_conv_kw_list	typeref:struct:pattern_conv_kw_list::pattern_conv	access:public
kw	include/types/pattern.h	/^	struct pattern_fetch kw[VAR_ARRAY];       \/* array of pattern fetches *\/$/;"	m	struct:pattern_fetch_kw_list	typeref:struct:pattern_fetch_kw_list::pattern_fetch	access:public
kw	include/types/stick_table.h	/^	const char *kw;       \/* keyword string *\/$/;"	m	struct:stktable_type	access:public
kw_mod	src/cfgparse.c	/^enum kw_mod {$/;"	g	file:
kwend	src/acl.c	/^	const char *kwend;$/;"	l
kwl	src/acl.c	/^	struct acl_kw_list *kwl;$/;"	l
kwl	src/cfgparse.c	/^		struct cfg_kw_list *kwl;$/;"	l
kwl	src/pattern.c	/^	struct pattern_conv_kw_list *kwl;$/;"	l
kwl	src/pattern.c	/^	struct pattern_fetch_kw_list *kwl;$/;"	l
kwm	src/cfgparse.c	/^		int arg, kwm = KWM_STD;$/;"	l
l	include/types/buffers.h	/^	unsigned int l;                 \/* data length *\/$/;"	m	struct:buffer	access:public
l	include/types/proto_http.h	/^			int l;                 \/* request line length (not including CR) *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
l	include/types/proto_http.h	/^			int l;                 \/* status line length (not including CR) *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
l	include/types/session.h	/^			struct listener *l;$/;"	m	struct:session::__anon9::__anon10	typeref:struct:session::__anon9::__anon10::listener	access:public
l	src/auth.c	/^	struct userlist *l;$/;"	l
l	src/backend.c	/^	unsigned int h, l;$/;"	l
l	src/buffers.c	/^	int i, l;$/;"	l
l	src/cfgparse.c	/^				struct listener *l;$/;"	l
l	src/cfgparse.c	/^	struct listener *l;$/;"	l
l	src/client.c	/^	struct listener *l = fdtab[fd].owner;$/;"	l
l	src/dumpstats.c	/^	struct listener *l;$/;"	l
l	src/haproxy.c	/^	struct listener *l,*l_next;$/;"	l
l	src/proto_uxst.c	/^	struct listener *l = fdtab[fd].owner;$/;"	l
l	src/proxy.c	/^	struct listener *l;$/;"	l
l	tests/test_hashes.c	/^  unsigned int h, l;$/;"	l
l	tests/uri_hash.c	/^  unsigned int h, l;$/;"	l
l3_addrlen	include/types/protocols.h	/^	int l3_addrlen;					\/* layer3 address length, used by hashes *\/$/;"	m	struct:protocol	access:public
l_next	src/haproxy.c	/^	struct listener *l,*l_next;$/;"	l
laddr	src/client.c	/^		socklen_t laddr = sizeof(addr);$/;"	l
laddr	src/proto_uxst.c	/^		socklen_t laddr = sizeof(addr);$/;"	l
last	contrib/halog/halog.c	/^	int f, tot, last, linenum, err, parse_err;$/;"	l
last	ebtree/ebtree.h	/^		struct eb_node *last = head;$/;"	l
last	include/types/hdr_idx.h	/^	short last;                 \/* length of the allocated area (1..size) *\/$/;"	m	struct:hdr_idx	access:public
last	include/types/lb_chash.h	/^	struct eb32_node *last;	\/* last node found in case of round robin (or NULL) *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb32_node	access:public
last	src/acl.c	/^	unsigned int j, last, skip = 0;$/;"	l
last	src/buffers.c	/^		char last, save;$/;"	l
last	src/cfgparse.c	/^			struct listener *new, *last = curproxy->listen;$/;"	l
last	src/fd.c	/^	int last, next;$/;"	l
last	tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:	access:public
last_change	include/types/proxy.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:proxy	access:public
last_change	include/types/server.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:server	access:public
last_checks	include/types/global.h	/^	int last_checks;$/;"	m	struct:global	access:public
last_hdr	src/proto_http.c	/^	int cur_idx, old_idx, last_hdr;$/;"	l
last_len	src/stream_sock.c	/^		int last_len = b->pipe ? b->pipe->data : 0;$/;"	l
last_listen	src/cfgparse.c	/^		struct listener *new_listen, *last_listen;$/;"	l
last_skipped	src/ev_sepoll.c	/^	static unsigned int last_skipped;$/;"	l	file:
last_timer	include/proto/task.h	/^extern struct eb32_node *last_timer;   \/* optimization: last queued timer *\/$/;"	x
last_timer	src/task.c	/^struct eb32_node *last_timer = NULL;  \/* optimization: last queued timer *\/$/;"	v	typeref:struct:eb32_node
lb_chash	include/types/lb_chash.h	/^struct lb_chash {$/;"	s
lb_chash::act	include/types/lb_chash.h	/^	struct eb_root act;	\/* weighted chash entries of active servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root	access:public
lb_chash::bck	include/types/lb_chash.h	/^	struct eb_root bck;	\/* weighted chash entries of backup servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root	access:public
lb_chash::last	include/types/lb_chash.h	/^	struct eb32_node *last;	\/* last node found in case of round robin (or NULL) *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb32_node	access:public
lb_fwlc	include/types/lb_fwlc.h	/^struct lb_fwlc {$/;"	s
lb_fwlc::act	include/types/lb_fwlc.h	/^	struct eb_root act;	\/* weighted least conns on the active servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root	access:public
lb_fwlc::bck	include/types/lb_fwlc.h	/^	struct eb_root bck;	\/* weighted least conns on the backup servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root	access:public
lb_fwrr	include/types/lb_fwrr.h	/^struct lb_fwrr {$/;"	s
lb_fwrr::act	include/types/lb_fwrr.h	/^	struct fwrr_group act;	\/* weighted round robin on the active servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group	access:public
lb_fwrr::bck	include/types/lb_fwrr.h	/^	struct fwrr_group bck;	\/* weighted round robin on the backup servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group	access:public
lb_map	include/types/lb_map.h	/^struct lb_map {$/;"	s
lb_map::rr_idx	include/types/lb_map.h	/^	int rr_idx;		\/* next server to be elected in round robin mode *\/$/;"	m	struct:lb_map	access:public
lb_map::srv	include/types/lb_map.h	/^	struct server **srv;	\/* the server map used to apply weights *\/$/;"	m	struct:lb_map	typeref:struct:lb_map::server	access:public
lb_map::state	include/types/lb_map.h	/^	int state;		\/* LB_MAP_RECALC *\/$/;"	m	struct:lb_map	access:public
lb_node	include/types/server.h	/^	struct eb32_node lb_node;               \/* node used for tree-based load balancing *\/$/;"	m	struct:server	typeref:struct:server::eb32_node	access:public
lb_nodes	include/types/server.h	/^	struct tree_occ *lb_nodes;              \/* lb_nodes_tot * struct tree_occ *\/$/;"	m	struct:server	typeref:struct:server::tree_occ	access:public
lb_nodes_now	include/types/server.h	/^	unsigned lb_nodes_now;                  \/* number of lb_nodes placed in the tree (C-HASH) *\/$/;"	m	struct:server	access:public
lb_nodes_tot	include/types/server.h	/^	unsigned lb_nodes_tot;                  \/* number of allocated lb_nodes (C-HASH) *\/$/;"	m	struct:server	access:public
lb_tree	include/types/server.h	/^	struct eb_root *lb_tree;                \/* we want to know in what tree the server is *\/$/;"	m	struct:server	typeref:struct:server::eb_root	access:public
lbprm	include/types/backend.h	/^struct lbprm {$/;"	s
lbprm	include/types/proxy.h	/^	struct lbprm lbprm;			\/* load-balancing parameters *\/$/;"	m	struct:proxy	typeref:struct:proxy::lbprm	access:public
lbprm::algo	include/types/backend.h	/^	int algo;			\/* load balancing algorithm and variants: BE_LB_* *\/$/;"	m	struct:lbprm	access:public
lbprm::chash	include/types/backend.h	/^	struct lb_chash chash;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_chash	access:public
lbprm::fbck	include/types/backend.h	/^	struct server *fbck;		\/* first backup server when !PR_O_USE_ALL_BK, or NULL *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::server	access:public
lbprm::fwlc	include/types/backend.h	/^	struct lb_fwlc fwlc;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwlc	access:public
lbprm::fwrr	include/types/backend.h	/^	struct lb_fwrr fwrr;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwrr	access:public
lbprm::map	include/types/backend.h	/^	struct lb_map map;		\/* LB parameters for map-based algorithms *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_map	access:public
lbprm::server_drop_conn	include/types/backend.h	/^	void (*server_drop_conn)(struct server *);       \/* to be called when connection is dropped *\/$/;"	m	struct:lbprm	access:public
lbprm::server_take_conn	include/types/backend.h	/^	void (*server_take_conn)(struct server *);       \/* to be called when connection is assigned *\/$/;"	m	struct:lbprm	access:public
lbprm::set_server_status_down	include/types/backend.h	/^	void (*set_server_status_down)(struct server *); \/* to be called after status changes to DOWN *\/$/;"	m	struct:lbprm	access:public
lbprm::set_server_status_up	include/types/backend.h	/^	void (*set_server_status_up)(struct server *);   \/* to be called after status changes to UP *\/$/;"	m	struct:lbprm	access:public
lbprm::tot_used	include/types/backend.h	/^	int tot_used;			\/* total number of servers used for LB *\/$/;"	m	struct:lbprm	access:public
lbprm::tot_wact	include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm	access:public
lbprm::tot_wbck	include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm	access:public
lbprm::tot_weight	include/types/backend.h	/^	int tot_weight;			\/* total effective weight of servers participating to LB *\/$/;"	m	struct:lbprm	access:public
lbprm::update_server_eweight	include/types/backend.h	/^	void (*update_server_eweight)(struct server *);  \/* to be called after eweight change *\/$/;"	m	struct:lbprm	access:public
lbprm::wdiv	include/types/backend.h	/^	int wdiv;			\/* ratio between effective weight and user weight *\/$/;"	m	struct:lbprm	access:public
lbprm::wmult	include/types/backend.h	/^	int wmult;			\/* ratio between user weight and effective weight *\/$/;"	m	struct:lbprm	access:public
leaf_p	ebtree/ebtree.h	/^	eb_troot_t    *leaf_p;  \/* leaf node's parent *\/$/;"	m	struct:eb_node	access:public
left	src/rbtree.c	/^		struct rb_node *old = node, *left;$/;"	l
left	src/rbtree.c	/^	struct rb_node *left = node->rb_left;$/;"	l
len	include/proto/buffers.h	/^	size_t len;$/;"	l
len	include/types/acl.h	/^	int len;                        \/* data length when required  *\/$/;"	m	struct:acl_pattern	access:public
len	include/types/acl.h	/^	int len;                \/* length of value at ptr, otherwise ignored *\/$/;"	m	struct:acl_test	access:public
len	include/types/buffers.h	/^	int len;	\/* current size of the string from first to last char. <0 = uninit. *\/$/;"	m	struct:chunk	access:public
len	include/types/capture.h	/^    int len;				\/* capture length, not including terminal zero *\/$/;"	m	struct:cap_hdr	access:public
len	include/types/hdr_idx.h	/^        unsigned len  :16; \/* length of this header not counting CRLF. 0=unused entry. *\/$/;"	m	struct:hdr_idx_elem	access:public
len	include/types/proxy.h	/^	unsigned int len;		\/* original length of the last invalid request\/response *\/$/;"	m	struct:error_snapshot	access:public
len	src/acl.c	/^	int len = 0, i;$/;"	l
len	src/acl.c	/^	int len;$/;"	l
len	src/appsession.c	/^						int len;$/;"	l
len	src/backend.c	/^		int len;$/;"	l
len	src/backend.c	/^	unsigned long    len  = msg->hdr_content_len;$/;"	l
len	src/backend.c	/^	unsigned long    len;$/;"	l
len	src/buffers.c	/^	int len;$/;"	l
len	src/cfgparse.c	/^				int i, len=0;$/;"	l
len	src/cfgparse.c	/^		int i, len=0;$/;"	l
len	src/checks.c	/^	int len;$/;"	l
len	src/client.c	/^			int len;$/;"	l
len	src/dumpstats.c	/^			int len;$/;"	l
len	src/dumpstats.c	/^	int len;$/;"	l
len	src/proto_http.c	/^				int len;$/;"	l
len	src/proto_http.c	/^			int len;$/;"	l
len	src/proto_http.c	/^	int bytes, len;$/;"	l
len	src/proto_http.c	/^	int len, delta;$/;"	l
len	src/proto_http.c	/^	int len, max;$/;"	l
len	src/proto_http.c	/^	int len, meth;$/;"	l
len	src/proto_http.c	/^	int len;$/;"	l
len	src/proto_http.c	/^	int len;$/;"	m	struct:http_method_desc	file:	access:public
len	src/regex.c	/^				int len, num;$/;"	l
len	src/session.c	/^		int len;$/;"	l
len	src/standard.c	/^		unsigned long len = strtol(str, &err, 10);$/;"	l
len	src/standard.c	/^	int len = 0;$/;"	l
len	tests/test_hashes.c	/^  int len;$/;"	l
lerr	src/proxy.c	/^	int lerr, err = ERR_NONE;$/;"	l
level	include/types/protocols.h	/^			int level;	\/* access level (ACCESS_LVL_*) *\/$/;"	m	struct:listener::__anon23::__anon24	access:public
level	src/cfgparse.c	/^			int level, minlvl;$/;"	l
level	src/cfgparse.c	/^		int facility, level, minlvl;$/;"	l
level	src/log.c	/^	int level;$/;"	l
level	src/log.c	/^	int tolog, level, err;$/;"	l
level	src/proto_http.c	/^	int tolog, level, err;$/;"	l
li	src/dumpstats.c	/^			struct listener *li;$/;"	l
licounters	include/types/counters.h	/^struct licounters {$/;"	s
licounters::bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:licounters	access:public
licounters::bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:licounters	access:public
licounters::conn_max	include/types/counters.h	/^	unsigned int conn_max;			\/* max # of active listener sessions *\/$/;"	m	struct:licounters	access:public
licounters::cum_conn	include/types/counters.h	/^	long long cum_conn;			\/* cumulated number of processed sessions *\/$/;"	m	struct:licounters	access:public
licounters::denied_req	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters	access:public
licounters::denied_resp	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters	access:public
licounters::failed_req	include/types/counters.h	/^	long long failed_req;			\/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:licounters	access:public
likely	include/common/compiler.h	101;"	d
likely	include/common/compiler.h	90;"	d
likely	include/common/compiler.h	94;"	d
limit	include/common/memory.h	/^	unsigned int limit;	\/* hard limit on the number of chunks *\/$/;"	m	struct:pool_head	access:public
limit	src/haproxy.c	/^	struct rlimit limit;$/;"	l
limit	src/proto_http.c	/^	long long limit = s->be->url_param_post_limit;$/;"	l
limit_r	include/common/standard.h	/^extern const char *limit_r(unsigned long n, char *buffer, int size, const char *alt);$/;"	p	signature:(unsigned long n, char *buffer, int size, const char *alt)
limit_r	src/standard.c	/^const char *limit_r(unsigned long n, char *buffer, int size, const char *alt)$/;"	f	signature:(unsigned long n, char *buffer, int size, const char *alt)
line	contrib/halog/fgets2-64.c	/^	static char *line = buffer;$/;"	l	file:
line	contrib/halog/fgets2.c	/^	static char *line = buffer;$/;"	l	file:
line	contrib/halog/halog.c	/^const char *line;$/;"	v
line	include/types/acl.h	/^	int line;                   \/* line in the config file where the condition is declared *\/$/;"	m	struct:acl_cond	access:public
line	include/types/proto_http.h	/^	char *line;$/;"	m	struct:hdr_ctx	access:public
line	include/types/protocols.h	/^		int line;		\/* line where the section appears *\/$/;"	m	struct:listener::__anon25	access:public
line	include/types/proxy.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:proxy::__anon20	access:public
line	include/types/server.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:server::__anon62	access:public
line	src/cfgparse.c	/^		char *line = thisline;$/;"	l
line	tests/uri_hash.c	/^char line[MAXLINE];$/;"	v
linenum	contrib/halog/halog.c	/^	int f, tot, last, linenum, err, parse_err;$/;"	l
linenum	src/cfgparse.c	/^	int linenum = 0;$/;"	l
lines	contrib/halog/fgets2-64.c	/^	unsigned int lines = 0;$/;"	l
lines	contrib/halog/fgets2.c	/^	unsigned int lines = 0;$/;"	l
list	include/common/cfgparse.h	/^	struct list list;$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::list	access:public
list	include/common/memory.h	/^	struct list list;	\/* list of all known pools *\/$/;"	m	struct:pool_head	typeref:struct:pool_head::list	access:public
list	include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:cond_wordlist	typeref:struct:cond_wordlist::list	access:public
list	include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:wordlist	typeref:struct:wordlist::list	access:public
list	include/common/mini-clist.h	/^struct list {$/;"	s
list	include/common/uri_auth.h	/^	struct list list;	\/* list linked to from the proxy *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::list	access:public
list	include/types/acl.h	/^	struct list list;                       \/* chaining *\/$/;"	m	struct:acl_pattern	typeref:struct:acl_pattern::list	access:public
list	include/types/acl.h	/^	struct list list;           \/* Some specific tests may use multiple conditions *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list	access:public
list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl	typeref:struct:acl::list	access:public
list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::list	access:public
list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::list	access:public
list	include/types/acl.h	/^	struct list list;           \/* chaining of term suites *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list	access:public
list	include/types/acl.h	/^	struct list list;$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::list	access:public
list	include/types/auth.h	/^	struct list list;$/;"	m	struct:req_acl_rule	typeref:struct:req_acl_rule::list	access:public
list	include/types/pattern.h	/^	struct list list;                         \/* head of pattern conversion keyword list *\/$/;"	m	struct:pattern_conv_kw_list	typeref:struct:pattern_conv_kw_list::list	access:public
list	include/types/pattern.h	/^	struct list list;                         \/* head of pattern fetch keyword list *\/$/;"	m	struct:pattern_fetch_kw_list	typeref:struct:pattern_fetch_kw_list::list	access:public
list	include/types/pattern.h	/^	struct list list;                         \/* member of a pattern expression *\/$/;"	m	struct:pattern_conv_expr	typeref:struct:pattern_conv_expr::list	access:public
list	include/types/pattern.h	/^	struct list list;                         \/* member of list of pattern, currently not used *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::list	access:public
list	include/types/proto_tcp.h	/^	struct list list;$/;"	m	struct:tcp_rule	typeref:struct:tcp_rule::list	access:public
list	include/types/protocols.h	/^	struct list list;				\/* list of registered protocols *\/$/;"	m	struct:protocol	typeref:struct:protocol::list	access:public
list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::list	access:public
list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::list	access:public
list	include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::list	access:public
list	include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::list	access:public
list	include/types/queue.h	/^	struct list list;		\/* chaining ... *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::list	access:public
list	include/types/session.h	/^	struct list list;			\/* position in global sessions list *\/$/;"	m	struct:session	typeref:struct:session::list	access:public
list::n	include/common/mini-clist.h	/^    struct list *n;	\/* next *\/$/;"	m	struct:list	typeref:struct:list::list	access:public
list::p	include/common/mini-clist.h	/^    struct list *p;	\/* prev *\/$/;"	m	struct:list	typeref:struct:list::list	access:public
list_for_each_entry	include/common/mini-clist.h	182;"	d
list_for_each_entry	src/acl.c	/^	list_for_each_entry(acl, head, list) {$/;"	f
list_for_each_entry_safe	include/common/mini-clist.h	195;"	d
list_for_each_entry_safe	src/auth.c	/^	list_for_each_entry_safe(pr, tr, r, list) {$/;"	f
list_pollers	include/proto/fd.h	/^int list_pollers(FILE *out);$/;"	p	signature:(FILE *out)
list_pollers	src/fd.c	/^int list_pollers(FILE *out)$/;"	f	signature:(FILE *out)
listen	include/types/proxy.h	/^	struct listener *listen;		\/* the listen addresses and sockets *\/$/;"	m	struct:proxy	typeref:struct:proxy::listener	access:public
listen_proxies	include/proto/proxy.h	/^void listen_proxies(void);$/;"	p	signature:(void)
listen_proxies	src/proxy.c	/^void listen_proxies(void)$/;"	f	signature:(void)
listener	include/types/protocols.h	/^struct listener {$/;"	s
listener	include/types/session.h	/^	struct listener *listener;		\/* the listener by which the request arrived *\/$/;"	m	struct:session	typeref:struct:session::listener	access:public
listener	src/cfgparse.c	/^		struct listener *listener;$/;"	l
listener	src/proto_tcp.c	/^	struct listener *listener;$/;"	l
listener	src/proto_uxst.c	/^	struct listener *listener;$/;"	l
listener	src/protocols.c	/^	struct listener *listener;$/;"	l
listener	src/proxy.c	/^	struct listener *listener;$/;"	l
listener::__anon23::__anon24::gid	include/types/protocols.h	/^			gid_t gid;	\/* -1 to leave unchanged *\/$/;"	m	struct:listener::__anon23::__anon24	access:public
listener::__anon23::__anon24::level	include/types/protocols.h	/^			int level;	\/* access level (ACCESS_LVL_*) *\/$/;"	m	struct:listener::__anon23::__anon24	access:public
listener::__anon23::__anon24::mode	include/types/protocols.h	/^			mode_t mode;	\/* 0 to leave unchanged *\/$/;"	m	struct:listener::__anon23::__anon24	access:public
listener::__anon23::__anon24::uid	include/types/protocols.h	/^			uid_t uid;	\/* -1 to leave unchanged *\/$/;"	m	struct:listener::__anon23::__anon24	access:public
listener::__anon23::ux	include/types/protocols.h	/^		} ux;$/;"	m	union:listener::__anon23	typeref:struct:listener::__anon23::__anon24	access:public
listener::__anon25::file	include/types/protocols.h	/^		const char *file;	\/* file where the section appears *\/$/;"	m	struct:listener::__anon25	access:public
listener::__anon25::id	include/types/protocols.h	/^		struct eb32_node id;	\/* place in the tree of used IDs *\/$/;"	m	struct:listener::__anon25	typeref:struct:listener::__anon25::eb32_node	access:public
listener::__anon25::line	include/types/protocols.h	/^		int line;		\/* line where the section appears *\/$/;"	m	struct:listener::__anon25	access:public
listener::accept	include/types/protocols.h	/^	int (*accept)(int fd);		\/* accept() function passed to fdtab[] *\/$/;"	m	struct:listener	access:public
listener::addr	include/types/protocols.h	/^	struct sockaddr_storage addr;	\/* the address we listen to *\/$/;"	m	struct:listener	typeref:struct:listener::sockaddr_storage	access:public
listener::analysers	include/types/protocols.h	/^	unsigned int analysers;		\/* bitmap of required protocol analysers *\/$/;"	m	struct:listener	access:private
listener::backlog	include/types/protocols.h	/^	unsigned int backlog;		\/* if set, listen backlog *\/$/;"	m	struct:listener	access:public
listener::conf	include/types/protocols.h	/^	} conf;				\/* config information *\/$/;"	m	struct:listener	typeref:struct:listener::__anon25	access:private
listener::counters	include/types/protocols.h	/^	struct licounters *counters;	\/* statistics counters *\/$/;"	m	struct:listener	typeref:struct:listener::licounters	access:public
listener::fd	include/types/protocols.h	/^	int fd;				\/* the listen socket *\/$/;"	m	struct:listener	access:public
listener::handler	include/types/protocols.h	/^	struct task * (*handler)(struct task *t); \/* protocol handler. It is a task *\/$/;"	m	struct:listener	typeref:struct:listener::handler	access:public
listener::interface	include/types/protocols.h	/^	char *interface;		\/* interface name or NULL *\/$/;"	m	struct:listener	access:private
listener::luid	include/types/protocols.h	/^	int luid;			\/* listener universally unique ID, used for SNMP *\/$/;"	m	struct:listener	access:public
listener::maxconn	include/types/protocols.h	/^	int maxconn;			\/* maximum connections allowed on this listener *\/$/;"	m	struct:listener	access:public
listener::maxseg	include/types/protocols.h	/^	int maxseg;			\/* for TCP, advertised MSS *\/$/;"	m	struct:listener	access:private
listener::name	include/types/protocols.h	/^	char *name;			\/* *\/$/;"	m	struct:listener	access:public
listener::nbconn	include/types/protocols.h	/^	int nbconn;			\/* current number of connections on this listener *\/$/;"	m	struct:listener	access:public
listener::next	include/types/protocols.h	/^	struct listener *next;		\/* next address for the same proxy, or NULL *\/$/;"	m	struct:listener	typeref:struct:listener::listener	access:public
listener::nice	include/types/protocols.h	/^	int nice;			\/* nice value to assign to the instanciated tasks *\/$/;"	m	struct:listener	access:private
listener::options	include/types/protocols.h	/^	int options;			\/* socket options : LI_O_* *\/$/;"	m	struct:listener	access:public
listener::perm	include/types/protocols.h	/^	} perm;$/;"	m	struct:listener	typeref:union:listener::__anon23	access:private
listener::proto	include/types/protocols.h	/^	struct protocol *proto;		\/* protocol this listener belongs to *\/$/;"	m	struct:listener	typeref:struct:listener::protocol	access:public
listener::proto_list	include/types/protocols.h	/^	struct list proto_list;         \/* list in the protocol header *\/$/;"	m	struct:listener	typeref:struct:listener::list	access:public
listener::state	include/types/protocols.h	/^	int state;			\/* state: NEW, INIT, ASSIGNED, LISTEN, READY, FULL *\/$/;"	m	struct:listener	access:public
listener::timeout	include/types/protocols.h	/^	int  *timeout;                  \/* pointer to client-side timeout *\/$/;"	m	struct:listener	access:public
listeners	include/types/global.h	/^extern int listeners;$/;"	x
listeners	include/types/protocols.h	/^	struct list listeners;				\/* list of listeners using this protocol *\/$/;"	m	struct:protocol	typeref:struct:protocol::list	access:public
listeners	src/proxy.c	/^int listeners;	\/* # of proxy listeners, set by cfgparse, unset by maintain_proxies *\/$/;"	v
ll	include/types/acl.h	/^		long long ll;   \/* any long long or smaller *\/$/;"	m	union:acl_test::__anon53	access:public
local_port	include/types/fd.h	/^	int local_port;                      \/* optional local port *\/$/;"	m	struct:fdinfo	access:public
log_facilities	src/log.c	/^const char *log_facilities[NB_LOG_FACILITIES] = {$/;"	v
log_len	src/proto_http.c	/^				int log_len = val_end - att_beg;$/;"	l
log_levels	src/log.c	/^const char *log_levels[NB_LOG_LEVELS] = {$/;"	v
log_ptr	src/log.c	/^	char *log_ptr;$/;"	l
logfac1	include/types/global.h	/^	int logfac1, logfac2;$/;"	m	struct:global	access:public
logfac1	include/types/proxy.h	/^	signed char logfac1, logfac2;		\/* log facility for both servers. -1 = disabled *\/$/;"	m	struct:proxy	access:public
logfac2	include/types/global.h	/^	int logfac1, logfac2;$/;"	m	struct:global	access:public
logfac2	include/types/proxy.h	/^	signed char logfac1, logfac2;		\/* log facility for both servers. -1 = disabled *\/$/;"	m	struct:proxy	access:public
logfdinet	src/log.c	/^	static int logfdinet = -1;	\/* syslog to AF_INET socket *\/$/;"	l	file:
logfdunix	src/log.c	/^	static int logfdunix = -1;	\/* syslog to AF_UNIX socket *\/$/;"	l	file:
loglev1	include/types/global.h	/^	int loglev1, loglev2;$/;"	m	struct:global	access:public
loglev1	include/types/proxy.h	/^	int loglev1, loglev2;			\/* log level for each server, 7 by default *\/$/;"	m	struct:proxy	access:public
loglev2	include/types/global.h	/^	int loglev1, loglev2;$/;"	m	struct:global	access:public
loglev2	include/types/proxy.h	/^	int loglev1, loglev2;			\/* log level for each server, 7 by default *\/$/;"	m	struct:proxy	access:public
loglevel	src/log.c	/^	int facilities[2], loglevel[2], minlvl[2];$/;"	l
logmsg	src/log.c	/^	static char logmsg[MAX_SYSLOG_LEN];$/;"	l	file:
logs	include/types/session.h	/^	} logs;$/;"	m	struct:session	typeref:struct:session::__anon8	access:public
logsrv	include/types/log.h	/^struct logsrv {$/;"	s
logsrv	src/cfgparse.c	/^		struct logsrv logsrv;$/;"	l
logsrv	src/log.c	/^		const struct logsrv *logsrv = logsrvs[nblogger];$/;"	l
logsrv1	include/types/global.h	/^	struct logsrv logsrv1, logsrv2;$/;"	m	struct:global	typeref:struct:global::logsrv	access:public
logsrv1	include/types/proxy.h	/^	struct logsrv logsrv1, logsrv2;		\/* 2 syslog servers *\/$/;"	m	struct:proxy	typeref:struct:proxy::logsrv	access:public
logsrv2	include/types/global.h	/^	struct logsrv logsrv1, logsrv2;$/;"	m	struct:global	typeref:struct:global::	access:public
logsrv2	include/types/proxy.h	/^	struct logsrv logsrv1, logsrv2;		\/* 2 syslog servers *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
logsrv::__anon1::addr	include/types/log.h	/^		struct sockaddr addr;$/;"	m	union:logsrv::__anon1	typeref:struct:logsrv::__anon1::sockaddr	access:public
logsrv::__anon1::in	include/types/log.h	/^		struct sockaddr_in in;	\/* AF_INET *\/$/;"	m	union:logsrv::__anon1	typeref:struct:logsrv::__anon1::sockaddr_in	access:public
logsrv::__anon1::un	include/types/log.h	/^		struct sockaddr_un un;	\/* AF_UNIX *\/$/;"	m	union:logsrv::__anon1	typeref:struct:logsrv::__anon1::sockaddr_un	access:public
logsrv::u	include/types/log.h	/^	} u;$/;"	m	struct:logsrv	typeref:union:logsrv::__anon1	access:public
logsrv_addrlen	src/log.c	/^static inline int logsrv_addrlen(const struct logsrv *logsrv)$/;"	f	file:	signature:(const struct logsrv *logsrv)
logsrvs	src/log.c	/^	struct logsrv *logsrvs[2];$/;"	l
logwait	include/types/session.h	/^		int logwait;			\/* log fields waiting to be collected : LW_* *\/$/;"	m	struct:session::__anon8	access:public
loop	tests/test_pools.c	/^	const int loop = 1000;$/;"	l
looping	src/ev_sepoll.c	/^	int looping = 0;$/;"	l
lpos	include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server	access:public
lr	include/types/buffers.h	/^	char *r, *w, *lr;               \/* read ptr, write ptr, last read *\/$/;"	m	struct:buffer	access:public
lr	include/types/checks.h	/^	unsigned char lr[HANA_OBS_SIZE];	\/* result for l4\/l7: 0 = ignore, 1 - error, 2 - OK *\/$/;"	m	struct:analyze_status	access:public
lskerr	src/checks.c	/^		socklen_t lskerr = sizeof(skerr);$/;"	l
lskerr	src/stream_sock.c	/^			socklen_t lskerr = sizeof(skerr);$/;"	l
ltrim	include/common/standard.h	/^static inline char *ltrim(char *s, char c) {$/;"	f	signature:(char *s, char c)
luid	include/types/protocols.h	/^	int luid;			\/* listener universally unique ID, used for SNMP *\/$/;"	m	struct:listener	access:public
m	contrib/halog/halog.c	/^			unsigned int d, h, m, s, ms;$/;"	l
m	contrib/halog/halog.c	/^	unsigned int h, m, s, ms;$/;"	l
m	src/proto_http.c	/^	unsigned char m;$/;"	l
m1	include/types/acl.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:acl_time	access:public
m2	include/types/acl.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:acl_time	access:public
m_l	include/types/proto_http.h	/^			int m_l;               \/* METHOD length (method starts at ->som) *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
main	contrib/base64/base64rev-gen.c	/^int main() {$/;"	f
main	contrib/halog/fgets2-64.c	/^int main() {$/;"	f
main	contrib/halog/fgets2.c	/^int main() {$/;"	f
main	contrib/halog/halog.c	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	src/haproxy.c	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	tests/filltab25.c	/^main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	tests/ip-hash.c	/^int main() {$/;"	f
main	tests/reset.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	tests/sessionhash_test.c	/^int main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
main	tests/test.c	/^main() {$/;"	f
main	tests/test_hashes.c	/^int main(){$/;"	f
main	tests/test_pools.c	/^int main(void)$/;"	f	signature:(void)
main	tests/testinet.c	/^main() {$/;"	f
main	tests/uri_hash.c	/^int main() {$/;"	f
maintain_proxies	include/proto/proxy.h	/^void maintain_proxies(int *next);$/;"	p	signature:(int *next)
maintain_proxies	src/proxy.c	/^void maintain_proxies(int *next)$/;"	f	signature:(int *next)
manage_client_side_appsession	include/proto/proto_http.h	/^void manage_client_side_appsession(struct session *t, const char *buf, int len);$/;"	p	signature:(struct session *t, const char *buf, int len)
manage_client_side_appsession	src/proto_http.c	/^void manage_client_side_appsession(struct session *t, const char *buf, int len) {$/;"	f	signature:(struct session *t, const char *buf, int len)
manage_client_side_cookies	include/proto/proto_http.h	/^void manage_client_side_cookies(struct session *t, struct buffer *req);$/;"	p	signature:(struct session *t, struct buffer *req)
manage_client_side_cookies	src/proto_http.c	/^void manage_client_side_cookies(struct session *t, struct buffer *req)$/;"	f	signature:(struct session *t, struct buffer *req)
manage_server_side_cookies	include/proto/proto_http.h	/^void manage_server_side_cookies(struct session *t, struct buffer *rtr);$/;"	p	signature:(struct session *t, struct buffer *rtr)
manage_server_side_cookies	src/proto_http.c	/^void manage_server_side_cookies(struct session *t, struct buffer *res)$/;"	f	signature:(struct session *t, struct buffer *res)
map	include/types/backend.h	/^	struct lb_map map;		\/* LB parameters for map-based algorithms *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_map	access:public
map_get_server_hash	include/proto/lb_map.h	/^struct server *map_get_server_hash(struct proxy *px, unsigned int hash);$/;"	p	signature:(struct proxy *px, unsigned int hash)
map_get_server_hash	src/lb_map.c	/^struct server *map_get_server_hash(struct proxy *px, unsigned int hash)$/;"	f	signature:(struct proxy *px, unsigned int hash)
map_get_server_rr	include/proto/lb_map.h	/^struct server *map_get_server_rr(struct proxy *px, struct server *srvtoavoid);$/;"	p	signature:(struct proxy *px, struct server *srvtoavoid)
map_get_server_rr	src/lb_map.c	/^struct server *map_get_server_rr(struct proxy *px, struct server *srvtoavoid)$/;"	f	signature:(struct proxy *px, struct server *srvtoavoid)
map_set_server_status_down	include/proto/lb_map.h	/^void map_set_server_status_down(struct server *srv);$/;"	p	signature:(struct server *srv)
map_set_server_status_down	src/lb_map.c	/^static void map_set_server_status_down(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
map_set_server_status_up	include/proto/lb_map.h	/^void map_set_server_status_up(struct server *srv);$/;"	p	signature:(struct server *srv)
map_set_server_status_up	src/lb_map.c	/^static void map_set_server_status_up(struct server *srv)$/;"	f	file:	signature:(struct server *srv)
mask	include/types/acl.h	/^			struct in_addr mask;$/;"	m	struct:acl_pattern::__anon49::__anon51	typeref:struct:acl_pattern::__anon49::__anon51::in_addr	access:public
mask	src/acl.c	/^		unsigned int mask = ntohl(pattern->val.ipv4.mask.s_addr);$/;"	l
mask	src/pattern.c	/^	struct in_addr mask;$/;"	l
mask	tests/ip-hash.c	/^	unsigned int mask = ~0;$/;"	l
match	include/types/acl.h	/^	int (*match)(struct acl_test *test, struct acl_pattern *pattern);$/;"	m	struct:acl_keyword	access:public
match_str	include/common/appsession.h	/^int match_str(const void *key1, const void *key2);$/;"	p	signature:(const void *key1, const void *key2)
match_str	src/appsession.c	/^int match_str(const void *key1, const void *key2)$/;"	f	signature:(const void *key1, const void *key2)
match_word	src/acl.c	/^static int match_word(struct acl_test *test, struct acl_pattern *pattern, char delim)$/;"	f	file:	signature:(struct acl_test *test, struct acl_pattern *pattern, char delim)
max	contrib/base64/base64rev-gen.c	/^	int i, min = 255, max = 0;$/;"	l
max	include/types/acl.h	/^			signed long long min, max;$/;"	m	struct:acl_pattern::__anon49::__anon50	access:public
max	src/buffers.c	/^	int max;$/;"	l
max	src/buffers.c	/^	int ret, max;$/;"	l
max	src/client.c	/^		int max = freq_ctr_remain(&p->fe_sess_per_sec, p->fe_sps_lim, 0);$/;"	l
max	src/lb_map.c	/^		int max = 0;$/;"	l
max	src/proto_http.c	/^	int len, max;$/;"	l
max	src/queue.c	/^	unsigned int max;$/;"	l
max	src/stream_sock.c	/^	int ret, max, retval, cur_read;$/;"	l
max	src/stream_sock.c	/^	int ret, max;$/;"	l
max	src/stream_sock.c	/^	unsigned long max;$/;"	l
max_accept	src/client.c	/^	int max_accept = global.tune.maxaccept;$/;"	l
max_accept	src/proto_uxst.c	/^	int max_accept;$/;"	l
max_err	tests/ip-hash.c	/^	double err, total_err, max_err;$/;"	l
max_loops	src/session.c	/^			int max_loops = global.tune.maxpollevents;$/;"	l
max_processed	src/task.c	/^	unsigned int max_processed;$/;"	l
max_set	include/types/acl.h	/^			int max_set :1;$/;"	m	struct:acl_pattern::__anon49::__anon50	access:public
maxaccept	include/types/global.h	/^		int maxaccept;     \/* max number of consecutive accept() *\/$/;"	m	struct:global::__anon16	access:public
maxconn	include/types/global.h	/^	int maxconn;$/;"	m	struct:global	access:public
maxconn	include/types/protocols.h	/^	int maxconn;			\/* maximum connections allowed on this listener *\/$/;"	m	struct:listener	access:public
maxconn	include/types/proxy.h	/^	unsigned int maxconn;			\/* max # of active sessions on the frontend *\/$/;"	m	struct:proxy	access:public
maxconn	include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server	access:public
maxconn	src/dumpstats.c	/^		int maxconn = atol(args[1]);$/;"	l
maxconn	src/queue.c	/^	int maxconn;$/;"	l
maxfd	include/types/fd.h	/^extern int maxfd;                       \/* # of the highest fd + 1 *\/$/;"	x
maxfd	src/fd.c	/^int maxfd;                      \/* # of the highest fd + 1 *\/$/;"	v
maxidle	src/cfgparse.c	/^				unsigned int maxidle;$/;"	l
maxlife	src/cfgparse.c	/^				unsigned int maxlife;$/;"	l
maxpipes	include/types/global.h	/^	int maxpipes;		\/* max # of pipes *\/$/;"	m	struct:global	access:public
maxpollevents	include/types/global.h	/^		int maxpollevents; \/* max number of poll events at once *\/$/;"	m	struct:global::__anon16	access:public
maxqueue	include/types/server.h	/^	int maxqueue;				\/* maximum number of pending connections allowed *\/$/;"	m	struct:server	access:public
maxrewrite	include/types/global.h	/^		int maxrewrite;    \/* buffer max rewrite size in bytes, defaults to MAXREWRITE *\/$/;"	m	struct:global::__anon16	access:public
maxseg	include/types/protocols.h	/^	int maxseg;			\/* for TCP, advertised MSS *\/$/;"	m	struct:listener	access:private
maxsock	include/types/global.h	/^	int maxsock;		\/* max # of sockets *\/$/;"	m	struct:global	access:public
may_dequeue_tasks	include/proto/queue.h	/^static inline int may_dequeue_tasks(const struct server *s, const struct proxy *p) {$/;"	f	signature:(const struct server *s, const struct proxy *p)
may_match	src/acl.c	/^	int may_match, icase;$/;"	l
meth	include/types/proto_http.h	/^	http_meth_t meth;               \/* HTTP method *\/$/;"	m	struct:http_txn	access:public
meth	src/proto_http.c	/^	http_meth_t meth;$/;"	m	struct:http_method_desc	file:	access:public
meth	src/proto_http.c	/^	int len, meth;$/;"	l
meth	src/proto_http.c	/^	int meth;$/;"	l
method	include/types/proto_http.h	/^	int method;			\/* one of HTTP_AUTH_* *\/$/;"	m	struct:http_auth_data	access:public
method_data	include/types/proto_http.h	/^	struct chunk method_data;	\/* points to the creditial part from 'Authorization:' header *\/$/;"	m	struct:http_auth_data	typeref:struct:http_auth_data::chunk	access:public
min	contrib/base64/base64rev-gen.c	/^	int i, min = 255, max = 0;$/;"	l
min	include/types/acl.h	/^			signed long long min, max;$/;"	m	struct:acl_pattern::__anon49::__anon50	access:public
min_set	include/types/acl.h	/^			int min_set :1;$/;"	m	struct:acl_pattern::__anon49::__anon50	access:public
minavail	include/common/memory.h	/^	unsigned int minavail;	\/* how many chunks are expected to be used *\/$/;"	m	struct:pool_head	access:public
minconn	include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server	access:public
mininter	src/checks.c	/^	int nbchk=0, mininter=0, srvpos=0;$/;"	l
minlvl	src/cfgparse.c	/^			int level, minlvl;$/;"	l
minlvl	src/cfgparse.c	/^		int facility, level, minlvl;$/;"	l
minlvl	src/log.c	/^	int facilities[2], loglevel[2], minlvl[2];$/;"	l
minlvl1	include/types/global.h	/^	int minlvl1, minlvl2;$/;"	m	struct:global	access:public
minlvl1	include/types/proxy.h	/^	int minlvl1, minlvl2;			\/* minimum log level for each server, 0 by default *\/$/;"	m	struct:proxy	access:public
minlvl2	include/types/global.h	/^	int minlvl1, minlvl2;$/;"	m	struct:global	access:public
minlvl2	include/types/proxy.h	/^	int minlvl1, minlvl2;			\/* minimum log level for each server, 0 by default *\/$/;"	m	struct:proxy	access:public
mix	tests/test_hashes.c	354;"	d	file:
mode	include/types/global.h	/^	int mode;$/;"	m	struct:global	access:public
mode	include/types/protocols.h	/^			mode_t mode;	\/* 0 to leave unchanged *\/$/;"	m	struct:listener::__anon23::__anon24	access:public
mode	include/types/proxy.h	/^	int mode;				\/* mode = PR_MODE_TCP, PR_MODE_HTTP or PR_MODE_HEALTH *\/$/;"	m	struct:proxy	access:public
mode	src/cfgparse.c	/^	unsigned int mode;$/;"	m	struct:cfg_opt	file:	access:public
mode	src/proto_http.c	/^	int mode = t->be->options2 & PR_O2_AS_M_ANY;$/;"	l
mon_fail_cond	include/types/proxy.h	/^	struct list mon_fail_cond;              \/* list of conditions to fail monitoring requests (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
mon_mask	include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
mon_net	include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr	access:public
monitor_uri	include/types/proxy.h	/^	char *monitor_uri;			\/* a special URI to which we respond with HTTP\/200 OK *\/$/;"	m	struct:proxy	access:public
monitor_uri_len	include/types/proxy.h	/^	int monitor_uri_len;			\/* length of the string above. 0 if unused *\/$/;"	m	struct:proxy	access:public
monthname	src/dumpstats.c	/^	extern const char *monthname[12];$/;"	x
monthname	src/log.c	/^const char *monthname[12] = {$/;"	v
monthname	src/proto_http.c	/^extern const char *monthname[12];$/;"	x
mrule	src/cfgparse.c	/^		struct sticking_rule *mrule;$/;"	l
ms	contrib/halog/halog.c	/^			unsigned int d, h, m, s, ms;$/;"	l
ms	contrib/halog/halog.c	/^	unsigned int h, m, s, ms;$/;"	l
msg	include/types/session.h	/^			const char *msg;	\/* pointer to a persistent message to be returned in PRINT state *\/$/;"	m	struct:session::__anon9::__anon13	access:public
msg	src/backend.c	/^	struct http_msg *msg  = &txn->req;$/;"	l
msg	src/cfgparse.c	/^	char *msg;$/;"	l
msg	src/checks.c	/^	struct chunk msg;$/;"	l
msg	src/client.c	/^			struct chunk msg;$/;"	l
msg	src/dumpstats.c	/^	struct chunk msg;$/;"	l
msg	src/proto_http.c	/^		struct chunk msg;$/;"	l
msg	src/proto_http.c	/^	int msg;$/;"	l
msg	src/proto_http.c	/^	struct http_msg *msg = &s->txn.req;$/;"	l
msg	src/proto_http.c	/^	struct http_msg *msg = &s->txn.rsp;$/;"	l
msg	src/proto_http.c	/^	struct http_msg *msg = &txn->req;$/;"	l
msg	src/proto_http.c	/^	struct http_msg *msg = &txn->rsp;$/;"	l
msg	src/proto_tcp.c	/^			char *msg;$/;"	l
msg	src/proto_tcp.c	/^	const char *msg = NULL;$/;"	l
msg	src/proxy.c	/^	char msg[100];$/;"	l
msg_fmt	src/proto_http.c	/^			const char *msg_fmt;$/;"	l
msg_len	src/proto_tcp.c	/^	int version, bleft, msg_len;$/;"	l
msg_state	include/types/proto_http.h	/^	unsigned int msg_state;                \/* where we are in the current message parsing *\/$/;"	m	struct:http_msg	access:public
msglen	src/checks.c	/^	unsigned short msglen;$/;"	l
mss	src/cfgparse.c	/^				int mss;$/;"	l
mul32hi	include/common/standard.h	/^static inline unsigned int mul32hi(unsigned int a, unsigned int b)$/;"	f	signature:(unsigned int a, unsigned int b)
my_strndup	include/common/standard.h	/^char *my_strndup(const char *src, int n);$/;"	p	signature:(const char *src, int n)
my_strndup	src/standard.c	/^char *my_strndup(const char *src, int n)$/;"	f	signature:(const char *src, int n)
myidx	src/cfgparse.c	/^		int myidx = 0;$/;"	l
myidx	src/cfgparse.c	/^		int myidx = 1;$/;"	l
mysqluser	src/cfgparse.c	/^						char *mysqluser;$/;"	l
n	contrib/halog/halog.c	/^			struct eb32_node *n;$/;"	l
n	contrib/halog/halog.c	/^		struct eb32_node *n[5];$/;"	l
n	contrib/halog/halog.c	/^	struct eb32_node *n;$/;"	l
n	include/common/mini-clist.h	/^    struct list *n;	\/* next *\/$/;"	m	struct:list	typeref:struct:list::list	access:public
n	src/proto_http.c	/^		int n;$/;"	l
n	src/proto_http.c	/^	int n;$/;"	l
n	src/rbtree.c	/^	struct rb_node	*n;$/;"	l
n	src/session.c	/^		int n;$/;"	l
name	include/common/memory.h	/^	char name[12];		\/* name of the pool *\/$/;"	m	struct:pool_head	access:public
name	include/types/acl.h	/^	char *name;		    \/* acl name *\/$/;"	m	struct:acl	access:public
name	include/types/auth.h	/^	char *name;$/;"	m	struct:userlist	access:public
name	include/types/capture.h	/^    char *name;				\/* header name, case insensitive *\/$/;"	m	struct:cap_hdr	access:public
name	include/types/fd.h	/^	const char   *name;                                  \/* poller name *\/$/;"	m	struct:poller	access:private
name	include/types/protocols.h	/^	char *name;			\/* *\/$/;"	m	struct:listener	access:public
name	include/types/protocols.h	/^	char name[PROTO_NAME_LEN];			\/* protocol name, zero-terminated *\/$/;"	m	struct:protocol	access:public
name	include/types/proxy.h	/^		char *name;			\/* default backend name during config parse *\/$/;"	m	union:proxy::__anon17	access:public
name	include/types/proxy.h	/^		char *name;			\/* target backend name during config parsing *\/$/;"	m	union:switching_rule::__anon21	access:public
name	include/types/proxy.h	/^		char *name;                     \/* target table name during config parsing *\/$/;"	m	union:sticking_rule::__anon22	access:public
name	src/acl.c	/^	char *name;$/;"	l
name	src/acl.c	/^	const char *name;$/;"	m	struct:__anon66	file:	access:public
name	src/cfgparse.c	/^							char *name, *end;$/;"	l
name	src/cfgparse.c	/^					char *name, *end;$/;"	l
name	src/cfgparse.c	/^		const char *name = NULL;$/;"	l
name	src/cfgparse.c	/^	const char *name;$/;"	m	struct:cfg_opt	file:	access:public
name	src/proto_tcp.c	/^			const char *name;$/;"	l
name	src/proxy.c	/^	char *res, *name;$/;"	l
name	src/proxy.c	/^	const char *res, *name;$/;"	l
namelen	include/types/capture.h	/^    int namelen;			\/* length of the header name, to speed-up lookups *\/$/;"	m	struct:cap_hdr	access:public
namelen	src/client.c	/^	socklen_t namelen = sizeof(s->frt_addr);$/;"	l
nb_ct	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:	access:public
nb_err	contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:	access:public
nb_listeners	include/types/protocols.h	/^	int nb_listeners;				\/* number of listeners *\/$/;"	m	struct:protocol	access:public
nb_ok	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:	access:public
nb_oldpids	include/types/global.h	/^extern int nb_oldpids;          \/* contains the number of old pids found *\/$/;"	x
nb_oldpids	src/haproxy.c	/^int nb_oldpids = 0;$/;"	v
nb_req	contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:	access:public
nb_req_cap	include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy	access:public
nb_rsp_cap	include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy	access:public
nb_rt	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:	access:public
nb_tasks	include/proto/task.h	/^extern unsigned int nb_tasks;     \/* total number of tasks *\/$/;"	x
nb_tasks	src/task.c	/^unsigned int nb_tasks = 0;$/;"	v
nb_tasks_cur	include/proto/task.h	/^extern unsigned int nb_tasks_cur;$/;"	x
nb_tasks_cur	src/task.c	/^unsigned int nb_tasks_cur = 0;     \/* copy of the tasks count *\/$/;"	v
nbbe	src/haproxy.c	/^		int nbfe = 0, nbbe = 0;$/;"	l
nbchanges	src/ev_epoll.c	/^static int nbchanges = 0;		\/\/ number of changes pending$/;"	v	file:
nbchk	src/checks.c	/^	int nbchk=0, mininter=0, srvpos=0;$/;"	l
nbconn	include/types/protocols.h	/^	int nbconn;			\/* current number of connections on this listener *\/$/;"	m	struct:listener	access:public
nbfd	src/ev_poll.c	/^	int fd, nbfd;$/;"	l
nbfe	src/haproxy.c	/^		int nbfe = 0, nbbe = 0;$/;"	l
nblogger	src/log.c	/^	int nblogger;$/;"	l
nbloggers	src/log.c	/^	int nbloggers = 0;$/;"	l
nbpend	include/types/proxy.h	/^	int nbpend;				\/* number of pending connections with no server assigned yet *\/$/;"	m	struct:proxy	access:public
nbpend	include/types/server.h	/^	int nbpend;				\/* number of pending connections *\/$/;"	m	struct:server	access:public
nbpend_max	include/types/counters.h	/^	unsigned int nbpend_max;		\/* max number of pending connections reached *\/$/;"	m	struct:srvcounters	access:public
nbpend_max	include/types/counters.h	/^	unsigned int nbpend_max;		\/* max number of pending connections with no server assigned yet *\/$/;"	m	struct:pxcounters	access:public
nbpollers	include/types/fd.h	/^extern int nbpollers;$/;"	x
nbpollers	src/fd.c	/^int nbpollers = 0;$/;"	v
nbpools	src/memory.c	/^	int nbpools;$/;"	l
nbproc	include/types/global.h	/^	int nbproc;$/;"	m	struct:global	access:public
nbspec	src/ev_sepoll.c	/^static int nbspec = 0;          \/\/ current size of the spec list$/;"	v	file:
nbsrv	src/backend.c	/^	int nbsrv;$/;"	l
neg	include/types/acl.h	/^	int neg;                    \/* 1 if the ACL result must be negated *\/$/;"	m	struct:acl_term	access:public
neg	src/acl.c	/^	int arg, neg;$/;"	l
new	src/cfgparse.c	/^			struct listener *new, *last = curproxy->listen;$/;"	l
new	src/hdr_idx.c	/^	int new;$/;"	l
new	src/pattern.c	/^			u_int new = *tp * 10 + digit;$/;"	l
new	src/standard.c	/^			u_int new = *tp * 10 + digit;$/;"	l
new_leaf	ebtree/eb32tree.h	/^	eb_troot_t *new_leaf;$/;"	l
new_leaf	ebtree/eb64tree.h	/^			eb_troot_t *new_leaf, *old_leaf;$/;"	l
new_leaf	ebtree/eb64tree.h	/^			eb_troot_t *new_leaf, *old_node;$/;"	l
new_leaf	ebtree/ebimtree.h	/^			eb_troot_t *new_leaf, *old_leaf;$/;"	l
new_leaf	ebtree/ebimtree.h	/^			eb_troot_t *new_leaf, *old_node;$/;"	l
new_leaf	ebtree/ebistree.h	/^			eb_troot_t *new_leaf, *old_leaf;$/;"	l
new_leaf	ebtree/ebistree.h	/^			eb_troot_t *new_leaf, *old_node;$/;"	l
new_leaf	ebtree/ebmbtree.h	/^	eb_troot_t *new_leaf;$/;"	l
new_leaf	ebtree/ebsttree.h	/^			eb_troot_t *new_leaf, *old_leaf;$/;"	l
new_leaf	ebtree/ebsttree.h	/^			eb_troot_t *new_leaf, *old_node;$/;"	l
new_leaf	ebtree/ebtree.h	/^	struct eb_troot *new_leaf = eb_dotag(&new->branches, EB_LEAF);$/;"	l
new_left	ebtree/eb32tree.h	/^	eb_troot_t *new_left, *new_rght;$/;"	l
new_left	ebtree/eb64tree.h	/^			eb_troot_t *new_left, *new_rght;$/;"	l
new_left	ebtree/ebimtree.h	/^			eb_troot_t *new_left, *new_rght;$/;"	l
new_left	ebtree/ebistree.h	/^			eb_troot_t *new_left, *new_rght;$/;"	l
new_left	ebtree/ebmbtree.h	/^	eb_troot_t *new_left, *new_rght;$/;"	l
new_left	ebtree/ebsttree.h	/^			eb_troot_t *new_left, *new_rght;$/;"	l
new_left	ebtree/ebtree.h	/^	struct eb_troot *new_left = eb_dotag(&new->branches, EB_LEFT);$/;"	l
new_len	src/cfgparse.c	/^					int new_len = strlen(curproxy->cookie_domain) +$/;"	l
new_listen	src/cfgparse.c	/^		struct listener *new_listen, *last_listen;$/;"	l
new_name	src/uri_auth.c	/^	char *new_name;$/;"	l
new_ptr	src/cfgparse.c	/^					char *new_ptr;$/;"	l
new_rght	ebtree/eb32tree.h	/^	eb_troot_t *new_left, *new_rght;$/;"	l
new_rght	ebtree/eb64tree.h	/^			eb_troot_t *new_left, *new_rght;$/;"	l
new_rght	ebtree/ebimtree.h	/^			eb_troot_t *new_left, *new_rght;$/;"	l
new_rght	ebtree/ebistree.h	/^			eb_troot_t *new_left, *new_rght;$/;"	l
new_rght	ebtree/ebmbtree.h	/^	eb_troot_t *new_left, *new_rght;$/;"	l
new_rght	ebtree/ebsttree.h	/^			eb_troot_t *new_left, *new_rght;$/;"	l
new_rght	ebtree/ebtree.h	/^	struct eb_troot *new_rght = eb_dotag(&new->branches, EB_RGHT);$/;"	l
new_state	src/lb_chash.c	/^	int old_state, new_state;$/;"	l
new_state	src/lb_fwlc.c	/^	int old_state, new_state;$/;"	l
new_state	src/lb_fwrr.c	/^	int old_state, new_state;$/;"	l
new_str	src/acl.c	/^		char *new_str;$/;"	l
newidx	src/lb_map.c	/^	int newidx, avoididx;$/;"	l
newkey	ebtree/eb32tree.h	/^	int newkey; \/* caching the key saves approximately one cycle *\/$/;"	l
newkey	ebtree/eb32tree.h	/^	u32 newkey; \/* caching the key saves approximately one cycle *\/$/;"	l
newkey	ebtree/eb64tree.h	/^	u64 newkey; \/* caching the key saves approximately one cycle *\/$/;"	l
newline	src/dumpstats.c	/^			int newline;$/;"	l
newptr	src/dumpstats.c	/^			int newptr;$/;"	l
newsrv	src/cfgparse.c	/^	struct server *newsrv = NULL;$/;"	l
newul	src/cfgparse.c	/^		struct userlist *newul;$/;"	l
newuser	src/cfgparse.c	/^		struct auth_users *newuser;$/;"	l
newuser	src/uri_auth.c	/^	struct auth_users *newuser;$/;"	l
next	contrib/halog/fgets2-64.c	/^	char *next;$/;"	l
next	contrib/halog/fgets2.c	/^	char *next;$/;"	l
next	contrib/halog/halog.c	/^				struct eb32_node *next;$/;"	l
next	contrib/halog/halog.c	/^		struct eb_node *node, *next;$/;"	l
next	include/common/memory.h	/^	void *temp, *next;$/;"	l
next	include/common/regex.h	/^    struct hdr_exp *next;$/;"	m	struct:hdr_exp	typeref:struct:hdr_exp::hdr_exp	access:public
next	include/common/uri_auth.h	/^	struct stat_scope *next;	\/* next entry, NULL if none *\/$/;"	m	struct:stat_scope	typeref:struct:stat_scope::stat_scope	access:public
next	include/common/uri_auth.h	/^	struct uri_auth *next;		\/* Used at deinit() to build a list of unique elements *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::uri_auth	access:public
next	include/types/auth.h	/^	struct auth_users *next;$/;"	m	struct:auth_users	typeref:struct:auth_users::auth_users	access:public
next	include/types/auth.h	/^	struct userlist *next;$/;"	m	struct:userlist	typeref:struct:userlist::userlist	access:public
next	include/types/capture.h	/^    struct cap_hdr *next;$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::cap_hdr	access:public
next	include/types/hdr_idx.h	/^        unsigned next :15; \/* offset of next header if len>0. 0=end of list. *\/$/;"	m	struct:hdr_idx_elem	access:public
next	include/types/lb_fwrr.h	/^	struct eb_root *next;   \/* servers to be placed at next run *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root	access:public
next	include/types/pipe.h	/^	struct pipe *next;$/;"	m	struct:pipe	typeref:struct:pipe::pipe	access:public
next	include/types/protocols.h	/^	struct listener *next;		\/* next address for the same proxy, or NULL *\/$/;"	m	struct:listener	typeref:struct:listener::listener	access:public
next	include/types/proxy.h	/^	struct proxy *next;$/;"	m	struct:proxy	typeref:struct:proxy::proxy	access:public
next	include/types/server.h	/^	struct server *next;$/;"	m	struct:server	typeref:struct:server::server	access:public
next	src/acl.c	/^	struct eb_node *node, *next;$/;"	l
next	src/cfgparse.c	/^			struct listener *next;$/;"	l
next	src/cfgparse.c	/^			struct server *next;$/;"	l
next	src/cfgparse.c	/^		struct proxy *next;$/;"	l
next	src/cfgparse.c	/^	char *c, *next, *range, *dupstr;$/;"	l
next	src/ev_epoll.c	/^	int prev, next;$/;"	l
next	src/fd.c	/^	int last, next;$/;"	l
next	src/haproxy.c	/^	int next;$/;"	l
next	src/lb_chash.c	/^	struct eb32_node *next, *prev;$/;"	l
next	src/memory.c	/^		void *temp, *next;$/;"	l
next	src/memory.c	/^	void *temp, *next;$/;"	l
next	src/proto_http.c	/^	char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;$/;"	l
next	tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:	access:public
next	tests/test_hashes.c	/^	register uint32_t next;$/;"	l
next	tests/test_pools.c	/^	void *temp, *next;$/;"	l
next	tests/uri_hash.c	/^	register uint32_t next;$/;"	l
next_event_delay	include/proto/freq_ctr.h	/^unsigned int next_event_delay(struct freq_ctr *ctr, unsigned int freq, unsigned int pend);$/;"	p	signature:(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)
next_event_delay	src/freq_ctr.c	/^unsigned int next_event_delay(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)$/;"	f	signature:(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)
next_full	include/types/server.h	/^	struct server *next_full;               \/* next server in the temporary full list *\/$/;"	m	struct:server	typeref:struct:server::server	access:public
next_id	src/cfgparse.c	/^		unsigned int next_id;$/;"	l
next_param	src/proto_http.c	/^	char *end_params, *first_param, *cur_param, *next_param;$/;"	l
next_param	src/proto_http.c	/^	char *first_param, *cur_param, *next_param, *end_params;$/;"	l
next_pxid	src/cfgparse.c	/^	unsigned int next_pxid = 1;$/;"	l
next_tree	tests/filltab25.c	/^struct eb_root *next_tree; \/* receives positions >= 2sw *\/$/;"	v	typeref:struct:eb_root
next_weight	include/types/lb_fwrr.h	/^	int next_weight;        \/* total weight of the next time range *\/$/;"	m	struct:fwrr_group	access:public
nice	include/types/protocols.h	/^	int nice;			\/* nice value to assign to the instanciated tasks *\/$/;"	m	struct:listener	access:private
nice	include/types/task.h	/^	int nice;			\/* the task's current nice value from -1024 to +1024 *\/$/;"	m	struct:task	access:public
niced_tasks	include/proto/task.h	/^extern unsigned int niced_tasks;  \/* number of niced tasks in the run queue *\/$/;"	x
niced_tasks	src/task.c	/^unsigned int niced_tasks = 0;      \/* number of niced tasks in the run queue *\/$/;"	v
no_options	include/types/proxy.h	/^	int no_options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy	access:public
no_options2	include/types/proxy.h	/^	int no_options2;			\/* PR_O2_* *\/$/;"	m	struct:proxy	access:public
node	contrib/halog/halog.c	/^		struct eb_node *node, *next;$/;"	l
node	contrib/halog/halog.c	/^	struct eb32_node node;$/;"	m	struct:timer	typeref:struct:timer::eb32_node	file:	access:public
node	contrib/halog/halog.c	/^	struct ebmb_node node;$/;"	m	struct:srv_st	typeref:struct:srv_st::ebmb_node	file:	access:public
node	contrib/halog/halog.c	/^	} node;$/;"	m	struct:url_stat	typeref:union:url_stat::__anon67	file:	access:public
node	ebtree/eb32tree.c	/^	struct eb32_node *node;$/;"	l
node	ebtree/eb32tree.h	/^	struct eb32_node *node;$/;"	l
node	ebtree/eb32tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb32_node	typeref:struct:eb32_node::eb_node	access:public
node	ebtree/eb64tree.c	/^	struct eb64_node *node;$/;"	l
node	ebtree/eb64tree.h	/^	struct eb64_node *node;$/;"	l
node	ebtree/eb64tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb64_node	typeref:struct:eb64_node::eb_node	access:public
node	ebtree/ebimtree.h	/^	struct ebpt_node *node;$/;"	l
node	ebtree/ebistree.c	/^	struct ebpt_node *node;$/;"	l
node	ebtree/ebistree.h	/^	struct ebpt_node *node;$/;"	l
node	ebtree/ebmbtree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebmb_node	typeref:struct:ebmb_node::eb_node	access:public
node	ebtree/ebmbtree.h	/^	struct ebmb_node *node;$/;"	l
node	ebtree/ebpttree.c	/^	struct ebpt_node *node;$/;"	l
node	ebtree/ebpttree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebpt_node	typeref:struct:ebpt_node::eb_node	access:public
node	ebtree/ebsttree.c	/^	struct ebmb_node *node;$/;"	l
node	ebtree/ebsttree.h	/^	struct ebmb_node *node;$/;"	l
node	include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth	access:public
node	include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global	access:public
node	include/types/server.h	/^	struct eb32_node node;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::eb32_node	access:public
node	src/acl.c	/^		struct ebmb_node *node;$/;"	l
node	src/acl.c	/^	struct eb_node *node, *next;$/;"	l
node	src/acl.c	/^	struct ebmb_node *node;$/;"	l
node	src/cfgparse.c	/^				struct eb32_node *node;$/;"	l
node	src/cfgparse.c	/^		struct eb32_node *node;$/;"	l
node	src/lb_chash.c	/^	int node;$/;"	l
node	src/lb_chash.c	/^	struct eb32_node *node, *stop, *avoided_node;$/;"	l
node	src/lb_fwlc.c	/^	struct eb32_node *node;$/;"	l
node	src/lb_fwrr.c	/^	struct eb32_node *node;$/;"	l
node	src/session.c	/^						struct eb32_node *node;$/;"	l
node	tests/filltab25.c	/^		struct eb32_node *node;$/;"	l
node	tests/filltab25.c	/^	struct eb32_node *node;$/;"	l
node	tests/filltab25.c	/^	struct eb32_node node;$/;"	m	struct:srv	typeref:struct:srv::eb32_node	file:	access:public
node2	src/lb_fwrr.c	/^		struct eb32_node *node2;$/;"	l
node2	tests/filltab25.c	/^		struct eb32_node *node2;$/;"	l
node_bit	ebtree/eb32tree.h	/^	int node_bit;$/;"	l
node_bit	ebtree/eb64tree.h	/^	int node_bit;$/;"	l
node_bit	ebtree/ebimtree.h	/^	int node_bit;$/;"	l
node_bit	ebtree/ebistree.h	/^	int node_bit;$/;"	l
node_bit	ebtree/ebmbtree.h	/^	int node_bit;$/;"	l
node_bit	ebtree/ebsttree.h	/^	int node_bit;$/;"	l
node_copy	src/uri_auth.c	/^	char *node_copy = NULL;$/;"	l
node_p	ebtree/ebtree.h	/^	eb_troot_t    *node_p;  \/* link node's parent *\/$/;"	m	struct:eb_node	access:public
nolinger	include/types/global.h	/^extern const struct linger nolinger;$/;"	x
nolinger	src/haproxy.c	/^const struct linger nolinger = { .l_onoff = 1, .l_linger = 0 };$/;"	v	typeref:struct:linger
nolinger	tests/reset.c	/^	const struct linger nolinger = { .l_onoff = 1, .l_linger = 0 };$/;"	l
nopurge	include/types/stick_table.h	/^	int nopurge;              \/* 1 never purge stuck sessions *\/$/;"	m	struct:stktable	access:public
now	include/common/time.h	/^extern struct timeval now;              \/* internal date is a monotonic function of real clock *\/$/;"	x
now	src/time.c	/^struct timeval now;             \/* internal date is a monotonic function of real clock *\/$/;"	v	typeref:struct:timeval
now_ms	include/common/time.h	/^extern unsigned int   now_ms;           \/* internal date in milliseconds (may wrap) *\/$/;"	x
now_ms	src/time.c	/^unsigned int   now_ms;          \/* internal date in milliseconds (may wrap) *\/$/;"	v
npos	include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server	access:public
nr	tests/ip-hash.c	/^	int nr;$/;"	l
nsrv	src/lb_chash.c	/^	struct server *nsrv, *psrv;$/;"	l
nsrv	tests/filltab25.c	/^int nsrv;       \/* # of servers *\/$/;"	v
nsrv	tests/ip-hash.c	/^	int srv, nsrv;$/;"	l
nsrv	tests/uri_hash.c	/^    int srv, nsrv;$/;"	l
nsw	tests/filltab25.c	/^int nsw, sw;    \/* sum of weights *\/$/;"	v
num	src/regex.c	/^				int len, num;$/;"	l
num	tests/filltab25.c	/^			int num = \/*1*\/\/**\/random()%nsrv\/**\/;$/;"	l
num	tests/filltab25.c	/^	int num;$/;"	m	struct:srv	file:	access:public
o	src/lb_map.c	/^	int o, tot, flag;$/;"	l
o_left	src/rbtree.c	/^					register struct rb_node *o_left;$/;"	l
o_right	src/rbtree.c	/^					register struct rb_node *o_right;$/;"	l
oat_hash	tests/test_hashes.c	/^unsigned oat_hash ( void *key, int len )$/;"	f	signature:( void *key, int len )
ob	include/types/stream_interface.h	/^	struct buffer *ib, *ob; \/* input and output buffers *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::	access:public
ob	src/stream_interface.c	/^	struct buffer *ob = si->ob;$/;"	l
ob	src/stream_sock.c	/^	struct buffer *ob = si->ob;$/;"	l
observe	include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server	access:public
octets	src/pattern.c	/^	int saw_digit, octets, ch;$/;"	l
octets	src/standard.c	/^	int saw_digit, octets, ch;$/;"	l
odiv	src/standard.c	/^	unsigned omult, odiv;$/;"	l
oe	include/types/proxy.h	/^	struct proxy *oe;		\/* other end = frontend or backend involved *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::proxy	access:public
off	src/proto_http.c	/^	int off = buf->data + buf->size - buf->w;$/;"	l
offset	src/task.c	/^		int offset;$/;"	l
offsetof	include/common/rbtree.h	121;"	d
ofs	ebtree/ebtree.h	/^	unsigned int ofs;$/;"	l
ofs	src/ev_epoll.c	/^	uint32_t ofs = FD2OFS(fd);$/;"	l
ofs	src/ev_epoll.c	/^	uint32_t ofs;$/;"	l
old	ebtree/eb32tree.h	/^	struct eb32_node *old;$/;"	l
old	ebtree/eb64tree.h	/^	struct eb64_node *old;$/;"	l
old	ebtree/ebimtree.h	/^	struct ebpt_node *old;$/;"	l
old	ebtree/ebistree.h	/^	struct ebpt_node *old;$/;"	l
old	ebtree/ebmbtree.h	/^	struct ebmb_node *old;$/;"	l
old	ebtree/ebsttree.h	/^	struct ebmb_node *old;$/;"	l
old	src/rbtree.c	/^		struct rb_node *old = node, *left;$/;"	l
old_argv	src/haproxy.c	/^	char *old_argv = *argv;$/;"	l
old_char	src/acl.c	/^	char old_char;$/;"	l
old_dst	src/regex.c	/^	char *old_dst = dst;$/;"	l
old_evt	src/ev_epoll.c	/^	uint32_t old_evt;$/;"	l
old_flags	src/proto_http.c	/^	unsigned int old_flags = buf->flags;$/;"	l
old_idx	src/proto_http.c	/^	int cur_idx, old_idx, delta;$/;"	l
old_idx	src/proto_http.c	/^	int cur_idx, old_idx, last_hdr;$/;"	l
old_idx	src/proto_http.c	/^	int cur_idx, old_idx;$/;"	l
old_leaf	ebtree/eb64tree.h	/^			eb_troot_t *new_leaf, *old_leaf;$/;"	l
old_leaf	ebtree/ebimtree.h	/^			eb_troot_t *new_leaf, *old_leaf;$/;"	l
old_leaf	ebtree/ebistree.h	/^			eb_troot_t *new_leaf, *old_leaf;$/;"	l
old_leaf	ebtree/ebsttree.h	/^			eb_troot_t *new_leaf, *old_leaf;$/;"	l
old_node	ebtree/eb64tree.h	/^			eb_troot_t *new_leaf, *old_node;$/;"	l
old_node	ebtree/ebimtree.h	/^			eb_troot_t *new_leaf, *old_node;$/;"	l
old_node	ebtree/ebistree.h	/^			eb_troot_t *new_leaf, *old_node;$/;"	l
old_node	ebtree/ebsttree.h	/^			eb_troot_t *new_leaf, *old_node;$/;"	l
old_node_bit	ebtree/eb32tree.h	/^	int old_node_bit;$/;"	l
old_node_bit	ebtree/eb64tree.h	/^		side >>= old_node_bit;$/;"	l
old_node_bit	ebtree/eb64tree.h	/^	int old_node_bit;$/;"	l
old_node_bit	ebtree/ebimtree.h	/^	int old_node_bit;$/;"	l
old_node_bit	ebtree/ebistree.h	/^	int old_node_bit;$/;"	l
old_node_bit	ebtree/ebmbtree.h	/^	int old_node_bit;$/;"	l
old_node_bit	ebtree/ebsttree.h	/^	int old_node_bit;$/;"	l
old_req_state	src/proto_http.c	/^	int old_req_state = txn->req.msg_state;$/;"	l
old_res_state	src/proto_http.c	/^	int old_res_state = txn->rsp.msg_state;$/;"	l
old_scope	src/uri_auth.c	/^	struct stat_scope *old_scope, **scope_list;$/;"	l
old_sig	src/signal.c	/^	sigset_t old_sig;$/;"	l
old_state	src/lb_chash.c	/^	int old_state, new_state;$/;"	l
old_state	src/lb_fwlc.c	/^	int old_state, new_state;$/;"	l
old_state	src/lb_fwrr.c	/^	int old_state, new_state;$/;"	l
old_state	src/proto_http.c	/^	unsigned int old_state = txn->req.msg_state;$/;"	l
old_state	src/proto_http.c	/^	unsigned int old_state = txn->rsp.msg_state;$/;"	l
oldnext	tests/filltab25.c	/^				int oldnext;$/;"	l
oldpids	src/haproxy.c	/^static int *oldpids = NULL;$/;"	v	file:
oldpids_sig	src/haproxy.c	/^static int oldpids_sig; \/* use USR1 or TERM *\/$/;"	v	file:
olen	src/buffers.c	/^	int olen, free;$/;"	l
omult	src/standard.c	/^	unsigned omult, odiv;$/;"	l
one	include/types/global.h	/^extern const int one;$/;"	x
one	src/haproxy.c	/^const int one = 1;$/;"	v
onerror	include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server	access:public
op	include/import/ip_tproxy.h	/^	u_int32_t op;$/;"	m	struct:in_tproxy	access:public
opaque	src/acl.c	/^	int opaque, patflags;$/;"	l
opaque	src/acl.c	/^	int opaque;$/;"	l
opcode	src/ev_epoll.c	/^	int opcode;$/;"	l
opcode	src/ev_sepoll.c	/^	int fd, opcode;$/;"	l
options	include/types/global.h	/^		int options;       \/* various tuning options *\/$/;"	m	struct:global::__anon16	access:public
options	include/types/protocols.h	/^	int options;			\/* socket options : LI_O_* *\/$/;"	m	struct:listener	access:public
options	include/types/proxy.h	/^	int options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy	access:public
options2	include/types/proxy.h	/^	int options2;				\/* PR_O2_* *\/$/;"	m	struct:proxy	access:public
optnum	src/cfgparse.c	/^			int optnum;$/;"	l
optnum	src/cfgparse.c	/^		int optnum;$/;"	l
orgto_hdr_len	include/types/proxy.h	/^	int orgto_hdr_len;			\/* length of "x-original-to" header *\/$/;"	m	struct:proxy	access:public
orgto_hdr_name	include/types/proxy.h	/^	char *orgto_hdr_name;			\/* header to use - default: "x-original-to" *\/$/;"	m	struct:proxy	access:public
orig	src/standard.c	/^	char *orig = dst;$/;"	l
other	src/rbtree.c	/^	struct rb_node *other;$/;"	l
out	src/base64.c	/^	int i, out;$/;"	l
out_err	src/standard.c	/^	__label__ out_free, out_err;$/;"	l
out_error	src/checks.c	/^	__label__ out_wakeup, out_nowake, out_poll, out_error;$/;"	l
out_free	src/standard.c	/^	__label__ out_free, out_err;$/;"	l
out_free_acl_expr	src/acl.c	/^	__label__ out_return, out_free_acl_expr, out_free_name;$/;"	l
out_free_expr	src/acl.c	/^	__label__ out_return, out_free_expr, out_free_pattern;$/;"	l
out_free_name	src/acl.c	/^	__label__ out_return, out_free_acl_expr, out_free_name;$/;"	l
out_free_pattern	src/acl.c	/^	__label__ out_return, out_free_expr, out_free_pattern;$/;"	l
out_free_suite	src/acl.c	/^	__label__ out_return, out_free_suite, out_free_term;$/;"	l
out_free_term	src/acl.c	/^	__label__ out_return, out_free_suite, out_free_term;$/;"	l
out_nowake	src/checks.c	/^	__label__ out_wakeup, out_nowake, out_poll, out_error;$/;"	l
out_poll	src/checks.c	/^	__label__ out_wakeup, out_nowake, out_poll, out_error;$/;"	l
out_return	src/acl.c	/^	__label__ out_return, out_free_acl_expr, out_free_name;$/;"	l
out_return	src/acl.c	/^	__label__ out_return, out_free_expr, out_free_pattern;$/;"	l
out_return	src/acl.c	/^	__label__ out_return, out_free_suite, out_free_term;$/;"	l
out_type	include/types/pattern.h	/^	unsigned int out_type;                    \/* output pattern type *\/$/;"	m	struct:pattern_conv	access:public
out_type	include/types/pattern.h	/^	unsigned long out_type;                   \/* output pattern type *\/$/;"	m	struct:pattern_fetch	access:public
out_wakeup	src/checks.c	/^	__label__ out_wakeup, out_nowake, out_poll, out_error;$/;"	l
out_wakeup	src/checks.c	/^	__label__ out_wakeup;$/;"	l
output_file	contrib/halog/halog.c	/^	const char *output_file = NULL;$/;"	l
owner	include/types/fd.h	/^	void *owner;                         \/* the session (or proxy) associated with this fd *\/$/;"	m	struct:fdtab	access:public
owner	include/types/stream_interface.h	/^	void *owner;            \/* generally a (struct task*) *\/$/;"	m	struct:stream_interface	access:public
p	contrib/base64/base64rev-gen.c	/^	char *p, c;$/;"	l
p	contrib/halog/fgets2-64.c	/^	const char *p;$/;"	l
p	contrib/halog/fgets2.c	/^	const char *p;$/;"	l
p	contrib/halog/halog.c	/^	const char *b, *e, *p;$/;"	l
p	include/common/mini-clist.h	/^    struct list *p;	\/* prev *\/$/;"	m	struct:list	typeref:struct:list::list	access:public
p	include/common/standard.h	/^		char *p = s++;$/;"	l
p	include/common/standard.h	/^	char *p = s + strlen(s);$/;"	l
p	include/types/acl.h	/^		void *p;        \/* any pointer *\/$/;"	m	union:acl_test::__anon53	access:public
p	include/types/counters.h	/^	} p;$/;"	m	struct:srvcounters	typeref:union:srvcounters::__anon60	access:public
p	src/appsession.c	/^	struct proxy           *p = proxy;$/;"	l
p	src/appsession.c	/^	struct proxy        *p = proxy;$/;"	l
p	src/appsession.c	/^	struct proxy *p = proxy;$/;"	l
p	src/backend.c	/^	const char      *p    = params;$/;"	l
p	src/backend.c	/^	const char      *p;$/;"	l
p	src/backend.c	/^	const char *p;$/;"	l
p	src/backend.c	/^	struct pendconn *p;$/;"	l
p	src/buffers.c	/^	char *p;$/;"	l
p	src/checks.c	/^		struct pendconn *p;$/;"	l
p	src/client.c	/^	struct proxy *p = (struct proxy *)l->private; \/* attached frontend *\/$/;"	l
p	src/ev_epoll.c	/^	struct poller *p;$/;"	l
p	src/ev_kqueue.c	/^	struct poller *p;$/;"	l
p	src/ev_poll.c	/^	struct poller *p;$/;"	l
p	src/ev_select.c	/^	struct poller *p;$/;"	l
p	src/ev_sepoll.c	/^	struct poller *p;$/;"	l
p	src/fd.c	/^	int p;$/;"	l
p	src/haproxy.c	/^	int p;$/;"	l
p	src/haproxy.c	/^	struct proxy *p = proxy, *p0;$/;"	l
p	src/haproxy.c	/^	struct proxy *p = proxy;$/;"	l
p	src/haproxy.c	/^	struct proxy *p;$/;"	l
p	src/lb_chash.c	/^	struct proxy *p = srv->proxy;$/;"	l
p	src/lb_fwlc.c	/^	struct proxy *p = srv->proxy;$/;"	l
p	src/lb_fwrr.c	/^	struct proxy *p = s->proxy;$/;"	l
p	src/lb_fwrr.c	/^	struct proxy *p = srv->proxy;$/;"	l
p	src/lb_map.c	/^	struct proxy *p = srv->proxy;$/;"	l
p	src/pattern.c	/^			char *p = my_strndup(endw + 1, i);$/;"	l
p	src/proto_http.c	/^	char *h, *p;$/;"	l
p	src/proto_tcp.c	/^	char *p;$/;"	l
p	src/proxy.c	/^	struct proxy *p;$/;"	l
p	src/queue.c	/^	struct pendconn *p;$/;"	l
p	src/queue.c	/^	struct proxy  *p = s->proxy;$/;"	l
p	src/standard.c	/^	const char *p, *d;$/;"	l
p	src/time.c	/^	char *p = rv;$/;"	l
p	tests/filltab25.c	/^int p;          \/* current position, between sw..2sw-1 *\/$/;"	v
p	tests/test_hashes.c	/^  unsigned char *p = key;$/;"	l
p0	src/haproxy.c	/^	struct proxy *p = proxy, *p0;$/;"	l
p1	src/proto_http.c	/^		char *p1 = NULL, *p2 = NULL;$/;"	l
p1	src/proto_http.c	/^	char *p1, *p2;$/;"	l
p1	tests/test_pools.c	/^		void *p1, *p2, *p3;$/;"	l
p2	src/proto_http.c	/^		char *p1 = NULL, *p2 = NULL;$/;"	l
p2	src/proto_http.c	/^	char *p1, *p2;$/;"	l
p2	tests/test_pools.c	/^		void *p1, *p2, *p3;$/;"	l
p3	tests/test_pools.c	/^		void *p1, *p2, *p3;$/;"	l
packetlen	src/cfgparse.c	/^						int packetlen, reqlen, userlen;$/;"	l
pad	src/base64.c	/^	int convlen = 0, i = 0, pad = 0;$/;"	l
params	src/backend.c	/^	const char      *params = req->data + msg->sov;$/;"	l
params	src/backend.c	/^	const char *params;$/;"	l
parent	ebtree/ebtree.h	/^	struct eb_node *parent;$/;"	l
parent	src/rbtree.c	/^	struct rb_node *child, *parent;$/;"	l
parent	src/rbtree.c	/^	struct rb_node *parent = victim->rb_parent;$/;"	l
parent	src/rbtree.c	/^	struct rb_node *parent, *gparent;$/;"	l
parse	include/common/cfgparse.h	/^	int (*parse)(                           \/* 0=OK, <0=Alert, >0=Warning *\/$/;"	m	struct:cfg_keyword	access:public
parse	include/types/acl.h	/^	int (*parse)(const char **text, struct acl_pattern *pattern, int *opaque);$/;"	m	struct:acl_keyword	access:public
parse_acl	include/proto/acl.h	/^struct acl *parse_acl(const char **args, struct list *known_acl);$/;"	p	signature:(const char **args, struct list *known_acl)
parse_acl	src/acl.c	/^struct acl *parse_acl(const char **args, struct list *known_acl)$/;"	f	signature:(const char **args, struct list *known_acl)
parse_acl_cond	include/proto/acl.h	/^struct acl_cond *parse_acl_cond(const char **args, struct list *known_acl, int pol);$/;"	p	signature:(const char **args, struct list *known_acl, int pol)
parse_acl_cond	src/acl.c	/^struct acl_cond *parse_acl_cond(const char **args, struct list *known_acl, int pol)$/;"	f	signature:(const char **args, struct list *known_acl, int pol)
parse_acl_expr	include/proto/acl.h	/^struct acl_expr *parse_acl_expr(const char **args);$/;"	p	signature:(const char **args)
parse_acl_expr	src/acl.c	/^struct acl_expr *parse_acl_expr(const char **args)$/;"	f	signature:(const char **args)
parse_args	include/types/pattern.h	/^	int (*parse_args)(const char *arg_str,$/;"	m	struct:pattern_conv	access:public
parse_auth_cond	include/proto/auth.h	/^struct req_acl_rule *parse_auth_cond(const char **args, const char *file, int linenum, struct proxy *proxy);$/;"	p	signature:(const char **args, const char *file, int linenum, struct proxy *proxy)
parse_auth_cond	src/auth.c	/^parse_auth_cond(const char **args, const char *file, int linenum, struct proxy *proxy)$/;"	f	signature:(const char **args, const char *file, int linenum, struct proxy *proxy)
parse_conf	examples/check	/^sub parse_conf$/;"	s
parse_err	contrib/halog/halog.c	/^	int f, tot, last, linenum, err, parse_err;$/;"	l
parse_size_err	include/common/standard.h	/^extern const char *parse_size_err(const char *text, unsigned *ret);$/;"	p	signature:(const char *text, unsigned *ret)
parse_size_err	src/standard.c	/^const char *parse_size_err(const char *text, unsigned *ret) {$/;"	f	signature:(const char *text, unsigned *ret)
parse_time_err	include/common/standard.h	/^extern const char *parse_time_err(const char *text, unsigned *ret, unsigned unit_flags);$/;"	p	signature:(const char *text, unsigned *ret, unsigned unit_flags)
parse_time_err	src/standard.c	/^const char *parse_time_err(const char *text, unsigned *ret, unsigned unit_flags)$/;"	f	signature:(const char *text, unsigned *ret, unsigned unit_flags)
partial	src/proto_tcp.c	/^	int partial;$/;"	l
pass	include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users	access:public
pass	include/types/proto_http.h	/^	char *user, *pass;		\/* extracted username & password *\/$/;"	m	struct:http_auth_data	access:public
pass	src/auth.c	/^	char *pass = test->ctx.a[2];$/;"	l
pass	src/uri_auth.c	/^	char *pass;$/;"	l
past	src/freq_ctr.c	/^	unsigned int curr, past;$/;"	l
pat	src/acl.c	/^	struct acl_pattern *pat, *tmp;$/;"	l
patflags	src/acl.c	/^	int opaque, patflags;$/;"	l
path	src/proto_http.c	/^				const char *path;$/;"	l
path	src/proto_http.c	/^	char *path;$/;"	l
pathlen	src/proto_http.c	/^				int pathlen;$/;"	l
pattern	include/types/pattern.h	/^struct pattern {$/;"	s
pattern	src/acl.c	/^	struct acl_pattern *pattern;$/;"	l
pattern::data	include/types/pattern.h	/^	union pattern_data data;  \/* data *\/$/;"	m	struct:pattern	typeref:union:pattern::pattern_data	access:public
pattern::type	include/types/pattern.h	/^	int type;                 \/* current type of data *\/$/;"	m	struct:pattern	access:public
pattern_cast	src/pattern.c	/^typedef int (*pattern_cast)(union pattern_data *data);$/;"	t	file:
pattern_casts	src/pattern.c	/^static pattern_cast pattern_casts[PATTERN_TYPES][PATTERN_TYPES] = { { c_donothing, c_ip2int, c_ip2str  },$/;"	v	file:
pattern_conv	include/types/pattern.h	/^struct pattern_conv {$/;"	s
pattern_conv::in_type	include/types/pattern.h	/^	unsigned int in_type;                     \/* input needed pattern type *\/$/;"	m	struct:pattern_conv	access:public
pattern_conv::kw	include/types/pattern.h	/^	const char *kw;                           \/* configuration keyword  *\/$/;"	m	struct:pattern_conv	access:public
pattern_conv::out_type	include/types/pattern.h	/^	unsigned int out_type;                    \/* output pattern type *\/$/;"	m	struct:pattern_conv	access:public
pattern_conv::parse_args	include/types/pattern.h	/^	int (*parse_args)(const char *arg_str,$/;"	m	struct:pattern_conv	access:public
pattern_conv::process	include/types/pattern.h	/^	int (*process)(const void *arg_p,$/;"	m	struct:pattern_conv	access:public
pattern_conv_arg_to_ipmask	src/pattern.c	/^static int pattern_conv_arg_to_ipmask(const char *arg_str, void **arg_p, int *arg_i)$/;"	f	file:	signature:(const char *arg_str, void **arg_p, int *arg_i)
pattern_conv_expr	include/types/pattern.h	/^struct pattern_conv_expr {$/;"	s
pattern_conv_expr::arg_i	include/types/pattern.h	/^	int arg_i;                                \/* int arg, most often the argument's length *\/$/;"	m	struct:pattern_conv_expr	access:public
pattern_conv_expr::arg_p	include/types/pattern.h	/^	void *arg_p;                              \/* pointer arg, most often a string argument *\/$/;"	m	struct:pattern_conv_expr	access:public
pattern_conv_expr::conv	include/types/pattern.h	/^	struct pattern_conv *conv;                \/* pattern conversion *\/$/;"	m	struct:pattern_conv_expr	typeref:struct:pattern_conv_expr::pattern_conv	access:public
pattern_conv_expr::list	include/types/pattern.h	/^	struct list list;                         \/* member of a pattern expression *\/$/;"	m	struct:pattern_conv_expr	typeref:struct:pattern_conv_expr::list	access:public
pattern_conv_ipmask	src/pattern.c	/^static int pattern_conv_ipmask(const void *arg_p, int arg_i, union pattern_data *data)$/;"	f	file:	signature:(const void *arg_p, int arg_i, union pattern_data *data)
pattern_conv_kw_list	include/types/pattern.h	/^struct pattern_conv_kw_list {$/;"	s
pattern_conv_kw_list::kw	include/types/pattern.h	/^	struct pattern_conv kw[VAR_ARRAY];        \/* array of pattern ions *\/$/;"	m	struct:pattern_conv_kw_list	typeref:struct:pattern_conv_kw_list::pattern_conv	access:public
pattern_conv_kw_list::list	include/types/pattern.h	/^	struct list list;                         \/* head of pattern conversion keyword list *\/$/;"	m	struct:pattern_conv_kw_list	typeref:struct:pattern_conv_kw_list::list	access:public
pattern_conv_kws	src/pattern.c	/^static struct pattern_conv_kw_list pattern_conv_kws = {{ },{$/;"	v	typeref:struct:pattern_conv_kw_list	file:
pattern_conv_str2lower	src/pattern.c	/^static int pattern_conv_str2lower(const void *arg_p, int arg_i, union pattern_data *data)$/;"	f	file:	signature:(const void *arg_p, int arg_i, union pattern_data *data)
pattern_conv_str2upper	src/pattern.c	/^static int pattern_conv_str2upper(const void *arg_p, int arg_i, union pattern_data *data)$/;"	f	file:	signature:(const void *arg_p, int arg_i, union pattern_data *data)
pattern_convs	src/pattern.c	/^static struct pattern_conv_kw_list pattern_convs = {$/;"	v	typeref:struct:pattern_conv_kw_list	file:
pattern_data	include/types/pattern.h	/^union pattern_data {$/;"	u
pattern_data::integer	include/types/pattern.h	/^	uint32_t integer;  \/* used for unsigned 32bits integer type *\/$/;"	m	union:pattern_data	access:public
pattern_data::ip	include/types/pattern.h	/^	struct in_addr ip; \/* used for ipv4 type *\/$/;"	m	union:pattern_data	typeref:struct:pattern_data::in_addr	access:public
pattern_data::str	include/types/pattern.h	/^	struct chunk str;  \/* used for char string type *\/$/;"	m	union:pattern_data	typeref:struct:pattern_data::chunk	access:public
pattern_data_setstring	src/pattern.c	/^static void pattern_data_setstring(union pattern_data *data, struct chunk *c)$/;"	f	file:	signature:(union pattern_data *data, struct chunk *c)
pattern_expr	include/types/pattern.h	/^struct pattern_expr {$/;"	s
pattern_expr::arg	include/types/pattern.h	/^	char *arg;                                \/* configured keyword argument *\/$/;"	m	struct:pattern_expr	access:public
pattern_expr::arg_len	include/types/pattern.h	/^	int arg_len;                              \/* configured keyword argument length *\/$/;"	m	struct:pattern_expr	access:public
pattern_expr::conv_exprs	include/types/pattern.h	/^	struct list conv_exprs;                   \/* list of conversion expression to apply *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::list	access:public
pattern_expr::fetch	include/types/pattern.h	/^	struct pattern_fetch *fetch;              \/* pattern fetch *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::pattern_fetch	access:public
pattern_expr::list	include/types/pattern.h	/^	struct list list;                         \/* member of list of pattern, currently not used *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::list	access:public
pattern_fetch	include/types/pattern.h	/^struct pattern_fetch {$/;"	s
pattern_fetch::dir	include/types/pattern.h	/^	int dir;                                  \/* usable directions *\/$/;"	m	struct:pattern_fetch	access:public
pattern_fetch::kw	include/types/pattern.h	/^	const char *kw;                           \/* configuration keyword *\/$/;"	m	struct:pattern_fetch	access:public
pattern_fetch::out_type	include/types/pattern.h	/^	unsigned long out_type;                   \/* output pattern type *\/$/;"	m	struct:pattern_fetch	access:public
pattern_fetch::process	include/types/pattern.h	/^	int (*process)(struct proxy *px,$/;"	m	struct:pattern_fetch	access:public
pattern_fetch_dport	src/client.c	/^pattern_fetch_dport(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, const char *arg, int arg_len, union pattern_data *data)
pattern_fetch_dst	src/client.c	/^pattern_fetch_dst(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, const char *arg, int arg_len, union pattern_data *data)
pattern_fetch_hdr_ip	src/proto_http.c	/^pattern_fetch_hdr_ip(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, const char *arg, int arg_len, union pattern_data *data)
pattern_fetch_keywords	src/client.c	/^static struct pattern_fetch_kw_list pattern_fetch_keywords = {{ },{$/;"	v	typeref:struct:pattern_fetch_kw_list	file:
pattern_fetch_keywords	src/proto_http.c	/^static struct pattern_fetch_kw_list pattern_fetch_keywords = {{ },{$/;"	v	typeref:struct:pattern_fetch_kw_list	file:
pattern_fetch_kw_list	include/types/pattern.h	/^struct pattern_fetch_kw_list {$/;"	s
pattern_fetch_kw_list::kw	include/types/pattern.h	/^	struct pattern_fetch kw[VAR_ARRAY];       \/* array of pattern fetches *\/$/;"	m	struct:pattern_fetch_kw_list	typeref:struct:pattern_fetch_kw_list::pattern_fetch	access:public
pattern_fetch_kw_list::list	include/types/pattern.h	/^	struct list list;                         \/* head of pattern fetch keyword list *\/$/;"	m	struct:pattern_fetch_kw_list	typeref:struct:pattern_fetch_kw_list::list	access:public
pattern_fetch_src	src/client.c	/^pattern_fetch_src(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	file:	signature:(struct proxy *px, struct session *l4, void *l7, int dir, const char *arg, int arg_len, union pattern_data *data)
pattern_fetches	src/pattern.c	/^static struct pattern_fetch_kw_list pattern_fetches = {$/;"	v	typeref:struct:pattern_fetch_kw_list	file:
pattern_key	src/pattern.c	/^typedef void *(*pattern_key)(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len);$/;"	t	file:
pattern_keys	src/pattern.c	/^static pattern_key pattern_keys[PATTERN_TYPES][STKTABLE_TYPES] = { { k_ip2ip,  k_ip2int,  k_ip2str  },$/;"	v	file:
pattern_notusable_key	include/proto/pattern.h	/^int pattern_notusable_key(struct pattern_expr *expr, unsigned long table_type);$/;"	p	signature:(struct pattern_expr *expr, unsigned long table_type)
pattern_notusable_key	src/pattern.c	/^int pattern_notusable_key(struct pattern_expr *expr, unsigned long table_type)$/;"	f	signature:(struct pattern_expr *expr, unsigned long table_type)
pattern_parse_expr	include/proto/pattern.h	/^struct pattern_expr *pattern_parse_expr(char **str, int *idx);$/;"	p	signature:(char **str, int *idx)
pattern_parse_expr	src/pattern.c	/^struct pattern_expr *pattern_parse_expr(char **str, int *idx)$/;"	f	signature:(char **str, int *idx)
pattern_process	include/proto/pattern.h	/^struct pattern *pattern_process(struct proxy *px, struct session *l4,$/;"	p	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct pattern_expr *expr, struct pattern *p)
pattern_process	src/pattern.c	/^struct pattern *pattern_process(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct pattern_expr *expr, struct pattern *p)
pattern_process_key	include/proto/pattern.h	/^struct stktable_key *pattern_process_key(struct proxy *px, struct session *l4,$/;"	p	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct pattern_expr *expr, unsigned long table_type)
pattern_process_key	src/pattern.c	/^struct stktable_key *pattern_process_key(struct proxy *px, struct session *l4, void *l7, int dir,$/;"	f	signature:(struct proxy *px, struct session *l4, void *l7, int dir, struct pattern_expr *expr, unsigned long table_type)
pattern_register_convs	include/proto/pattern.h	/^void pattern_register_convs(struct pattern_conv_kw_list *psl);$/;"	p	signature:(struct pattern_conv_kw_list *psl)
pattern_register_convs	src/pattern.c	/^void pattern_register_convs(struct pattern_conv_kw_list *pckl)$/;"	f	signature:(struct pattern_conv_kw_list *pckl)
pattern_register_fetches	include/proto/pattern.h	/^void pattern_register_fetches(struct pattern_fetch_kw_list *psl);$/;"	p	signature:(struct pattern_fetch_kw_list *psl)
pattern_register_fetches	src/pattern.c	/^void pattern_register_fetches(struct pattern_fetch_kw_list *pfkl)$/;"	f	signature:(struct pattern_fetch_kw_list *pfkl)
pattern_trash_buf	src/pattern.c	/^static char *pattern_trash_buf = pattern_trash_buf1;$/;"	v	file:
pattern_trash_buf1	src/pattern.c	/^static char pattern_trash_buf1[BUFSIZE];$/;"	v	file:
pattern_trash_buf2	src/pattern.c	/^static char pattern_trash_buf2[BUFSIZE];$/;"	v	file:
pattern_tree	include/types/acl.h	/^	struct eb_root pattern_tree;  \/* may be used for lookup in large datasets *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::eb_root	access:public
patterns	include/types/acl.h	/^	struct list patterns;       \/* list of acl_patterns *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::list	access:public
pause_proxies	include/proto/proxy.h	/^void pause_proxies(void);$/;"	p	signature:(void)
pause_proxies	src/proxy.c	/^void pause_proxies(void)$/;"	f	signature:(void)
pause_proxy	include/proto/proxy.h	/^void pause_proxy(struct proxy *p);$/;"	p	signature:(struct proxy *p)
pause_proxy	src/proxy.c	/^void pause_proxy(struct proxy *p)$/;"	f	signature:(struct proxy *p)
pc	src/checks.c	/^	struct pendconn *pc, *pc_bck, *pc_end;$/;"	l
pc_bck	src/checks.c	/^	struct pendconn *pc, *pc_bck, *pc_end;$/;"	l
pc_end	src/checks.c	/^	struct pendconn *pc, *pc_bck, *pc_end;$/;"	l
peeraddr	include/types/fd.h	/^	struct sockaddr *peeraddr;   \/* pointer to peer's network address, or NULL if unset *\/$/;"	m	struct:fdinfo	typeref:struct:fdinfo::sockaddr	access:public
peerlen	include/types/fd.h	/^	socklen_t peerlen;           \/* peer's address length, or 0 if unset *\/$/;"	m	struct:fdinfo	access:public
pend_pos	include/types/session.h	/^	struct pendconn *pend_pos;		\/* if not NULL, points to the position in the pending queue *\/$/;"	m	struct:session	typeref:struct:session::pendconn	access:public
pendconn	include/types/queue.h	/^struct pendconn {$/;"	s
pendconn::list	include/types/queue.h	/^	struct list list;		\/* chaining ... *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::list	access:public
pendconn::sess	include/types/queue.h	/^	struct session *sess;		\/* the session waiting for a connection *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::session	access:public
pendconn::srv	include/types/queue.h	/^	struct server *srv;		\/* the server we are waiting for *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::server	access:public
pendconn_add	include/proto/queue.h	/^struct pendconn *pendconn_add(struct session *sess);$/;"	p	signature:(struct session *sess)
pendconn_add	src/queue.c	/^struct pendconn *pendconn_add(struct session *sess)$/;"	f	signature:(struct session *sess)
pendconn_free	include/proto/queue.h	/^void pendconn_free(struct pendconn *p);$/;"	p	signature:(struct pendconn *p)
pendconn_free	src/queue.c	/^void pendconn_free(struct pendconn *p)$/;"	f	signature:(struct pendconn *p)
pendconn_from_px	include/proto/queue.h	/^static inline struct pendconn *pendconn_from_px(const struct proxy *px) {$/;"	f	signature:(const struct proxy *px)
pendconn_from_srv	include/proto/queue.h	/^static inline struct pendconn *pendconn_from_srv(const struct server *s) {$/;"	f	signature:(const struct server *s)
pendconn_get_next_sess	include/proto/queue.h	/^struct session *pendconn_get_next_sess(struct server *srv, struct proxy *px);$/;"	p	signature:(struct server *srv, struct proxy *px)
pendconn_get_next_sess	src/queue.c	/^struct session *pendconn_get_next_sess(struct server *srv, struct proxy *px)$/;"	f	signature:(struct server *srv, struct proxy *px)
pendconns	include/types/proxy.h	/^	struct list pendconns;			\/* pending connections with no server assigned yet *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
pendconns	include/types/server.h	/^	struct list pendconns;			\/* pending connections *\/$/;"	m	struct:server	typeref:struct:server::list	access:public
perform_http_redirect	include/proto/proto_http.h	/^void perform_http_redirect(struct session *s, struct stream_interface *si);$/;"	p	signature:(struct session *s, struct stream_interface *si)
perform_http_redirect	src/proto_http.c	/^void perform_http_redirect(struct session *s, struct stream_interface *si)$/;"	f	signature:(struct session *s, struct stream_interface *si)
perm	include/types/protocols.h	/^	} perm;$/;"	m	struct:listener	typeref:union:listener::__anon23	access:private
persist_rule	include/types/proxy.h	/^struct persist_rule {$/;"	s
persist_rule::cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::acl_cond	access:public
persist_rule::list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::list	access:public
persist_rule::type	include/types/proxy.h	/^	int type;$/;"	m	struct:persist_rule	access:public
persist_rules	include/types/proxy.h	/^	struct list persist_rules;		\/* 'force-persist' and 'ignore-persist' rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
pfx	ebtree/ebtree.h	/^	short int      pfx;     \/* data prefix length, always related to leaf *\/$/;"	m	struct:eb_node	access:public
pgcd	src/lb_map.c	/^	int pgcd;$/;"	l
pid	include/types/global.h	/^extern int  pid;                \/* current process id *\/$/;"	x
pid	src/haproxy.c	/^int  pid;			\/* current process id *\/$/;"	v
pid	src/proxy.c	/^	int pid, sid;$/;"	l
pidfd	src/haproxy.c	/^		int pidfd;$/;"	l
pidfile	include/types/global.h	/^	char *pidfile;$/;"	m	struct:global	access:public
pidfile	src/haproxy.c	/^	FILE *pidfile = NULL;$/;"	l
pipe	include/types/buffers.h	/^	struct pipe *pipe;		\/* non-NULL only when data present *\/$/;"	m	struct:buffer	typeref:struct:buffer::pipe	access:public
pipe	include/types/pipe.h	/^struct pipe {$/;"	s
pipe::cons	include/types/pipe.h	/^	int cons;	\/* FD the consumer must read from ; -1 if none *\/$/;"	m	struct:pipe	access:public
pipe::data	include/types/pipe.h	/^	int data;	\/* number of bytes present in the pipe  *\/$/;"	m	struct:pipe	access:public
pipe::next	include/types/pipe.h	/^	struct pipe *next;$/;"	m	struct:pipe	typeref:struct:pipe::pipe	access:public
pipe::prod	include/types/pipe.h	/^	int prod;	\/* FD the producer must write to ; -1 if none *\/$/;"	m	struct:pipe	access:public
pipefd	src/pipe.c	/^	int pipefd[2];$/;"	l
pipes_free	include/proto/pipe.h	/^extern int pipes_free;	\/* # of pipes unused (2 fds each) *\/$/;"	x
pipes_free	src/pipe.c	/^int pipes_free = 0;             \/* # of pipes unused *\/$/;"	v
pipes_live	src/pipe.c	/^struct pipe *pipes_live = NULL; \/* pipes which are still ready to use *\/$/;"	v	typeref:struct:pipe
pipes_used	include/proto/pipe.h	/^extern int pipes_used;	\/* # of pipes in use (2 fds each) *\/$/;"	x
pipes_used	src/pipe.c	/^int pipes_used = 0;             \/* # of pipes in use (2 fds each) *\/$/;"	v
pl	src/acl.c	/^	int pl;$/;"	l
plen	src/backend.c	/^	int plen;$/;"	l
plen	src/backend.c	/^	unsigned int     plen = px->hh_len;$/;"	l
plen	src/backend.c	/^	unsigned int     plen = px->url_param_len;$/;"	l
plen	src/proto_tcp.c	/^		int rlen, plen, cilen, silen, chlen;$/;"	l
plogfd	src/log.c	/^		int *plogfd = logsrv->u.addr.sa_family == AF_UNIX ?$/;"	l
plogfd	src/log.c	/^		int proto, *plogfd;$/;"	l
pmatch	include/common/regex.h	/^extern regmatch_t pmatch[MAX_MATCH];$/;"	x
pmatch	src/regex.c	/^regmatch_t pmatch[MAX_MATCH];  \/* rm_so, rm_eo for regular expressions *\/$/;"	v
pn	src/client.c	/^				char pn[INET6_ADDRSTRLEN], sn[INET6_ADDRSTRLEN];$/;"	l
pn	src/client.c	/^				char pn[INET6_ADDRSTRLEN];$/;"	l
pn	src/client.c	/^				char pn[INET_ADDRSTRLEN], sn[INET_ADDRSTRLEN];$/;"	l
pn	src/client.c	/^				char pn[INET_ADDRSTRLEN];$/;"	l
pn	src/dumpstats.c	/^			char pn[INET6_ADDRSTRLEN + strlen(":65535")];$/;"	l
pn	src/dumpstats.c	/^			char pn[INET6_ADDRSTRLEN];$/;"	l
pn	src/dumpstats.c	/^	char pn[INET6_ADDRSTRLEN];$/;"	l
pn	src/log.c	/^	char pn[INET6_ADDRSTRLEN + strlen(":65535")];$/;"	l
pn	src/proto_http.c	/^				unsigned char *pn;$/;"	l
pn	src/proto_http.c	/^			char pn[INET6_ADDRSTRLEN];$/;"	l
pn	src/proto_http.c	/^	char pn[INET6_ADDRSTRLEN + strlen(":65535")];$/;"	l
pname	src/acl.c	/^				char *pname, *sname;$/;"	l
pname	src/cfgparse.c	/^				char *pname, *sname;$/;"	l
pol	include/types/acl.h	/^	int pol;                    \/* polarity: ACL_COND_IF \/ ACL_COND_UNLESS *\/$/;"	m	struct:acl_cond	access:public
pol	src/acl.c	/^	int pol = ACL_COND_NONE;$/;"	l
pol	src/proto_tcp.c	/^		int pol = ACL_COND_NONE;$/;"	l
poll	include/types/fd.h	/^    	void REGPRM2   (*poll)(struct poller *p, int exp);   \/* the poller itself *\/$/;"	m	struct:poller	access:private
poll_events	src/ev_poll.c	/^static struct pollfd *poll_events = NULL;$/;"	v	typeref:struct:pollfd	file:
poller	include/types/fd.h	/^struct poller {$/;"	s
poller::clo	include/types/fd.h	/^	void REGPRM1    (*clo)(const int fd);                \/* mark <fd> as closed *\/$/;"	m	struct:poller	access:private
poller::clr	include/types/fd.h	/^	int  REGPRM2    (*clr)(const int fd, int dir);       \/* clear polling on <fd> for <dir> *\/$/;"	m	struct:poller	access:private
poller::cond_c	include/types/fd.h	/^	int  REGPRM2 (*cond_c)(const int fd, int dir);       \/* clear polling on <fd> for <dir> if set *\/$/;"	m	struct:poller	access:private
poller::cond_s	include/types/fd.h	/^	int  REGPRM2 (*cond_s)(const int fd, int dir);       \/* set   polling on <fd> for <dir> if unset *\/$/;"	m	struct:poller	access:private
poller::fork	include/types/fd.h	/^	int  REGPRM1   (*fork)(struct poller *p);            \/* post-fork re-opening *\/$/;"	m	struct:poller	access:private
poller::init	include/types/fd.h	/^	int  REGPRM1   (*init)(struct poller *p);            \/* poller initialization *\/$/;"	m	struct:poller	access:private
poller::is_set	include/types/fd.h	/^	int  REGPRM2 (*is_set)(const int fd, int dir);       \/* check if <fd> is being polled for dir <dir> *\/$/;"	m	struct:poller	access:private
poller::name	include/types/fd.h	/^	const char   *name;                                  \/* poller name *\/$/;"	m	struct:poller	access:private
poller::poll	include/types/fd.h	/^    	void REGPRM2   (*poll)(struct poller *p, int exp);   \/* the poller itself *\/$/;"	m	struct:poller	access:private
poller::pref	include/types/fd.h	/^	int    pref;                                         \/* try pollers with higher preference first *\/$/;"	m	struct:poller	access:private
poller::rem	include/types/fd.h	/^	void REGPRM1    (*rem)(const int fd);                \/* remove any polling on <fd> *\/$/;"	m	struct:poller	access:private
poller::set	include/types/fd.h	/^	int  REGPRM2    (*set)(const int fd, int dir);       \/* set   polling on <fd> for <dir> *\/$/;"	m	struct:poller	access:private
poller::term	include/types/fd.h	/^	void REGPRM1   (*term)(struct poller *p);            \/* termination of this poller *\/$/;"	m	struct:poller	access:private
poller::test	include/types/fd.h	/^	int  REGPRM1   (*test)(struct poller *p);            \/* pre-init check of the poller *\/$/;"	m	struct:poller	access:private
pollers	include/types/fd.h	/^extern struct poller pollers[MAX_POLLERS];   \/* all registered pollers *\/$/;"	x
pollers	src/fd.c	/^struct poller pollers[MAX_POLLERS];$/;"	v	typeref:struct:poller
pool	include/types/capture.h	/^    struct pool_head *pool;		\/* pool of pre-allocated memory area of (len+1) bytes *\/$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::pool_head	access:public
pool	include/types/stick_table.h	/^	struct pool_head *pool;   \/* pool used to allocate stuck sessions *\/$/;"	m	struct:stktable	typeref:struct:stktable::pool_head	access:public
pool	src/memory.c	/^	struct pool_head *pool;$/;"	l
pool2_appsess	include/common/appsession.h	/^extern struct pool_head *pool2_appsess;$/;"	x
pool2_appsess	src/appsession.c	/^struct pool_head *pool2_appsess;$/;"	v	typeref:struct:pool_head
pool2_buffer	include/proto/buffers.h	/^extern struct pool_head *pool2_buffer;$/;"	x
pool2_buffer	src/buffers.c	/^struct pool_head *pool2_buffer;$/;"	v	typeref:struct:pool_head
pool2_capture	include/types/capture.h	/^extern struct pool_head *pool2_capture;$/;"	x
pool2_capture	src/proto_http.c	/^struct pool_head *pool2_capture;$/;"	v	typeref:struct:pool_head
pool2_pendconn	include/proto/queue.h	/^extern struct pool_head *pool2_pendconn;$/;"	x
pool2_pendconn	src/queue.c	/^struct pool_head *pool2_pendconn;$/;"	v	typeref:struct:pool_head
pool2_pipe	src/pipe.c	/^struct pool_head *pool2_pipe = NULL;$/;"	v	typeref:struct:pool_head
pool2_requri	include/proto/log.h	/^extern struct pool_head *pool2_requri;$/;"	x
pool2_requri	src/proto_http.c	/^struct pool_head *pool2_requri;$/;"	v	typeref:struct:pool_head
pool2_session	include/proto/session.h	/^extern struct pool_head *pool2_session;$/;"	x
pool2_session	src/session.c	/^struct pool_head *pool2_session;$/;"	v	typeref:struct:pool_head
pool2_task	include/proto/task.h	/^extern struct pool_head *pool2_task;$/;"	x
pool2_task	src/task.c	/^struct pool_head *pool2_task;$/;"	v	typeref:struct:pool_head
pool_alloc	include/common/memory.h	69;"	d
pool_alloc	include/common/memory.h	95;"	d
pool_alloc	tests/test_pools.c	84;"	d	file:
pool_alloc2	include/common/memory.h	171;"	d
pool_alloc_from	include/common/memory.h	35;"	d
pool_alloc_from	tests/test_pools.c	52;"	d	file:
pool_destroy	include/common/memory.h	/^static inline void pool_destroy(void **pool)$/;"	f	signature:(void **pool)
pool_destroy	tests/test_pools.c	/^static inline void pool_destroy(void **pool)$/;"	f	file:	signature:(void **pool)
pool_destroy2	include/common/memory.h	/^void *pool_destroy2(struct pool_head *pool);$/;"	p	signature:(struct pool_head *pool)
pool_destroy2	src/memory.c	/^void *pool_destroy2(struct pool_head *pool)$/;"	f	signature:(struct pool_head *pool)
pool_flush2	include/common/memory.h	/^void pool_flush2(struct pool_head *pool);$/;"	p	signature:(struct pool_head *pool)
pool_flush2	src/memory.c	/^void pool_flush2(struct pool_head *pool)$/;"	f	signature:(struct pool_head *pool)
pool_free	include/common/memory.h	88;"	d
pool_free	include/common/memory.h	96;"	d
pool_free	tests/test_pools.c	103;"	d	file:
pool_free2	include/common/memory.h	192;"	d
pool_free_to	include/common/memory.h	55;"	d
pool_free_to	tests/test_pools.c	72;"	d	file:
pool_gc2	include/common/memory.h	/^void pool_gc2();$/;"	p	signature:()
pool_gc2	src/memory.c	/^void pool_gc2()$/;"	f
pool_head	include/common/memory.h	/^struct pool_head {$/;"	s
pool_head::allocated	include/common/memory.h	/^	unsigned int allocated;	\/* how many chunks have been allocated *\/$/;"	m	struct:pool_head	access:public
pool_head::flags	include/common/memory.h	/^	unsigned int flags;	\/* MEM_F_* *\/$/;"	m	struct:pool_head	access:public
pool_head::free_list	include/common/memory.h	/^	void **free_list;$/;"	m	struct:pool_head	access:public
pool_head::limit	include/common/memory.h	/^	unsigned int limit;	\/* hard limit on the number of chunks *\/$/;"	m	struct:pool_head	access:public
pool_head::list	include/common/memory.h	/^	struct list list;	\/* list of all known pools *\/$/;"	m	struct:pool_head	typeref:struct:pool_head::list	access:public
pool_head::minavail	include/common/memory.h	/^	unsigned int minavail;	\/* how many chunks are expected to be used *\/$/;"	m	struct:pool_head	access:public
pool_head::name	include/common/memory.h	/^	char name[12];		\/* name of the pool *\/$/;"	m	struct:pool_head	access:public
pool_head::size	include/common/memory.h	/^	unsigned int size;	\/* chunk size *\/$/;"	m	struct:pool_head	access:public
pool_head::used	include/common/memory.h	/^	unsigned int used;	\/* how many chunks are currently in use *\/$/;"	m	struct:pool_head	access:public
pool_head::users	include/common/memory.h	/^	unsigned int users;	\/* number of pools sharing this zone *\/$/;"	m	struct:pool_head	access:public
pool_refill_alloc	include/common/memory.h	/^void *pool_refill_alloc(struct pool_head *pool);$/;"	p	signature:(struct pool_head *pool)
pool_refill_alloc	src/memory.c	/^void *pool_refill_alloc(struct pool_head *pool)$/;"	f	signature:(struct pool_head *pool)
pool_talloc	tests/test_pools.c	/^        void **pool_talloc = NULL;$/;"	l
pools	src/memory.c	/^static struct list pools = LIST_HEAD_INIT(pools);$/;"	v	typeref:struct:list	file:
port	src/cfgparse.c	/^					int port;$/;"	l
port	src/cfgparse.c	/^	int port, end;$/;"	l
port	src/dumpstats.c	/^						int port;$/;"	l
port	src/proxy.c	/^					int port;$/;"	l
port	src/standard.c	/^	int port;$/;"	l
port	tests/reset.c	/^	int port;$/;"	l
port_high	src/cfgparse.c	/^				int port_low, port_high;$/;"	l
port_low	src/cfgparse.c	/^				int port_low, port_high;$/;"	l
port_range	include/types/fd.h	/^	struct port_range *port_range;       \/* optional port range to bind to *\/$/;"	m	struct:fdinfo	typeref:struct:fdinfo::port_range	access:public
port_range	include/types/port_range.h	/^struct port_range {$/;"	s
port_range::avail	include/types/port_range.h	/^	int avail;			\/* number of available ports left *\/$/;"	m	struct:port_range	access:public
port_range::get	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range	access:public
port_range::ports	include/types/port_range.h	/^	uint16_t ports[0];		\/* array of <size> ports, in host byte order *\/$/;"	m	struct:port_range	access:public
port_range::put	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range	access:public
port_range::size	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range	access:public
port_range_alloc_port	include/proto/port_range.h	/^static inline int port_range_alloc_port(struct port_range *range)$/;"	f	signature:(struct port_range *range)
port_range_alloc_range	include/proto/port_range.h	/^static inline struct port_range *port_range_alloc_range(int n)$/;"	f	signature:(int n)
port_range_release_port	include/proto/port_range.h	/^static inline void port_range_release_port(struct port_range *range, int port)$/;"	f	signature:(struct port_range *range, int port)
porth	src/standard.c	/^	int portl, porth;$/;"	l
portl	src/standard.c	/^	int portl, porth;$/;"	l
ports	include/types/port_range.h	/^	uint16_t ports[0];		\/* array of <size> ports, in host byte order *\/$/;"	m	struct:port_range	access:public
pos	ebtree/ebmbtree.h	/^	int pos, side;$/;"	l
pos	include/types/proxy.h	/^	unsigned int pos;		\/* position of the first invalid character *\/$/;"	m	struct:error_snapshot	access:public
pos	include/types/session.h	/^			int pos;		\/* last position of the current session's buffer *\/$/;"	m	struct:session::__anon9::__anon11	access:public
pos	src/ev_sepoll.c	/^	unsigned int pos;$/;"	l
pos	src/pattern.c	/^	char *pos;$/;"	l
pos	src/standard.c	/^	char *pos;$/;"	l
pp	src/queue.c	/^	struct pendconn *ps, *pp;$/;"	l
pr	src/auth.c	/^	struct req_acl_rule *tr, *pr;$/;"	l
pref	include/types/fd.h	/^	int    pref;                                         \/* try pollers with higher preference first *\/$/;"	m	struct:poller	access:private
preg	include/common/regex.h	/^    const regex_t *preg;		\/* expression to look for *\/$/;"	m	struct:hdr_exp	access:public
preg	src/acl.c	/^	regex_t *preg;$/;"	l
preg	src/cfgparse.c	/^	regex_t *preg = NULL;$/;"	l
preserve_hdr	src/proto_http.c	/^	int preserve_hdr;$/;"	l
prev	include/types/proto_http.h	/^	int  prev; \/* index of previous header *\/$/;"	m	struct:hdr_ctx	access:public
prev	src/acl.c	/^	char prev;$/;"	l
prev	src/ev_epoll.c	/^	int prev, next;$/;"	l
prev	src/ev_epoll.c	/^	unsigned int prev:2;	\/\/ previous state mask. New one is in fd_evts.$/;"	m	struct:fd_chg	file:	access:public
prev	src/lb_chash.c	/^	struct eb32_node *next, *prev;$/;"	l
prev	src/proto_http.c	/^	char *prev = *from;$/;"	l
prev	src/proto_http.c	/^	char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;$/;"	l
prev_ctr	include/types/freq_ctr.h	/^	unsigned int prev_ctr; \/* value for last period *\/$/;"	m	struct:freq_ctr	access:public
prev_eweight	include/types/server.h	/^	unsigned prev_eweight;			\/* eweight before last change *\/$/;"	m	struct:server	access:public
prev_next	src/lb_fwrr.c	/^			int prev_next = srv->npos;$/;"	l
prev_srv	include/types/session.h	/^	struct server *prev_srv;		\/* the server the was running on, after a redispatch, otherwise NULL *\/$/;"	m	struct:session	typeref:struct:session::server	access:public
prev_srv_count	src/checks.c	/^		int prev_srv_count = s->proxy->srv_bck + s->proxy->srv_act;$/;"	l
prev_state	include/types/server.h	/^	int prev_state;				\/* server state before last change (SRV_*) *\/$/;"	m	struct:server	access:public
prev_state	include/types/stream_interface.h	/^	unsigned int prev_state;\/* SI_ST*, copy of previous state *\/$/;"	m	struct:stream_interface	access:public
prev_type	src/pattern.c	/^	unsigned long prev_type;$/;"	l
printUsage	examples/stats_haproxy.sh	/^printUsage ()$/;"	f
print_csv_header	src/dumpstats.c	/^int print_csv_header(struct chunk *msg)$/;"	f	signature:(struct chunk *msg)
proc	src/haproxy.c	/^		int proc;$/;"	l
process	include/types/pattern.h	/^	int (*process)(const void *arg_p,$/;"	m	struct:pattern_conv	access:public
process	include/types/pattern.h	/^	int (*process)(struct proxy *px,$/;"	m	struct:pattern_fetch	access:public
process	include/types/task.h	/^	struct task * (*process)(struct task *t);  \/* the function which processes the task *\/$/;"	m	struct:task	typeref:struct:task::process	access:public
process_chk	include/proto/checks.h	/^struct task *process_chk(struct task *t);$/;"	p	signature:(struct task *t)
process_chk	src/checks.c	/^struct task *process_chk(struct task *t)$/;"	f	signature:(struct task *t)
process_cli	include/proto/proto_http.h	/^int process_cli(struct session *t);$/;"	p	signature:(struct session *t)
process_request	examples/check	/^sub process_request$/;"	s
process_runnable_tasks	include/proto/task.h	/^void process_runnable_tasks(int *next);$/;"	p	signature:(int *next)
process_runnable_tasks	src/task.c	/^void process_runnable_tasks(int *next)$/;"	f	signature:(int *next)
process_session	include/proto/session.h	/^struct task *process_session(struct task *t);$/;"	p	signature:(struct task *t)
process_session	src/session.c	/^struct task *process_session(struct task *t)$/;"	f	signature:(struct task *t)
process_srv_conn	include/proto/proto_http.h	/^int process_srv_conn(struct session *t);$/;"	p	signature:(struct session *t)
process_srv_data	include/proto/proto_http.h	/^int process_srv_data(struct session *t);$/;"	p	signature:(struct session *t)
process_srv_queue	include/proto/queue.h	/^void process_srv_queue(struct server *s);$/;"	p	signature:(struct server *s)
process_srv_queue	src/queue.c	/^void process_srv_queue(struct server *s)$/;"	f	signature:(struct server *s)
process_sticking_rules	src/session.c	/^int process_sticking_rules(struct session *s, struct buffer *req, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit)
process_store_rules	src/session.c	/^int process_store_rules(struct session *s, struct buffer *rep, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *rep, int an_bit)
process_switching_rules	src/session.c	/^int process_switching_rules(struct session *s, struct buffer *req, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit)
process_table_expire	src/stick_table.c	/^static struct task *process_table_expire(struct task * task)$/;"	f	file:	signature:(struct task * task)
prod	include/types/buffers.h	/^	struct stream_interface *prod;  \/* producer attached to this buffer *\/$/;"	m	struct:buffer	typeref:struct:buffer::stream_interface	access:public
prod	include/types/pipe.h	/^	int prod;	\/* FD the producer must write to ; -1 if none *\/$/;"	m	struct:pipe	access:public
progname	include/types/global.h	/^extern char *progname;          \/* program name *\/$/;"	x
progname	src/haproxy.c	/^char *progname = NULL;		\/* program name *\/$/;"	v
proto	include/types/protocols.h	/^	struct protocol *proto;		\/* protocol this listener belongs to *\/$/;"	m	struct:listener	typeref:struct:listener::protocol	access:public
proto	src/log.c	/^		int proto, *plogfd;$/;"	l
proto	src/protocols.c	/^	struct protocol *proto;$/;"	l
proto_list	include/types/protocols.h	/^	struct list proto_list;         \/* list in the protocol header *\/$/;"	m	struct:listener	typeref:struct:listener::list	access:public
proto_tcpv4	src/proto_tcp.c	/^static struct protocol proto_tcpv4 = {$/;"	v	typeref:struct:protocol	file:
proto_tcpv6	src/proto_tcp.c	/^static struct protocol proto_tcpv6 = {$/;"	v	typeref:struct:protocol	file:
proto_unix	src/proto_uxst.c	/^static struct protocol proto_unix = {$/;"	v	typeref:struct:protocol	file:
protocol	include/types/protocols.h	/^struct protocol {$/;"	s
protocol::bind_all	include/types/protocols.h	/^	int (*bind_all)(struct protocol *proto);	\/* bind all unbound listeners *\/$/;"	m	struct:protocol	access:public
protocol::disable_all	include/types/protocols.h	/^	int (*disable_all)(struct protocol *proto);	\/* disable all bound listeners *\/$/;"	m	struct:protocol	access:public
protocol::enable_all	include/types/protocols.h	/^	int (*enable_all)(struct protocol *proto);	\/* enable all bound listeners *\/$/;"	m	struct:protocol	access:public
protocol::l3_addrlen	include/types/protocols.h	/^	int l3_addrlen;					\/* layer3 address length, used by hashes *\/$/;"	m	struct:protocol	access:public
protocol::list	include/types/protocols.h	/^	struct list list;				\/* list of registered protocols *\/$/;"	m	struct:protocol	typeref:struct:protocol::list	access:public
protocol::listeners	include/types/protocols.h	/^	struct list listeners;				\/* list of listeners using this protocol *\/$/;"	m	struct:protocol	typeref:struct:protocol::list	access:public
protocol::name	include/types/protocols.h	/^	char name[PROTO_NAME_LEN];			\/* protocol name, zero-terminated *\/$/;"	m	struct:protocol	access:public
protocol::nb_listeners	include/types/protocols.h	/^	int nb_listeners;				\/* number of listeners *\/$/;"	m	struct:protocol	access:public
protocol::read	include/types/protocols.h	/^	int (*read)(int fd);				\/* generic read function *\/$/;"	m	struct:protocol	access:public
protocol::sock_addrlen	include/types/protocols.h	/^	socklen_t sock_addrlen;				\/* socket address length, used by bind() *\/$/;"	m	struct:protocol	access:public
protocol::sock_domain	include/types/protocols.h	/^	int sock_domain;				\/* socket domain, as passed to socket()   *\/$/;"	m	struct:protocol	access:public
protocol::sock_family	include/types/protocols.h	/^	sa_family_t sock_family;			\/* socket family, for sockaddr *\/$/;"	m	struct:protocol	access:public
protocol::sock_prot	include/types/protocols.h	/^	int sock_prot;					\/* socket protocol, as passed to socket() *\/$/;"	m	struct:protocol	access:public
protocol::sock_type	include/types/protocols.h	/^	int sock_type;					\/* socket type, as passed to socket()     *\/$/;"	m	struct:protocol	access:public
protocol::unbind_all	include/types/protocols.h	/^	int (*unbind_all)(struct protocol *proto);	\/* unbind all bound listeners *\/$/;"	m	struct:protocol	access:public
protocol::write	include/types/protocols.h	/^	int (*write)(int fd);				\/* generic write function *\/$/;"	m	struct:protocol	access:public
protocol_bind_all	include/proto/protocols.h	/^int protocol_bind_all(void);$/;"	p	signature:(void)
protocol_bind_all	src/protocols.c	/^int protocol_bind_all(void)$/;"	f	signature:(void)
protocol_disable_all	src/protocols.c	/^int protocol_disable_all(void)$/;"	f	signature:(void)
protocol_enable_all	include/proto/protocols.h	/^int protocol_enable_all(void);$/;"	p	signature:(void)
protocol_enable_all	src/protocols.c	/^int protocol_enable_all(void)$/;"	f	signature:(void)
protocol_register	include/proto/protocols.h	/^void protocol_register(struct protocol *proto);$/;"	p	signature:(struct protocol *proto)
protocol_register	src/protocols.c	/^void protocol_register(struct protocol *proto)$/;"	f	signature:(struct protocol *proto)
protocol_unbind_all	include/proto/protocols.h	/^int protocol_unbind_all(void);$/;"	p	signature:(void)
protocol_unbind_all	src/protocols.c	/^int protocol_unbind_all(void)$/;"	f	signature:(void)
protocol_unregister	include/proto/protocols.h	/^void protocol_unregister(struct protocol *proto);$/;"	p	signature:(struct protocol *proto)
protocol_unregister	src/protocols.c	/^void protocol_unregister(struct protocol *proto)$/;"	f	signature:(struct protocol *proto)
protocols	src/protocols.c	/^static struct list protocols = LIST_HEAD_INIT(protocols);$/;"	v	typeref:struct:list	file:
proxy	include/types/acl.h	/^struct proxy;$/;"	x
proxy	include/types/proxy.h	/^extern struct proxy *proxy;$/;"	x
proxy	include/types/proxy.h	/^struct proxy {$/;"	s
proxy	include/types/server.h	/^	struct proxy *proxy;			\/* the proxy this server belongs to *\/$/;"	m	struct:server	typeref:struct:server::proxy	access:public
proxy	include/types/stream_interface.h	/^struct proxy;$/;"	x
proxy	src/proxy.c	/^struct proxy *proxy  = NULL;	\/* list of all existing proxies *\/$/;"	v	typeref:struct:proxy
proxy::__anon17::be	include/types/proxy.h	/^		struct proxy *be;		\/* default backend, or NULL if none set *\/$/;"	m	union:proxy::__anon17	typeref:struct:proxy::__anon17::proxy	access:public
proxy::__anon17::name	include/types/proxy.h	/^		char *name;			\/* default backend name during config parse *\/$/;"	m	union:proxy::__anon17	access:public
proxy::__anon18::inspect_delay	include/types/proxy.h	/^		unsigned int inspect_delay;     \/* inspection delay *\/$/;"	m	struct:proxy::__anon18	access:public
proxy::__anon18::inspect_rules	include/types/proxy.h	/^		struct list inspect_rules;      \/* inspection rules *\/$/;"	m	struct:proxy::__anon18	typeref:struct:proxy::__anon18::list	access:public
proxy::__anon19::appsession	include/types/proxy.h	/^		int appsession;                 \/* appsession cookie expiration *\/$/;"	m	struct:proxy::__anon19	access:public
proxy::__anon19::check	include/types/proxy.h	/^		int check;                      \/* maximum time for complete check *\/$/;"	m	struct:proxy::__anon19	access:public
proxy::__anon19::client	include/types/proxy.h	/^		int client;                     \/* client I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon19	access:public
proxy::__anon19::connect	include/types/proxy.h	/^		int connect;                    \/* connect timeout (in ticks) *\/$/;"	m	struct:proxy::__anon19	access:public
proxy::__anon19::httpka	include/types/proxy.h	/^		int httpka;                     \/* maximum time for a new HTTP request when using keep-alive *\/$/;"	m	struct:proxy::__anon19	access:public
proxy::__anon19::httpreq	include/types/proxy.h	/^		int httpreq;                    \/* maximum time for complete HTTP request *\/$/;"	m	struct:proxy::__anon19	access:public
proxy::__anon19::queue	include/types/proxy.h	/^		int queue;                      \/* queue timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon19	access:public
proxy::__anon19::server	include/types/proxy.h	/^		int server;                     \/* server I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon19	access:public
proxy::__anon19::tarpit	include/types/proxy.h	/^		int tarpit;                     \/* tarpit timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon19	access:public
proxy::__anon20::file	include/types/proxy.h	/^		const char *file;		\/* file where the section appears *\/$/;"	m	struct:proxy::__anon20	access:public
proxy::__anon20::id	include/types/proxy.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:proxy::__anon20	typeref:struct:proxy::__anon20::eb32_node	access:public
proxy::__anon20::line	include/types/proxy.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:proxy::__anon20	access:public
proxy::__anon20::used_listener_id	include/types/proxy.h	/^		struct eb_root used_listener_id;\/* list of listener IDs in use *\/$/;"	m	struct:proxy::__anon20	typeref:struct:proxy::__anon20::eb_root	access:public
proxy::__anon20::used_server_id	include/types/proxy.h	/^		struct eb_root used_server_id;	\/* list of server IDs in use *\/$/;"	m	struct:proxy::__anon20	typeref:struct:proxy::__anon20::eb_root	access:public
proxy::acl	include/types/proxy.h	/^	struct list acl;                        \/* ACL declared on this proxy *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::acl_requires	include/types/proxy.h	/^	int acl_requires;                       \/* Elements required to satisfy all ACLs (ACL_USE_*) *\/$/;"	m	struct:proxy	access:public
proxy::appsession_len	include/types/proxy.h	/^	int  appsession_len;			\/* length of the appsession cookie value to be used *\/$/;"	m	struct:proxy	access:public
proxy::appsession_name	include/types/proxy.h	/^	char *appsession_name;			\/* name of the cookie to look for *\/$/;"	m	struct:proxy	access:public
proxy::appsession_name_len	include/types/proxy.h	/^	int  appsession_name_len;		\/* strlen(appsession_name), computed only once *\/$/;"	m	struct:proxy	access:public
proxy::backlog	include/types/proxy.h	/^	unsigned int backlog;			\/* force the frontend's listen backlog *\/$/;"	m	struct:proxy	access:public
proxy::be_req_ana	include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy	access:public
proxy::be_rsp_ana	include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy	access:public
proxy::be_sess_per_sec	include/types/proxy.h	/^	struct freq_ctr be_sess_per_sec;	\/* sessions per second on the backend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr	access:public
proxy::beconn	include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends sessions *\/$/;"	m	struct:proxy	access:public
proxy::bind_hdr_len	include/types/proxy.h	/^	int bind_hdr_len;			\/* length of the name of the header above *\/$/;"	m	struct:proxy	access:public
proxy::bind_hdr_name	include/types/proxy.h	/^	char *bind_hdr_name;			\/* bind to this header name if defined *\/$/;"	m	struct:proxy	access:public
proxy::bind_hdr_occ	include/types/proxy.h	/^	int bind_hdr_occ;			\/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled *\/$/;"	m	struct:proxy	access:public
proxy::bind_proc	include/types/proxy.h	/^	unsigned int bind_proc;			\/* bitmask of processes using this proxy. 0 = all. *\/$/;"	m	struct:proxy	access:public
proxy::block_cond	include/types/proxy.h	/^	struct list block_cond;                 \/* early blocking conditions (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::cap	include/types/proxy.h	/^	int cap;				\/* supported capabilities (PR_CAP_*) *\/$/;"	m	struct:proxy	access:public
proxy::capture_len	include/types/proxy.h	/^	int  capture_len;			\/* length of the string to be captured *\/$/;"	m	struct:proxy	access:public
proxy::capture_name	include/types/proxy.h	/^	char *capture_name;			\/* beginning of the name of the cookie to capture *\/$/;"	m	struct:proxy	access:public
proxy::capture_namelen	include/types/proxy.h	/^	int  capture_namelen;			\/* length of the cookie name to match *\/$/;"	m	struct:proxy	access:public
proxy::check_len	include/types/proxy.h	/^	int check_len;				\/* Length of the HTTP or SSL3 request *\/$/;"	m	struct:proxy	access:public
proxy::check_req	include/types/proxy.h	/^	char *check_req;			\/* HTTP or SSL request to use for PR_O_HTTP_CHK|PR_O_SSL3_CHK *\/$/;"	m	struct:proxy	access:public
proxy::conf	include/types/proxy.h	/^	} conf;					\/* config information *\/$/;"	m	struct:proxy	typeref:struct:proxy::__anon20	access:public
proxy::conn_retries	include/types/proxy.h	/^	int conn_retries;			\/* maximum number of connect retries *\/$/;"	m	struct:proxy	access:public
proxy::cookie_domain	include/types/proxy.h	/^	char *cookie_domain;			\/* domain used to insert the cookie *\/$/;"	m	struct:proxy	access:public
proxy::cookie_len	include/types/proxy.h	/^	int  cookie_len;			\/* strlen(cookie_name), computed only once *\/$/;"	m	struct:proxy	access:public
proxy::cookie_maxidle	include/types/proxy.h	/^	unsigned int cookie_maxidle;		\/* max idle time for this cookie *\/$/;"	m	struct:proxy	access:public
proxy::cookie_maxlife	include/types/proxy.h	/^	unsigned int cookie_maxlife;		\/* max life time for this cookie *\/$/;"	m	struct:proxy	access:public
proxy::cookie_name	include/types/proxy.h	/^	char *cookie_name;			\/* name of the cookie to look for *\/$/;"	m	struct:proxy	access:public
proxy::counters	include/types/proxy.h	/^	struct pxcounters counters;		\/* statistics counters *\/$/;"	m	struct:proxy	typeref:struct:proxy::pxcounters	access:public
proxy::defbe	include/types/proxy.h	/^	} defbe;$/;"	m	struct:proxy	typeref:union:proxy::__anon17	access:public
proxy::defsrv	include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
proxy::desc	include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy	access:public
proxy::dispatch_addr	include/types/proxy.h	/^	struct sockaddr_in dispatch_addr;	\/* the default address to connect to *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_in	access:public
proxy::down_time	include/types/proxy.h	/^	unsigned down_time;			\/* total time the proxy was down *\/$/;"	m	struct:proxy	access:public
proxy::down_trans	include/types/proxy.h	/^	unsigned down_trans;			\/* up-down transitions *\/$/;"	m	struct:proxy	access:public
proxy::errmsg	include/types/proxy.h	/^	struct chunk errmsg[HTTP_ERR_SIZE];	\/* default or customized error messages for known errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::chunk	access:public
proxy::except_mask	include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
proxy::except_mask_to	include/types/proxy.h	/^	struct in_addr except_mask_to;		\/* the netmask for except_to. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr	access:public
proxy::except_net	include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr	access:public
proxy::except_to	include/types/proxy.h	/^	struct in_addr except_to;		\/* don't x-original-to for this address. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr	access:public
proxy::expect_regex	include/types/proxy.h	/^	regex_t *expect_regex;			\/* http-check expected content *\/$/;"	m	struct:proxy	access:public
proxy::expect_str	include/types/proxy.h	/^	char *expect_str;			\/* http-check expected content *\/$/;"	m	struct:proxy	access:public
proxy::fe_req_ana	include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy	access:public
proxy::fe_req_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_req_per_sec;		\/* HTTP requests per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr	access:public
proxy::fe_rsp_ana	include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy	access:public
proxy::fe_sess_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_sess_per_sec;	\/* sessions per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr	access:public
proxy::fe_sps_lim	include/types/proxy.h	/^	unsigned int fe_sps_lim;		\/* limit on new sessions per second on the frontend *\/$/;"	m	struct:proxy	access:public
proxy::feconn	include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends sessions *\/$/;"	m	struct:proxy	access:public
proxy::fullconn	include/types/proxy.h	/^	unsigned int fullconn;			\/* #conns on backend above which servers are used at full load *\/$/;"	m	struct:proxy	access:public
proxy::fwdfor_hdr_len	include/types/proxy.h	/^	int fwdfor_hdr_len;			\/* length of "x-forwarded-for" header *\/$/;"	m	struct:proxy	access:public
proxy::fwdfor_hdr_name	include/types/proxy.h	/^	char *fwdfor_hdr_name;			\/* header to use - default: "x-forwarded-for" *\/$/;"	m	struct:proxy	access:public
proxy::grace	include/types/proxy.h	/^	int grace;				\/* grace time after stop request *\/$/;"	m	struct:proxy	access:public
proxy::hdr_idx_pool	include/types/proxy.h	/^	struct pool_head *hdr_idx_pool;         \/* pools of pre-allocated int* used for headers indexing *\/$/;"	m	struct:proxy	typeref:struct:proxy::pool_head	access:public
proxy::hh_len	include/types/proxy.h	/^	int  hh_len;				\/* strlen(hh_name), computed only once *\/$/;"	m	struct:proxy	access:public
proxy::hh_match_domain	include/types/proxy.h	/^	int  hh_match_domain;			\/* toggle use of special match function *\/$/;"	m	struct:proxy	access:public
proxy::hh_name	include/types/proxy.h	/^	char *hh_name;				\/* name of the header parameter used for hashing *\/$/;"	m	struct:proxy	access:public
proxy::htbl_proxy	include/types/proxy.h	/^	struct appsession_hash htbl_proxy;	\/* Per Proxy hashtable *\/$/;"	m	struct:proxy	typeref:struct:proxy::appsession_hash	access:public
proxy::id	include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy	access:public
proxy::iface_len	include/types/proxy.h	/^	int iface_len;				\/* bind interface name length *\/$/;"	m	struct:proxy	access:public
proxy::iface_name	include/types/proxy.h	/^	char *iface_name;			\/* bind interface name or NULL *\/$/;"	m	struct:proxy	access:public
proxy::invalid_rep	include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
proxy::invalid_req	include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::error_snapshot	access:public
proxy::last_change	include/types/proxy.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:proxy	access:public
proxy::lbprm	include/types/proxy.h	/^	struct lbprm lbprm;			\/* load-balancing parameters *\/$/;"	m	struct:proxy	typeref:struct:proxy::lbprm	access:public
proxy::listen	include/types/proxy.h	/^	struct listener *listen;		\/* the listen addresses and sockets *\/$/;"	m	struct:proxy	typeref:struct:proxy::listener	access:public
proxy::logfac1	include/types/proxy.h	/^	signed char logfac1, logfac2;		\/* log facility for both servers. -1 = disabled *\/$/;"	m	struct:proxy	access:public
proxy::logfac2	include/types/proxy.h	/^	signed char logfac1, logfac2;		\/* log facility for both servers. -1 = disabled *\/$/;"	m	struct:proxy	access:public
proxy::loglev1	include/types/proxy.h	/^	int loglev1, loglev2;			\/* log level for each server, 7 by default *\/$/;"	m	struct:proxy	access:public
proxy::loglev2	include/types/proxy.h	/^	int loglev1, loglev2;			\/* log level for each server, 7 by default *\/$/;"	m	struct:proxy	access:public
proxy::logsrv1	include/types/proxy.h	/^	struct logsrv logsrv1, logsrv2;		\/* 2 syslog servers *\/$/;"	m	struct:proxy	typeref:struct:proxy::logsrv	access:public
proxy::logsrv2	include/types/proxy.h	/^	struct logsrv logsrv1, logsrv2;		\/* 2 syslog servers *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
proxy::maxconn	include/types/proxy.h	/^	unsigned int maxconn;			\/* max # of active sessions on the frontend *\/$/;"	m	struct:proxy	access:public
proxy::minlvl1	include/types/proxy.h	/^	int minlvl1, minlvl2;			\/* minimum log level for each server, 0 by default *\/$/;"	m	struct:proxy	access:public
proxy::minlvl2	include/types/proxy.h	/^	int minlvl1, minlvl2;			\/* minimum log level for each server, 0 by default *\/$/;"	m	struct:proxy	access:public
proxy::mode	include/types/proxy.h	/^	int mode;				\/* mode = PR_MODE_TCP, PR_MODE_HTTP or PR_MODE_HEALTH *\/$/;"	m	struct:proxy	access:public
proxy::mon_fail_cond	include/types/proxy.h	/^	struct list mon_fail_cond;              \/* list of conditions to fail monitoring requests (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::mon_mask	include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
proxy::mon_net	include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr	access:public
proxy::monitor_uri	include/types/proxy.h	/^	char *monitor_uri;			\/* a special URI to which we respond with HTTP\/200 OK *\/$/;"	m	struct:proxy	access:public
proxy::monitor_uri_len	include/types/proxy.h	/^	int monitor_uri_len;			\/* length of the string above. 0 if unused *\/$/;"	m	struct:proxy	access:public
proxy::nb_req_cap	include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy	access:public
proxy::nb_rsp_cap	include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy	access:public
proxy::nbpend	include/types/proxy.h	/^	int nbpend;				\/* number of pending connections with no server assigned yet *\/$/;"	m	struct:proxy	access:public
proxy::next	include/types/proxy.h	/^	struct proxy *next;$/;"	m	struct:proxy	typeref:struct:proxy::proxy	access:public
proxy::no_options	include/types/proxy.h	/^	int no_options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy	access:public
proxy::no_options2	include/types/proxy.h	/^	int no_options2;			\/* PR_O2_* *\/$/;"	m	struct:proxy	access:public
proxy::options	include/types/proxy.h	/^	int options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy	access:public
proxy::options2	include/types/proxy.h	/^	int options2;				\/* PR_O2_* *\/$/;"	m	struct:proxy	access:public
proxy::orgto_hdr_len	include/types/proxy.h	/^	int orgto_hdr_len;			\/* length of "x-original-to" header *\/$/;"	m	struct:proxy	access:public
proxy::orgto_hdr_name	include/types/proxy.h	/^	char *orgto_hdr_name;			\/* header to use - default: "x-original-to" *\/$/;"	m	struct:proxy	access:public
proxy::pendconns	include/types/proxy.h	/^	struct list pendconns;			\/* pending connections with no server assigned yet *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::persist_rules	include/types/proxy.h	/^	struct list persist_rules;		\/* 'force-persist' and 'ignore-persist' rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::rdp_cookie_len	include/types/proxy.h	/^	int  rdp_cookie_len;			\/* strlen(rdp_cookie_name), computed only once *\/$/;"	m	struct:proxy	access:public
proxy::rdp_cookie_name	include/types/proxy.h	/^	char *rdp_cookie_name;			\/* name of the RDP cookie to look for *\/$/;"	m	struct:proxy	access:public
proxy::redirect_rules	include/types/proxy.h	/^	struct list redirect_rules;             \/* content redirecting rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::req_acl	include/types/proxy.h	/^	struct list req_acl;			\/* request ACL: allow\/deny\/http-auth *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::req_add	include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::req_cap	include/types/proxy.h	/^	struct cap_hdr *req_cap;		\/* chained list of request headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr	access:public
proxy::req_cap_pool	include/types/proxy.h	/^	struct pool_head *req_cap_pool,		\/* pools of pre-allocated char ** used to build the sessions *\/$/;"	m	struct:proxy	typeref:struct:proxy::pool_head	access:public
proxy::req_exp	include/types/proxy.h	/^	struct hdr_exp *req_exp;		\/* regular expressions for request headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp	access:public
proxy::rsp_add	include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
proxy::rsp_cap	include/types/proxy.h	/^	struct cap_hdr *rsp_cap;		\/* chained list of response headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr	access:public
proxy::rsp_cap_pool	include/types/proxy.h	/^	                 *rsp_cap_pool;$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
proxy::rsp_exp	include/types/proxy.h	/^	struct hdr_exp *rsp_exp;		\/* regular expressions for response headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp	access:public
proxy::source_addr	include/types/proxy.h	/^	struct sockaddr_in source_addr;		\/* the address to which we want to bind for connect() *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_in	access:public
proxy::srv	include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::server	access:public
proxy::srv_act	include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy	access:public
proxy::srv_bck	include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy	access:public
proxy::state	include/types/proxy.h	/^	int state;				\/* proxy state *\/$/;"	m	struct:proxy	access:public
proxy::sticking_rules	include/types/proxy.h	/^	struct list sticking_rules;             \/* content sticking rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::stop_time	include/types/proxy.h	/^	int stop_time;                          \/* date to stop listening, when stopping != 0 (int ticks) *\/$/;"	m	struct:proxy	access:public
proxy::storersp_rules	include/types/proxy.h	/^	struct list storersp_rules;             \/* content store response rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::switching_rules	include/types/proxy.h	/^	struct list switching_rules;            \/* content switching rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
proxy::table	include/types/proxy.h	/^	struct stktable table;			\/* table for storing sticking sessions *\/$/;"	m	struct:proxy	typeref:struct:proxy::stktable	access:public
proxy::tcp_req	include/types/proxy.h	/^	} tcp_req;$/;"	m	struct:proxy	typeref:struct:proxy::__anon18	access:public
proxy::timeout	include/types/proxy.h	/^	} timeout;$/;"	m	struct:proxy	typeref:struct:proxy::__anon19	access:public
proxy::to_log	include/types/proxy.h	/^	int to_log;				\/* things to be logged (LW_*) *\/$/;"	m	struct:proxy	access:public
proxy::totpend	include/types/proxy.h	/^	int totpend;				\/* total number of pending connections on this instance (for stats) *\/$/;"	m	struct:proxy	access:public
proxy::tproxy_addr	include/types/proxy.h	/^	struct sockaddr_in tproxy_addr;		\/* non-local address we want to bind to for connect() *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_in	access:public
proxy::uri_auth	include/types/proxy.h	/^	struct uri_auth *uri_auth;		\/* if non-NULL, the (list of) per-URI authentications *\/$/;"	m	struct:proxy	typeref:struct:proxy::uri_auth	access:public
proxy::uri_dirs_depth1	include/types/proxy.h	/^	int  uri_dirs_depth1;			\/* directories+1 (slashes) limit for uri balancing algorithm *\/$/;"	m	struct:proxy	access:public
proxy::uri_len_limit	include/types/proxy.h	/^	int  uri_len_limit;			\/* character limit for uri balancing algorithm *\/$/;"	m	struct:proxy	access:public
proxy::url_param_len	include/types/proxy.h	/^	int  url_param_len;			\/* strlen(url_param_name), computed only once *\/$/;"	m	struct:proxy	access:public
proxy::url_param_name	include/types/proxy.h	/^	char *url_param_name;			\/* name of the URL parameter used for hashing *\/$/;"	m	struct:proxy	access:public
proxy::url_param_post_limit	include/types/proxy.h	/^	unsigned url_param_post_limit;		\/* if checking POST body for URI parameter, max body to wait for *\/$/;"	m	struct:proxy	access:public
proxy::uuid	include/types/proxy.h	/^	int uuid;				\/* universally unique proxy ID, used for SNMP *\/$/;"	m	struct:proxy	access:public
proxy_cap_str	include/proto/proxy.h	/^const char *proxy_cap_str(int cap);$/;"	p	signature:(int cap)
proxy_cap_str	src/proxy.c	/^const char *proxy_cap_str(int cap)$/;"	f	signature:(int cap)
proxy_cfg_ensure_no_http	include/proto/proxy.h	/^int proxy_cfg_ensure_no_http(struct proxy *curproxy);$/;"	p	signature:(struct proxy *curproxy)
proxy_cfg_ensure_no_http	src/proxy.c	/^int proxy_cfg_ensure_no_http(struct proxy *curproxy)$/;"	f	signature:(struct proxy *curproxy)
proxy_inc_be_ctr	include/proto/proxy.h	/^static void inline proxy_inc_be_ctr(struct proxy *be)$/;"	f	signature:(struct proxy *be)
proxy_inc_fe_ctr	include/proto/proxy.h	/^static void inline proxy_inc_fe_ctr(struct listener *l, struct proxy *fe)$/;"	f	signature:(struct listener *l, struct proxy *fe)
proxy_inc_fe_req_ctr	include/proto/proxy.h	/^static void inline proxy_inc_fe_req_ctr(struct proxy *fe)$/;"	f	signature:(struct proxy *fe)
proxy_mode_str	include/proto/proxy.h	/^const char *proxy_mode_str(int mode);$/;"	p	signature:(int mode)
proxy_mode_str	src/proxy.c	/^const char *proxy_mode_str(int mode) {$/;"	f	signature:(int mode)
proxy_parse_rate_limit	src/proxy.c	/^static int proxy_parse_rate_limit(char **args, int section, struct proxy *proxy,$/;"	f	file:	signature:(char **args, int section, struct proxy *proxy, struct proxy *defpx, char *err, int errlen)
proxy_parse_timeout	src/proxy.c	/^static int proxy_parse_timeout(char **args, int section, struct proxy *proxy,$/;"	f	file:	signature:(char **args, int section, struct proxy *proxy, struct proxy *defpx, char *err, int errlen)
proxy_reset_timeouts	include/proto/proxy.h	/^static inline void proxy_reset_timeouts(struct proxy *proxy)$/;"	f	signature:(struct proxy *proxy)
proxy_type_str	include/proto/proxy.h	/^static inline const char *proxy_type_str(struct proxy *proxy)$/;"	f	signature:(struct proxy *proxy)
prst_rule	src/session.c	/^	struct persist_rule *prst_rule;$/;"	l
prune_acl	include/proto/acl.h	/^struct acl *prune_acl(struct acl *acl);$/;"	p	signature:(struct acl *acl)
prune_acl	src/acl.c	/^struct acl *prune_acl(struct acl *acl) {$/;"	f	signature:(struct acl *acl)
prune_acl_cond	include/proto/acl.h	/^struct acl_cond *prune_acl_cond(struct acl_cond *cond);$/;"	p	signature:(struct acl_cond *cond)
prune_acl_cond	src/acl.c	/^struct acl_cond *prune_acl_cond(struct acl_cond *cond)$/;"	f	signature:(struct acl_cond *cond)
prune_acl_expr	src/acl.c	/^static struct acl_expr *prune_acl_expr(struct acl_expr *expr)$/;"	f	file:	signature:(struct acl_expr *expr)
prx_log	src/log.c	/^	struct proxy *prx_log;$/;"	l
prx_log	src/proto_http.c	/^	struct proxy *prx_log;$/;"	l
prx_queue_size	include/types/session.h	/^		unsigned long prx_queue_size;	\/* overall number of sessions waiting for a connect slot on this instance at accept() time *\/$/;"	m	struct:session::__anon8	access:public
ps	src/acl.c	/^	char *ps;$/;"	l
ps	src/queue.c	/^	struct pendconn *ps, *pp;$/;"	l
pside	ebtree/ebtree.h	/^	unsigned int pside, gpside, sibtype;$/;"	l
psrv	src/lb_chash.c	/^	struct server *nsrv, *psrv;$/;"	l
ptr	include/common/epoll.h	/^		void *ptr;$/;"	m	union:epoll_event::__anon65	access:public
ptr	include/types/acl.h	/^		void *ptr;              \/* any data *\/$/;"	m	union:acl_pattern::__anon52	access:public
ptr	include/types/acl.h	/^	char *ptr;              \/* pointer to beginning of value *\/$/;"	m	struct:acl_test	access:public
ptr	include/types/acl.h	/^	} ptr;                          \/* indirect values, allocated *\/$/;"	m	struct:acl_pattern	typeref:union:acl_pattern::__anon52	access:public
ptr	include/types/session.h	/^			int ptr;		\/* <0: headers, >=0 : text pointer to restart from *\/$/;"	m	struct:session::__anon9::__anon12	access:public
ptr	src/acl.c	/^	const char *ptr = *text;$/;"	l
ptr	src/ev_epoll.c	/^	struct fd_chg *ptr;$/;"	l
ptr	src/proto_http.c	/^		char *ptr = buf->lr;$/;"	l
ptr	src/proto_http.c	/^	char *ptr = buf->lr;$/;"	l
ptr	src/proto_http.c	/^	char *ptr, *end;$/;"	l
ptr	src/proto_http.c	/^	char *ptr;$/;"	l
ptr	src/proto_http.c	/^	register char *ptr, *end; \/* request pointers, to avoid dereferences *\/$/;"	l
ptr	src/proto_tcp.c	/^	const char *ptr = NULL;$/;"	l
ptr	tests/test_hashes.c	/^  const char         *ptr;$/;"	l
ptr_arg	src/cfgparse.c	/^			const char *ptr_arg;$/;"	l
ptr_t	ebtree/ebpttree.h	/^typedef PTR_INT_TYPE ptr_t;$/;"	t
ptrn	src/pattern.c	/^	struct pattern *ptrn;$/;"	l
puid	include/types/server.h	/^	int puid;				\/* proxy-unique server ID, used for SNMP *\/$/;"	m	struct:server	access:public
put	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range	access:public
put_pipe	include/proto/pipe.h	/^void put_pipe(struct pipe *p);$/;"	p	signature:(struct pipe *p)
put_pipe	src/pipe.c	/^void put_pipe(struct pipe *p)$/;"	f	signature:(struct pipe *p)
put_srv	tests/filltab25.c	/^void put_srv(struct srv *s) {$/;"	f	signature:(struct srv *s)
px	include/types/session.h	/^			struct proxy *px;	\/* current proxy being dumped, NULL = not started yet. *\/$/;"	m	struct:session::__anon9::__anon12	typeref:struct:session::__anon9::__anon12::proxy	access:public
px	include/types/session.h	/^			struct proxy *px;$/;"	m	struct:session::__anon9::__anon10	typeref:struct:session::__anon9::__anon10::proxy	access:public
px	src/acl.c	/^				struct proxy *px;$/;"	l
px	src/backend.c	/^	struct proxy    *px   = s->be;$/;"	l
px	src/cfgparse.c	/^				struct proxy *px;$/;"	l
px	src/checks.c	/^	struct proxy *px;$/;"	l
px	src/dumpstats.c	/^			struct proxy *px;$/;"	l
px	src/dumpstats.c	/^	struct proxy *px;$/;"	l
px	src/haproxy.c	/^		struct proxy *px;$/;"	l
px	src/proto_http.c	/^	struct proxy *px;$/;"	l
px	src/proto_tcp.c	/^	struct proxy    *px   = s->be;$/;"	l
px	src/session.c	/^	struct proxy    *px   = s->be;$/;"	l
px_id	include/common/uri_auth.h	/^	char *px_id;			\/* proxy id *\/$/;"	m	struct:stat_scope	access:public
px_len	include/common/uri_auth.h	/^	int px_len;			\/* proxy name length *\/$/;"	m	struct:stat_scope	access:public
px_st	include/types/session.h	/^			short px_st, sv_st;	\/* DATA_ST_INIT or DATA_ST_DATA *\/$/;"	m	struct:session::__anon9::__anon10	access:public
pxcounters	include/types/counters.h	/^struct pxcounters {$/;"	s
pxcounters::__anon58::__anon59::rsp	include/types/counters.h	/^			long long rsp[6];	\/* http response codes *\/$/;"	m	struct:pxcounters::__anon58::__anon59	access:public
pxcounters::__anon58::http	include/types/counters.h	/^		} http;$/;"	m	union:pxcounters::__anon58	typeref:struct:pxcounters::__anon58::__anon59	access:public
pxcounters::be	include/types/counters.h	/^	} fe, be;				\/* FE and BE stats *\/$/;"	m	struct:pxcounters	typeref:union:pxcounters::__anon58	access:public
pxcounters::be_sps_max	include/types/counters.h	/^	unsigned int be_sps_max;		\/* maximum of new sessions per second seen on the backend *\/$/;"	m	struct:pxcounters	access:public
pxcounters::beconn_max	include/types/counters.h	/^	unsigned int feconn_max, beconn_max;	\/* max # of active frontend and backend sessions *\/$/;"	m	struct:pxcounters	access:public
pxcounters::bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:pxcounters	access:public
pxcounters::bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:pxcounters	access:public
pxcounters::cli_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:pxcounters	access:public
pxcounters::cum_beconn	include/types/counters.h	/^	long long cum_feconn, cum_beconn;	\/* cumulated number of processed sessions *\/$/;"	m	struct:pxcounters	access:public
pxcounters::cum_fe_req	include/types/counters.h	/^	long long cum_fe_req;			\/* cumulated number of processed HTTP requests *\/$/;"	m	struct:pxcounters	access:public
pxcounters::cum_feconn	include/types/counters.h	/^	long long cum_feconn, cum_beconn;	\/* cumulated number of processed sessions *\/$/;"	m	struct:pxcounters	access:public
pxcounters::cum_lbconn	include/types/counters.h	/^	long long cum_lbconn;			\/* cumulated number of sessions processed by load balancing *\/$/;"	m	struct:pxcounters	access:public
pxcounters::denied_req	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters	access:public
pxcounters::denied_resp	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters	access:public
pxcounters::failed_conns	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:pxcounters	access:public
pxcounters::failed_req	include/types/counters.h	/^	long long failed_req;			\/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:pxcounters	access:public
pxcounters::failed_resp	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:pxcounters	access:public
pxcounters::fe	include/types/counters.h	/^	} fe, be;				\/* FE and BE stats *\/$/;"	m	struct:pxcounters	typeref:union:pxcounters::__anon58	access:public
pxcounters::fe_rps_max	include/types/counters.h	/^	unsigned int fe_rps_max;		\/* maximum of new sessions per second seen on the frontend *\/$/;"	m	struct:pxcounters	access:public
pxcounters::fe_sps_max	include/types/counters.h	/^	unsigned int fe_sps_max;		\/* maximum of new sessions per second seen on the frontend *\/$/;"	m	struct:pxcounters	access:public
pxcounters::feconn_max	include/types/counters.h	/^	unsigned int feconn_max, beconn_max;	\/* max # of active frontend and backend sessions *\/$/;"	m	struct:pxcounters	access:public
pxcounters::nbpend_max	include/types/counters.h	/^	unsigned int nbpend_max;		\/* max number of pending connections with no server assigned yet *\/$/;"	m	struct:pxcounters	access:public
pxcounters::redispatches	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:pxcounters	access:public
pxcounters::retries	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:pxcounters	access:public
pxcounters::srv_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:pxcounters	access:public
pxerr	src/proxy.c	/^	int pxerr;$/;"	l
qdpair	src/proto_http.c	/^	int quoted, qdpair;$/;"	l
qfprintf	include/proto/log.h	/^void qfprintf(FILE *out, const char *fmt, ...)$/;"	p	signature:(FILE *out, const char *fmt, ...)
qfprintf	src/log.c	/^void qfprintf(FILE *out, const char *fmt, ...)$/;"	f	signature:(FILE *out, const char *fmt, ...)
qs	src/proto_http.c	/^						int qs = 0;$/;"	l
quantify	contrib/halog/halog.c	/^static inline int quantify(int i, int bits)$/;"	f	file:	signature:(int i, int bits)
quantify_u32	contrib/halog/halog.c	/^static inline unsigned int quantify_u32(unsigned int i, int bits)$/;"	f	file:	signature:(unsigned int i, int bits)
queue	include/types/proxy.h	/^		int queue;                      \/* queue timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon19	access:public
queue_by_weight	tests/filltab25.c	/^void queue_by_weight(struct eb_root *root, struct srv *s) {$/;"	f	signature:(struct eb_root *root, struct srv *s)
queue_by_weight_0	tests/filltab25.c	/^void queue_by_weight_0(struct eb_root *root, struct srv *s) {$/;"	f	signature:(struct eb_root *root, struct srv *s)
quoted	src/proto_http.c	/^	int quoted, qdpair;$/;"	l
r	ebtree/ebtree.h	/^	int r;$/;"	l
r	include/types/buffers.h	/^	char *r, *w, *lr;               \/* read ptr, write ptr, last read *\/$/;"	m	struct:buffer	access:public
r	include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
r_l	include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
raddr	src/cfgparse.c	/^		char *rport, *raddr;$/;"	l
range	include/types/acl.h	/^		} range; \/* integer range *\/$/;"	m	union:acl_pattern::__anon49	typeref:struct:acl_pattern::__anon49::__anon50	access:public
range	src/cfgparse.c	/^	char *c, *next, *range, *dupstr;$/;"	l
ratio	src/checks.c	/^	int ratio;$/;"	l
ratio	src/dumpstats.c	/^					unsigned int ratio;$/;"	l
ratio	src/queue.c	/^		unsigned int ratio;$/;"	l
rb_color	include/common/rbtree.h	/^	int rb_color;$/;"	m	struct:rb_node	access:public
rb_entry	include/common/rbtree.h	125;"	d
rb_erase	include/common/rbtree.h	/^extern void rb_erase(struct rb_node *, struct rb_root *);$/;"	p	signature:(struct rb_node *, struct rb_root *)
rb_erase	src/rbtree.c	/^void rb_erase(struct rb_node *node, struct rb_root *root)$/;"	f	signature:(struct rb_node *node, struct rb_root *root)
rb_first	include/common/rbtree.h	/^extern struct rb_node *rb_first(struct rb_root *);$/;"	p	signature:(struct rb_root *)
rb_first	src/rbtree.c	/^struct rb_node *rb_first(struct rb_root *root)$/;"	f	signature:(struct rb_root *root)
rb_insert_color	include/common/rbtree.h	/^extern void rb_insert_color(struct rb_node *, struct rb_root *);$/;"	p	signature:(struct rb_node *, struct rb_root *)
rb_insert_color	src/rbtree.c	/^void rb_insert_color(struct rb_node *node, struct rb_root *root)$/;"	f	signature:(struct rb_node *node, struct rb_root *root)
rb_last	include/common/rbtree.h	/^extern struct rb_node *rb_last(struct rb_root *);$/;"	p	signature:(struct rb_root *)
rb_last	src/rbtree.c	/^struct rb_node *rb_last(struct rb_root *root)$/;"	f	signature:(struct rb_root *root)
rb_left	include/common/rbtree.h	/^	struct rb_node *rb_left;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node	access:public
rb_link_node	include/common/rbtree.h	/^static inline void rb_link_node(struct rb_node * node, struct rb_node * parent,$/;"	f	signature:(struct rb_node * node, struct rb_node * parent, struct rb_node ** rb_link)
rb_next	include/common/rbtree.h	/^extern struct rb_node *rb_next(struct rb_node *);$/;"	p	signature:(struct rb_node *)
rb_next	src/rbtree.c	/^struct rb_node *rb_next(struct rb_node *node)$/;"	f	signature:(struct rb_node *node)
rb_node	include/common/rbtree.h	/^	struct rb_node *rb_node;$/;"	m	struct:rb_root	typeref:struct:rb_root::rb_node	access:public
rb_node	include/common/rbtree.h	/^struct rb_node$/;"	s
rb_node::rb_color	include/common/rbtree.h	/^	int rb_color;$/;"	m	struct:rb_node	access:public
rb_node::rb_left	include/common/rbtree.h	/^	struct rb_node *rb_left;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node	access:public
rb_node::rb_parent	include/common/rbtree.h	/^	struct rb_node *rb_parent;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node	access:public
rb_node::rb_right	include/common/rbtree.h	/^	struct rb_node *rb_right;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node	access:public
rb_parent	include/common/rbtree.h	/^	struct rb_node *rb_parent;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node	access:public
rb_prev	include/common/rbtree.h	/^extern struct rb_node *rb_prev(struct rb_node *);$/;"	p	signature:(struct rb_node *)
rb_prev	src/rbtree.c	/^struct rb_node *rb_prev(struct rb_node *node)$/;"	f	signature:(struct rb_node *node)
rb_replace_node	include/common/rbtree.h	/^extern void rb_replace_node(struct rb_node *victim, struct rb_node *new,$/;"	p	signature:(struct rb_node *victim, struct rb_node *new, struct rb_root *root)
rb_replace_node	src/rbtree.c	/^void rb_replace_node(struct rb_node *victim, struct rb_node *new,$/;"	f	signature:(struct rb_node *victim, struct rb_node *new, struct rb_root *root)
rb_right	include/common/rbtree.h	/^	struct rb_node *rb_right;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node	access:public
rb_root	include/common/rbtree.h	/^struct rb_root$/;"	s
rb_root::rb_node	include/common/rbtree.h	/^	struct rb_node *rb_node;$/;"	m	struct:rb_root	typeref:struct:rb_root::rb_node	access:public
rc	src/cfgparse.c	/^		int rc;$/;"	l
rc	src/cfgparse.c	/^	int rc;$/;"	l
rdp_cookie_len	include/types/proxy.h	/^	int  rdp_cookie_len;			\/* strlen(rdp_cookie_name), computed only once *\/$/;"	m	struct:proxy	access:public
rdp_cookie_name	include/types/proxy.h	/^	char *rdp_cookie_name;			\/* name of the RDP cookie to look for *\/$/;"	m	struct:proxy	access:public
rdr	src/haproxy.c	/^	struct redirect_rule *rdr, *rdrb;$/;"	l
rdr	src/proto_http.c	/^			struct chunk rdr = { .str = trash, .size = sizeof(trash), .len = 0 };$/;"	l
rdr	src/proto_http.c	/^	struct chunk rdr;$/;"	l
rdr_len	include/types/proxy.h	/^	int rdr_len;$/;"	m	struct:redirect_rule	access:public
rdr_len	include/types/server.h	/^	int rdr_len;				\/* the length of the redirection prefix *\/$/;"	m	struct:server	access:public
rdr_pfx	include/types/server.h	/^	char *rdr_pfx;				\/* the redirection prefix *\/$/;"	m	struct:server	access:public
rdr_str	include/types/proxy.h	/^	char *rdr_str;$/;"	m	struct:redirect_rule	access:public
rdrb	src/haproxy.c	/^	struct redirect_rule *rdr, *rdrb;$/;"	l
read	include/types/protocols.h	/^	int (*read)(int fd);				\/* generic read function *\/$/;"	m	struct:protocol	access:public
read_freq_ctr	include/proto/freq_ctr.h	/^unsigned int read_freq_ctr(struct freq_ctr *ctr);$/;"	p	signature:(struct freq_ctr *ctr)
read_freq_ctr	src/freq_ctr.c	/^unsigned int read_freq_ctr(struct freq_ctr *ctr)$/;"	f	signature:(struct freq_ctr *ctr)
read_poll	src/stream_sock.c	/^	int read_poll = MAX_READ_POLL_LOOPS;$/;"	l
readcfgfile	include/common/cfgparse.h	/^int readcfgfile(const char *file);$/;"	p	signature:(const char *file)
readcfgfile	src/cfgparse.c	/^int readcfgfile(const char *file)$/;"	f	signature:(const char *file)
readnotnull	src/ev_select.c	/^	int readnotnull, writenotnull;$/;"	l
realm	include/types/auth.h	/^		char *realm;$/;"	m	struct:req_acl_rule::__anon27	access:public
realm	src/proto_http.c	/^		char *realm = req_acl->http_auth.realm;$/;"	l
realm_copy	src/uri_auth.c	/^	char *realm_copy;$/;"	l
realport	src/cfgparse.c	/^		short realport = 0;$/;"	l
recalc_server_map	include/proto/lb_map.h	/^void recalc_server_map(struct proxy *px);$/;"	p	signature:(struct proxy *px)
recalc_server_map	src/lb_map.c	/^void recalc_server_map(struct proxy *px)$/;"	f	signature:(struct proxy *px)
recount_servers	include/proto/backend.h	/^void recount_servers(struct proxy *px);$/;"	p	signature:(struct proxy *px)
recount_servers	src/backend.c	/^void recount_servers(struct proxy *px)$/;"	f	signature:(struct proxy *px)
recurse	src/memory.c	/^	static int recurse;$/;"	l	file:
recv_enough	include/types/global.h	/^		int recv_enough;   \/* how many input bytes at once are "enough" *\/$/;"	m	struct:global::__anon16	access:public
redirect_rule	include/types/proxy.h	/^struct redirect_rule {$/;"	s
redirect_rule::code	include/types/proxy.h	/^	int code;$/;"	m	struct:redirect_rule	access:public
redirect_rule::cond	include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::acl_cond	access:public
redirect_rule::cookie_len	include/types/proxy.h	/^	int cookie_len;$/;"	m	struct:redirect_rule	access:public
redirect_rule::cookie_str	include/types/proxy.h	/^	char *cookie_str;$/;"	m	struct:redirect_rule	access:public
redirect_rule::flags	include/types/proxy.h	/^	unsigned int flags;$/;"	m	struct:redirect_rule	access:public
redirect_rule::list	include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::list	access:public
redirect_rule::rdr_len	include/types/proxy.h	/^	int rdr_len;$/;"	m	struct:redirect_rule	access:public
redirect_rule::rdr_str	include/types/proxy.h	/^	char *rdr_str;$/;"	m	struct:redirect_rule	access:public
redirect_rule::type	include/types/proxy.h	/^	int type;$/;"	m	struct:redirect_rule	access:public
redirect_rules	include/types/proxy.h	/^	struct list redirect_rules;             \/* content redirecting rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
redispatches	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:pxcounters	access:public
redispatches	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters	access:public
redistribute_pending	src/checks.c	/^static int redistribute_pending(struct server *s)$/;"	f	file:	signature:(struct server *s)
ref	include/common/mini-clist.h	/^	struct list *ref; \/* pointer to the target's list entry *\/$/;"	m	struct:bref	typeref:struct:bref::list	access:public
refresh	include/common/uri_auth.h	/^	int refresh;			\/* refresh interval for the browser (in seconds) *\/$/;"	m	struct:uri_auth	access:public
reg	include/types/acl.h	/^		regex_t *reg;           \/* a compiled regex *\/$/;"	m	union:acl_pattern::__anon52	access:public
regex	examples/check	/^sub regex$/;"	s
relative_pid	include/types/global.h	/^extern int  relative_pid;       \/* process id starting at 1 *\/$/;"	x
relative_pid	src/haproxy.c	/^int  relative_pid = 1;		\/* process id starting at 1 *\/$/;"	v
release_spec_entry	src/ev_sepoll.c	/^REGPRM1 static void release_spec_entry(int fd)$/;"	f	file:	signature:(int fd)
rem	include/types/fd.h	/^	void REGPRM1    (*rem)(const int fd);                \/* remove any polling on <fd> *\/$/;"	m	struct:poller	access:private
rem	tests/filltab25.c	/^	int rem;$/;"	m	struct:srv	file:	access:public
rem	tests/test_hashes.c	/^int rem;$/;"	l
rem	tests/uri_hash.c	/^int rem;$/;"	l
remote	src/checks.c	/^					struct sockaddr_in *remote = NULL;$/;"	l
rep	include/types/session.h	/^	struct buffer *rep;			\/* response buffer *\/$/;"	m	struct:session	typeref:struct:session::buffer	access:public
rep	src/dumpstats.c	/^	struct buffer *rep = s->rep;$/;"	l
rep	src/session.c	/^	struct buffer *rep = si->ib;$/;"	l
replace	include/common/regex.h	/^    const char *replace;		\/* expression to set instead *\/$/;"	m	struct:hdr_exp	access:public
req	include/types/proto_http.h	/^	struct http_msg req;            \/* HTTP request message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg	access:public
req	include/types/session.h	/^	struct buffer *req;			\/* request buffer *\/$/;"	m	struct:session	typeref:struct:session::buffer	access:public
req	src/backend.c	/^	struct buffer   *req  = s->req;$/;"	l
req	src/dumpstats.c	/^	struct buffer *req = si->ob;$/;"	l
req	src/proto_http.c	/^	struct buffer *req = s->req;$/;"	l
req	src/session.c	/^	struct buffer *req = si->ob;$/;"	l
req_acl	include/common/uri_auth.h	/^	struct list req_acl; 		\/* http stats ACL: allow\/deny\/auth *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list	access:public
req_acl	include/types/proxy.h	/^	struct list req_acl;			\/* request ACL: allow\/deny\/http-auth *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
req_acl	src/auth.c	/^	struct req_acl_rule *req_acl;$/;"	l
req_acl	src/cfgparse.c	/^			struct req_acl_rule *req_acl;$/;"	l
req_acl	src/cfgparse.c	/^		struct req_acl_rule *req_acl;$/;"	l
req_acl	src/proto_http.c	/^	struct req_acl_rule *req_acl, *req_acl_final = NULL;$/;"	l
req_acl_final	src/proto_http.c	/^	struct req_acl_rule *req_acl, *req_acl_final = NULL;$/;"	l
req_acl_free	include/proto/auth.h	/^void req_acl_free(struct list *r);$/;"	p	signature:(struct list *r)
req_acl_free	src/auth.c	/^req_acl_free(struct list *r) {$/;"	f	signature:(struct list *r)
req_acl_rule	include/types/auth.h	/^struct req_acl_rule {$/;"	s
req_acl_rule::__anon27::realm	include/types/auth.h	/^		char *realm;$/;"	m	struct:req_acl_rule::__anon27	access:public
req_acl_rule::action	include/types/auth.h	/^	unsigned int action;$/;"	m	struct:req_acl_rule	access:public
req_acl_rule::cond	include/types/auth.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:req_acl_rule	typeref:struct:req_acl_rule::acl_cond	access:public
req_acl_rule::http_auth	include/types/auth.h	/^	} http_auth;$/;"	m	struct:req_acl_rule	typeref:struct:req_acl_rule::__anon27	access:public
req_acl_rule::list	include/types/auth.h	/^	struct list list;$/;"	m	struct:req_acl_rule	typeref:struct:req_acl_rule::list	access:public
req_add	include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
req_ana_back	src/session.c	/^	unsigned int req_ana_back;$/;"	l
req_cap	include/types/proxy.h	/^	struct cap_hdr *req_cap;		\/* chained list of request headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr	access:public
req_cap_pool	include/types/proxy.h	/^	struct pool_head *req_cap_pool,		\/* pools of pre-allocated char ** used to build the sessions *\/$/;"	m	struct:proxy	typeref:struct:proxy::pool_head	access:public
req_exp	include/types/proxy.h	/^	struct hdr_exp *req_exp;		\/* regular expressions for request headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp	access:public
reql	src/dumpstats.c	/^	int reql;$/;"	l
reqlen	src/cfgparse.c	/^						int packetlen, reqlen, userlen;$/;"	l
reqlen	src/cfgparse.c	/^					int reqlen = strlen(args[2]) + strlen(args[3]) + strlen(" \\r\\n") + 1;$/;"	l
reqlen	src/cfgparse.c	/^				int reqlen = strlen(args[2]) + strlen("OPTIONS  HTTP\/1.0\\r\\n") + 1;$/;"	l
reqlen	src/cfgparse.c	/^				int reqlen = strlen(args[2]) + strlen(args[3]) + 3 + strlen("\\r\\n");$/;"	l
request_count	include/common/appsession.h	/^	unsigned long int request_count;$/;"	m	struct:appsessions	access:public
requires	include/types/acl.h	/^	unsigned int requires;      \/* or'ed bit mask of all acl's ACL_USE_* *\/$/;"	m	struct:acl_cond	access:public
requires	include/types/acl.h	/^	unsigned int requires;      \/* or'ed bit mask of all acl_expr's ACL_USE_* *\/$/;"	m	struct:acl	access:public
requires	include/types/acl.h	/^	unsigned int requires;   \/* bit mask of all ACL_USE_* required to evaluate this keyword *\/$/;"	m	struct:acl_keyword	access:public
res	src/cfgparse.c	/^				const char *res;$/;"	l
res	src/dumpstats.c	/^				const char *res;$/;"	l
res	src/dumpstats.c	/^		const char *res = parse_time_err(args[1], &timeout, TIME_UNIT_MS);$/;"	l
res	src/dumpstats.c	/^	struct buffer *res = si->ib;$/;"	l
res	src/proxy.c	/^	char *res, *name;$/;"	l
res	src/proxy.c	/^	const char *res, *name;$/;"	l
result	include/types/checks.h	/^	short result;			\/* one of SRV_CHK_* *\/$/;"	m	struct:check_status	access:public
result	include/types/server.h	/^	int result;				\/* health-check result : SRV_CHK_* *\/$/;"	m	struct:server	access:public
ret	contrib/halog/fgets2-64.c	/^	int ret;$/;"	l
ret	contrib/halog/fgets2.c	/^	int ret;$/;"	l
ret	ebtree/eb32tree.h	/^			struct eb_node *ret;$/;"	l
ret	ebtree/eb64tree.h	/^				struct eb_node *ret;$/;"	l
ret	ebtree/ebimtree.h	/^				struct eb_node *ret;$/;"	l
ret	ebtree/ebistree.h	/^				struct eb_node *ret;$/;"	l
ret	ebtree/ebmbtree.h	/^				struct eb_node *ret;$/;"	l
ret	ebtree/ebmbtree.h	/^			struct eb_node *ret;$/;"	l
ret	ebtree/ebsttree.h	/^				struct eb_node *ret;$/;"	l
ret	ebtree/ebtree.h	/^	int bit, ret;$/;"	l
ret	ebtree/ebtree.h	/^	int ret = 0;$/;"	l
ret	include/common/time.h	/^	unsigned long ret;$/;"	l
ret	include/proto/buffers.h	/^	int ret;$/;"	l
ret	include/proto/port_range.h	/^	int ret;$/;"	l
ret	include/proto/port_range.h	/^	struct port_range *ret;$/;"	l
ret	src/acl.c	/^		int ret;$/;"	l
ret	src/acl.c	/^	int ret;$/;"	l
ret	src/backend.c	/^	int              ret;$/;"	l
ret	src/buffers.c	/^	int ret, max;$/;"	l
ret	src/buffers.c	/^	int ret;$/;"	l
ret	src/checks.c	/^					int ret, flags = 0;$/;"	l
ret	src/checks.c	/^			int ret;$/;"	l
ret	src/checks.c	/^	int ret;$/;"	l
ret	src/cttproxy.c	/^	int fd, ret;$/;"	l
ret	src/ev_poll.c	/^	int ret;$/;"	l
ret	src/ev_select.c	/^	int ret;$/;"	l
ret	src/ev_sepoll.c	/^	int ret;$/;"	l
ret	src/haproxy.c	/^		int ret = 0;$/;"	l
ret	src/haproxy.c	/^		int ret;$/;"	l
ret	src/haproxy.c	/^	int ret = 0;$/;"	l
ret	src/memory.c	/^	void *ret;$/;"	l
ret	src/pattern.c	/^	uint32_t ret = 0;$/;"	l
ret	src/pipe.c	/^	struct pipe *ret;$/;"	l
ret	src/proto_http.c	/^					int ret = acl_exec_cond(wl->cond, px, t, txn, ACL_DIR_RTR);$/;"	l
ret	src/proto_http.c	/^			int ret = 1;$/;"	l
ret	src/proto_http.c	/^			int ret = acl_exec_cond(cond, s->fe, s, txn, ACL_DIR_REQ);$/;"	l
ret	src/proto_http.c	/^			int ret = acl_exec_cond(wl->cond, px, s, txn, ACL_DIR_REQ);$/;"	l
ret	src/proto_http.c	/^			int ret = http_forward_trailers(req, msg);$/;"	l
ret	src/proto_http.c	/^			int ret = http_forward_trailers(res, msg);$/;"	l
ret	src/proto_http.c	/^			int ret = http_parse_chunk_size(req, msg);$/;"	l
ret	src/proto_http.c	/^			int ret = http_parse_chunk_size(res, msg);$/;"	l
ret	src/proto_http.c	/^			int ret;$/;"	l
ret	src/proto_http.c	/^		int ret = 1;$/;"	l
ret	src/proto_http.c	/^		int ret = ACL_PAT_PASS;$/;"	l
ret	src/proto_http.c	/^		int ret = acl_exec_cond(cond, px, s, txn, ACL_DIR_REQ);$/;"	l
ret	src/proto_http.c	/^		int ret = http_parse_chunk_size(req, msg);$/;"	l
ret	src/proto_http.c	/^		int ret;$/;"	l
ret	src/proto_tcp.c	/^		int ret = ACL_PAT_PASS;$/;"	l
ret	src/proto_tcp.c	/^		int ret, flags = 0;$/;"	l
ret	src/proto_tcp.c	/^	int              ret;$/;"	l
ret	src/proto_tcp.c	/^	int ret;$/;"	l
ret	src/proto_uxst.c	/^	int ret, sock;$/;"	l
ret	src/proto_uxst.c	/^	int sock, ret;$/;"	l
ret	src/session.c	/^			int ret;$/;"	l
ret	src/session.c	/^		int ret = 1 ;$/;"	l
ret	src/session.c	/^		int ret = 1;$/;"	l
ret	src/standard.c	/^	char *ret;$/;"	l
ret	src/standard.c	/^	int ret, url_code = 0;$/;"	l
ret	src/standard.c	/^	struct sockaddr_in *ret = NULL;$/;"	l
ret	src/stream_sock.c	/^	int ret, max, retval, cur_read;$/;"	l
ret	src/stream_sock.c	/^	int ret, max;$/;"	l
ret	src/stream_sock.c	/^	int ret;$/;"	l
ret	tests/test_pools.c	/^	bool ret = test_speed1();$/;"	l
ret_val	src/standard.c	/^	int ret_val;$/;"	l
retlen	src/proto_tcp.c	/^	int retlen;$/;"	l
retries	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:pxcounters	access:public
retries	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters	access:public
retry	src/haproxy.c	/^	int err, retry;$/;"	l
retval	src/proxy.c	/^	int retval, cap;$/;"	l
retval	src/stream_sock.c	/^	int ret, max, retval, cur_read;$/;"	l
retval	src/stream_sock.c	/^	int retval = 1;$/;"	l
retval	src/stream_sock.c	/^	int retval;$/;"	l
rev32	tests/uri_hash.c	/^static unsigned int rev32(unsigned int c) {$/;"	f	file:	signature:(unsigned int c)
rex	include/types/buffers.h	/^	int rex;                        \/* expiration date for a read, in ticks *\/$/;"	m	struct:buffer	access:public
right	src/rbtree.c	/^	struct rb_node *right = node->rb_right;$/;"	l
rise	include/types/server.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:server	access:public
rise	src/checks.c	/^		int health, rise, fall, state;$/;"	l
rlen	src/proto_tcp.c	/^		int rlen, plen, cilen, silen, chlen;$/;"	l
rlimit_memmax	include/types/global.h	/^	int rlimit_memmax;	\/* default ulimit-d in megs value : 0=unset *\/$/;"	m	struct:global	access:public
rlimit_nofile	include/types/global.h	/^	int rlimit_nofile;	\/* default ulimit-n value : 0=unset *\/$/;"	m	struct:global	access:public
rn	src/ev_poll.c	/^	unsigned rn, wn; \/* read new, write new *\/$/;"	l
root	src/lb_chash.c	/^	struct eb_root *root;$/;"	l
root_right	ebtree/eb32tree.h	/^	eb_troot_t *root_right = root;$/;"	l
root_right	ebtree/eb64tree.h	/^	eb_troot_t *root_right = root;$/;"	l
root_right	ebtree/ebimtree.h	/^	eb_troot_t *root_right = root;$/;"	l
root_right	ebtree/ebistree.h	/^	eb_troot_t *root_right = root;$/;"	l
root_right	ebtree/ebmbtree.h	/^	eb_troot_t *root_right = root;$/;"	l
root_right	ebtree/ebsttree.h	/^	eb_troot_t *root_right = root;$/;"	l
rot	tests/test_hashes.c	308;"	d	file:
rotate_freq_ctr	include/proto/freq_ctr.h	/^static inline void rotate_freq_ctr(struct freq_ctr *ctr)$/;"	f	signature:(struct freq_ctr *ctr)
rpf_last	src/session.c	/^	unsigned int rqf_last, rpf_last;$/;"	l
rport	src/cfgparse.c	/^		char *rport, *raddr;$/;"	l
rq	include/types/proto_http.h	/^		} rq;                          \/* request line : field, length *\/$/;"	m	union:http_msg::__anon36	typeref:struct:http_msg::__anon36::__anon37	access:public
rq	include/types/task.h	/^	struct eb32_node rq;		\/* ebtree node used to hold the task in the run queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node	access:public
rqf_last	src/session.c	/^	unsigned int rqf_last, rpf_last;$/;"	l
rqueue	src/task.c	/^static struct eb_root rqueue;      \/* tree constituting the run queue *\/$/;"	v	typeref:struct:eb_root	file:
rqueue_ticks	src/task.c	/^static unsigned int rqueue_ticks;  \/* insertion count *\/$/;"	v	file:
rr_idx	include/types/lb_map.h	/^	int rr_idx;		\/* next server to be elected in round robin mode *\/$/;"	m	struct:lb_map	access:public
rsp	include/types/counters.h	/^			long long rsp[6];	\/* http response codes *\/$/;"	m	struct:pxcounters::__anon58::__anon59	access:public
rsp	include/types/counters.h	/^			long long rsp[6];	\/* http response codes *\/$/;"	m	struct:srvcounters::__anon60::__anon61	access:public
rsp	include/types/proto_http.h	/^	struct http_msg rsp;            \/* HTTP response message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg	access:public
rsp_add	include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
rsp_cap	include/types/proxy.h	/^	struct cap_hdr *rsp_cap;		\/* chained list of response headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr	access:public
rsp_cap_pool	include/types/proxy.h	/^	                 *rsp_cap_pool;$/;"	m	struct:proxy	typeref:struct:proxy::	access:public
rsp_exp	include/types/proxy.h	/^	struct hdr_exp *rsp_exp;		\/* regular expressions for response headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp	access:public
rsrv	src/queue.c	/^	struct server *rsrv;$/;"	l
rto	include/types/buffers.h	/^	int rto;                        \/* read timeout, in ticks *\/$/;"	m	struct:buffer	access:public
rtrim	include/common/standard.h	/^static inline char *rtrim(char *s, char c) {$/;"	f	signature:(char *s, char c)
rule	src/cfgparse.c	/^			struct stats_admin_rule *rule;$/;"	l
rule	src/cfgparse.c	/^		struct persist_rule *rule;$/;"	l
rule	src/cfgparse.c	/^		struct redirect_rule *rule;$/;"	l
rule	src/cfgparse.c	/^		struct sticking_rule *rule;$/;"	l
rule	src/cfgparse.c	/^		struct switching_rule *rule;$/;"	l
rule	src/haproxy.c	/^	struct switching_rule *rule, *ruleb;$/;"	l
rule	src/proto_http.c	/^	struct redirect_rule *rule;$/;"	l
rule	src/proto_tcp.c	/^		struct tcp_rule *rule;$/;"	l
rule	src/proto_tcp.c	/^	struct tcp_rule *rule;$/;"	l
rule	src/session.c	/^		struct switching_rule *rule;$/;"	l
rule	src/session.c	/^	struct sticking_rule  *rule;$/;"	l
rule_set	src/proto_http.c	/^			struct proxy *rule_set = cur_proxy;$/;"	l
ruleb	src/haproxy.c	/^	struct switching_rule *rule, *ruleb;$/;"	l
run_poll_loop	src/haproxy.c	/^void run_poll_loop()$/;"	f
run_poller	include/proto/fd.h	/^void run_poller();$/;"	p	signature:()
run_queue	include/proto/task.h	/^extern unsigned int run_queue;    \/* run queue size *\/$/;"	x
run_queue	src/task.c	/^unsigned int run_queue = 0;$/;"	v
run_queue_cur	include/proto/task.h	/^extern unsigned int run_queue_cur;$/;"	x
run_queue_cur	src/task.c	/^unsigned int run_queue_cur = 0;    \/* copy of the run queue size *\/$/;"	v
run_test	tests/test_hashes.c	510;"	d	file:
rv	src/checks.c	/^	int rv;$/;"	l
rv	src/time.c	/^	static char rv[sizeof("24855d23h")+1];	\/\/ longest of "23h59m" and "59m59s"$/;"	l	file:
rweight	include/types/server.h	/^	unsigned rweight;			\/* remainer of weight in the current LB tree *\/$/;"	m	struct:server	access:public
s	contrib/halog/halog.c	/^			unsigned int d, h, m, s, ms;$/;"	l
s	contrib/halog/halog.c	/^	unsigned int h, m, s, ms;$/;"	l
s	include/common/mini-clist.h	/^	char *s;$/;"	m	struct:cond_wordlist	access:public
s	include/common/mini-clist.h	/^	char *s;$/;"	m	struct:wordlist	access:public
s	src/acl.c	/^	char *s;$/;"	l
s	src/acl.c	/^	struct in_addr *s;$/;"	l
s	src/appsession.c	/^	struct server       *s;$/;"	l
s	src/checks.c	/^	struct server *s = t->context;$/;"	l
s	src/checks.c	/^	struct server *s;$/;"	l
s	src/client.c	/^	struct session *s;$/;"	l
s	src/dumpstats.c	/^	struct session *s = si->private;$/;"	l
s	src/haproxy.c	/^		struct server *s = p->srv;$/;"	l
s	src/haproxy.c	/^	struct server *s,*s_next;$/;"	l
s	src/lb_chash.c	/^		struct server *s;$/;"	l
s	src/lb_fwlc.c	/^		struct server *s;$/;"	l
s	src/lb_fwrr.c	/^	struct server *s;$/;"	l
s	src/proto_uxst.c	/^	struct session *s;$/;"	l
s	src/proxy.c	/^	struct server *s;$/;"	l
s	src/session.c	/^	struct session *s = t->context;$/;"	l
s	src/standard.c	/^	char *c, *s;$/;"	l
s	src/standard.c	/^	int s;$/;"	l
s	tests/filltab25.c	/^			struct srv *s = &srv[num];$/;"	l
s	tests/filltab25.c	/^	struct srv *s;$/;"	l
s	tests/test_hashes.c	/^    unsigned char *s = (unsigned char *)str;	\/* unsigned string *\/$/;"	l
s1	include/types/fd.h	/^		unsigned int s1;             \/* Position in spec list+1. 0=not in list. *\/$/;"	m	struct:fdtab::__anon57	access:public
s30tob64	include/common/base64.h	/^const char *s30tob64(int in, char *out);$/;"	p	signature:(int in, char *out)
s30tob64	src/base64.c	/^const char *s30tob64(int in, char *out)$/;"	f	signature:(int in, char *out)
s32	ebtree/eb32tree.h	/^typedef   signed int s32;$/;"	t
s64	ebtree/eb64tree.h	/^typedef   signed long long s64;$/;"	t
s_next	src/haproxy.c	/^	struct server *s,*s_next;$/;"	l
sa	src/checks.c	/^			struct sockaddr_in sa;$/;"	l
sa	src/checks.c	/^	struct sockaddr_in sa;$/;"	l
sa	src/standard.c	/^	static struct sockaddr_in sa;$/;"	l	file:
saddr	tests/reset.c	/^	struct sockaddr_in saddr;$/;"	l
save	src/buffers.c	/^		char last, save;$/;"	l
saw_digit	src/pattern.c	/^	int saw_digit, octets, ch;$/;"	l
saw_digit	src/standard.c	/^	int saw_digit, octets, ch;$/;"	l
sax_hash	tests/test_hashes.c	/^unsigned sax_hash ( void *key, int len )$/;"	f	signature:( void *key, int len )
scope	include/common/uri_auth.h	/^	struct stat_scope *scope;	\/* linked list of authorized proxies *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::stat_scope	access:public
scope	src/dumpstats.c	/^			struct stat_scope *scope;$/;"	l
scope_list	src/uri_auth.c	/^	struct stat_scope *old_scope, **scope_list;$/;"	l
second_packet_len	src/checks.c	/^				unsigned int second_packet_len = ((unsigned int) *(s->check_data + first_packet_len + 4)) +$/;"	l
section	include/common/cfgparse.h	/^	int section;                            \/* section type for this keyword *\/$/;"	m	struct:cfg_keyword	access:public
section	include/types/session.h	/^			int section;		\/* section of the session being dumped *\/$/;"	m	struct:session::__anon9::__anon11	access:public
send_flag	src/stream_sock.c	/^			unsigned int send_flag = MSG_DONTWAIT | MSG_NOSIGNAL;$/;"	l
send_log	include/proto/log.h	/^void send_log(struct proxy *p, int level, const char *message, ...)$/;"	p	signature:(struct proxy *p, int level, const char *message, ...)
send_log	src/log.c	/^void send_log(struct proxy *p, int level, const char *message, ...)$/;"	f	signature:(struct proxy *p, int level, const char *message, ...)
send_max	include/types/buffers.h	/^	unsigned int send_max;          \/* number of bytes the sender can consume om this buffer, <= l *\/$/;"	m	struct:buffer	access:public
sent	src/log.c	/^		int sent;$/;"	l
sep	src/standard.c	/^		char *sep;$/;"	l
separator	src/proto_http.c	/^	char separator;$/;"	l
ser_msize	src/appsession.c	/^			int ser_msize, ses_msize;$/;"	l
served	include/types/server.h	/^	int served;				\/* # of active sessions currently being served (ie not pending) *\/$/;"	m	struct:server	access:public
server	include/types/proxy.h	/^		int server;                     \/* server I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon19	access:public
server	include/types/server.h	/^	struct server *server;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::server	access:public
server	include/types/server.h	/^struct server {$/;"	s
server	include/types/server.h	/^struct server;$/;"	x
server	include/types/stream_interface.h	/^struct server;$/;"	x
server::__anon62::file	include/types/server.h	/^		const char *file;		\/* file where the section appears *\/$/;"	m	struct:server::__anon62	access:public
server::__anon62::id	include/types/server.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:server::__anon62	typeref:struct:server::__anon62::eb32_node	access:public
server::__anon62::line	include/types/server.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:server::__anon62	access:public
server::addr	include/types/server.h	/^	struct sockaddr_in addr;		\/* the address to connect to *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_in	access:public
server::bind_hdr_len	include/types/server.h	/^	int bind_hdr_len;			\/* length of the name of the header above *\/$/;"	m	struct:server	access:public
server::bind_hdr_name	include/types/server.h	/^	char *bind_hdr_name;			\/* bind to this header name if defined *\/$/;"	m	struct:server	access:public
server::bind_hdr_occ	include/types/server.h	/^	int bind_hdr_occ;			\/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled *\/$/;"	m	struct:server	access:public
server::check	include/types/server.h	/^	struct task *check;                     \/* the task associated to the health check processing *\/$/;"	m	struct:server	typeref:struct:server::task	access:public
server::check_addr	include/types/server.h	/^	struct sockaddr_in check_addr;		\/* the address to check, if different from <addr> *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_in	access:public
server::check_code	include/types/server.h	/^	short check_status, check_code;		\/* check result, check code *\/$/;"	m	struct:server	access:public
server::check_data	include/types/server.h	/^	char *check_data;			\/* storage of partial check results *\/$/;"	m	struct:server	access:public
server::check_data_len	include/types/server.h	/^	int check_data_len;			\/* length of partial check results stored in check_data *\/$/;"	m	struct:server	access:public
server::check_desc	include/types/server.h	/^	char check_desc[HCHK_DESC_LEN];		\/* health check descritpion *\/$/;"	m	struct:server	access:public
server::check_duration	include/types/server.h	/^	long check_duration;			\/* time in ms took to finish last health check *\/$/;"	m	struct:server	access:public
server::check_port	include/types/server.h	/^	short check_port;			\/* the port to use for the health checks *\/$/;"	m	struct:server	access:public
server::check_start	include/types/server.h	/^	struct timeval check_start;		\/* last health check start time *\/$/;"	m	struct:server	typeref:struct:server::timeval	access:public
server::check_status	include/types/server.h	/^	short check_status, check_code;		\/* check result, check code *\/$/;"	m	struct:server	access:public
server::cklen	include/types/server.h	/^	int cklen;				\/* the len of the cookie, to speed up checks *\/$/;"	m	struct:server	access:public
server::conf	include/types/server.h	/^	} conf;					\/* config information *\/$/;"	m	struct:server	typeref:struct:server::__anon62	access:public
server::consecutive_errors	include/types/server.h	/^	int consecutive_errors;			\/* current number of consecutive errors *\/$/;"	m	struct:server	access:public
server::consecutive_errors_limit	include/types/server.h	/^	int consecutive_errors_limit;		\/* number of consecutive errors that triggers an event *\/$/;"	m	struct:server	access:public
server::cookie	include/types/server.h	/^	char *cookie;				\/* the id set in the cookie *\/$/;"	m	struct:server	access:public
server::counters	include/types/server.h	/^	struct srvcounters counters;		\/* statistics counters *\/$/;"	m	struct:server	typeref:struct:server::srvcounters	access:public
server::cur_sess	include/types/server.h	/^	int cur_sess;				\/* number of currently active sessions (including syn_sent) *\/$/;"	m	struct:server	access:public
server::curfd	include/types/server.h	/^	int curfd;				\/* file desc used for current test, or -1 if not in test *\/$/;"	m	struct:server	access:public
server::down_time	include/types/server.h	/^	unsigned down_time;			\/* total time the server was down *\/$/;"	m	struct:server	access:public
server::downinter	include/types/server.h	/^	int inter, fastinter, downinter;	\/* checks: time in milliseconds *\/$/;"	m	struct:server	access:public
server::eweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server	access:public
server::fall	include/types/server.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:server	access:public
server::fastinter	include/types/server.h	/^	int inter, fastinter, downinter;	\/* checks: time in milliseconds *\/$/;"	m	struct:server	access:public
server::health	include/types/server.h	/^	int health;				\/* 0->rise-1 = bad; rise->rise+fall-1 = good *\/$/;"	m	struct:server	access:public
server::id	include/types/server.h	/^	char *id;				\/* just for identification *\/$/;"	m	struct:server	access:public
server::iface_len	include/types/server.h	/^	int iface_len;				\/* bind interface name length *\/$/;"	m	struct:server	access:public
server::iface_name	include/types/server.h	/^	char *iface_name;			\/* bind interface name or NULL *\/$/;"	m	struct:server	access:public
server::inter	include/types/server.h	/^	int inter, fastinter, downinter;	\/* checks: time in milliseconds *\/$/;"	m	struct:server	access:public
server::iweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server	access:public
server::last_change	include/types/server.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:server	access:public
server::lb_node	include/types/server.h	/^	struct eb32_node lb_node;               \/* node used for tree-based load balancing *\/$/;"	m	struct:server	typeref:struct:server::eb32_node	access:public
server::lb_nodes	include/types/server.h	/^	struct tree_occ *lb_nodes;              \/* lb_nodes_tot * struct tree_occ *\/$/;"	m	struct:server	typeref:struct:server::tree_occ	access:public
server::lb_nodes_now	include/types/server.h	/^	unsigned lb_nodes_now;                  \/* number of lb_nodes placed in the tree (C-HASH) *\/$/;"	m	struct:server	access:public
server::lb_nodes_tot	include/types/server.h	/^	unsigned lb_nodes_tot;                  \/* number of allocated lb_nodes (C-HASH) *\/$/;"	m	struct:server	access:public
server::lb_tree	include/types/server.h	/^	struct eb_root *lb_tree;                \/* we want to know in what tree the server is *\/$/;"	m	struct:server	typeref:struct:server::eb_root	access:public
server::lpos	include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server	access:public
server::maxconn	include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server	access:public
server::maxqueue	include/types/server.h	/^	int maxqueue;				\/* maximum number of pending connections allowed *\/$/;"	m	struct:server	access:public
server::minconn	include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server	access:public
server::nbpend	include/types/server.h	/^	int nbpend;				\/* number of pending connections *\/$/;"	m	struct:server	access:public
server::next	include/types/server.h	/^	struct server *next;$/;"	m	struct:server	typeref:struct:server::server	access:public
server::next_full	include/types/server.h	/^	struct server *next_full;               \/* next server in the temporary full list *\/$/;"	m	struct:server	typeref:struct:server::server	access:public
server::npos	include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server	access:public
server::observe	include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server	access:public
server::onerror	include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server	access:public
server::pendconns	include/types/server.h	/^	struct list pendconns;			\/* pending connections *\/$/;"	m	struct:server	typeref:struct:server::list	access:public
server::prev_eweight	include/types/server.h	/^	unsigned prev_eweight;			\/* eweight before last change *\/$/;"	m	struct:server	access:public
server::prev_state	include/types/server.h	/^	int prev_state;				\/* server state before last change (SRV_*) *\/$/;"	m	struct:server	access:public
server::proxy	include/types/server.h	/^	struct proxy *proxy;			\/* the proxy this server belongs to *\/$/;"	m	struct:server	typeref:struct:server::proxy	access:public
server::puid	include/types/server.h	/^	int puid;				\/* proxy-unique server ID, used for SNMP *\/$/;"	m	struct:server	access:public
server::rdr_len	include/types/server.h	/^	int rdr_len;				\/* the length of the redirection prefix *\/$/;"	m	struct:server	access:public
server::rdr_pfx	include/types/server.h	/^	char *rdr_pfx;				\/* the redirection prefix *\/$/;"	m	struct:server	access:public
server::result	include/types/server.h	/^	int result;				\/* health-check result : SRV_CHK_* *\/$/;"	m	struct:server	access:public
server::rise	include/types/server.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:server	access:public
server::rweight	include/types/server.h	/^	unsigned rweight;			\/* remainer of weight in the current LB tree *\/$/;"	m	struct:server	access:public
server::served	include/types/server.h	/^	int served;				\/* # of active sessions currently being served (ie not pending) *\/$/;"	m	struct:server	access:public
server::sess_per_sec	include/types/server.h	/^	struct freq_ctr sess_per_sec;		\/* sessions per second on this server *\/$/;"	m	struct:server	typeref:struct:server::freq_ctr	access:public
server::slowstart	include/types/server.h	/^	int slowstart;				\/* slowstart time in seconds (ms in the conf) *\/$/;"	m	struct:server	access:public
server::source_addr	include/types/server.h	/^	struct sockaddr_in source_addr;		\/* the address to which we want to bind for connect() *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_in	access:public
server::sport_range	include/types/server.h	/^	struct port_range *sport_range;		\/* optional per-server TCP source ports *\/$/;"	m	struct:server	typeref:struct:server::port_range	access:public
server::state	include/types/server.h	/^	int state;				\/* server state (SRV_*) *\/$/;"	m	struct:server	access:public
server::tproxy_addr	include/types/server.h	/^	struct sockaddr_in tproxy_addr;		\/* non-local address we want to bind to for connect() *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_in	access:public
server::tracked	include/types/server.h	/^	struct server *tracknext, *tracked;	\/* next server in a tracking list, tracked server *\/$/;"	m	struct:server	typeref:struct:server::	access:public
server::trackit	include/types/server.h	/^	char *trackit;				\/* temporary variable to make assignment deferrable *\/$/;"	m	struct:server	access:public
server::tracknext	include/types/server.h	/^	struct server *tracknext, *tracked;	\/* next server in a tracking list, tracked server *\/$/;"	m	struct:server	typeref:struct:server::server	access:public
server::uweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server	access:public
server::wscore	include/types/server.h	/^	unsigned wscore;			\/* weight score, used during srv map computation *\/$/;"	m	struct:server	access:public
server_drop_conn	include/types/backend.h	/^	void (*server_drop_conn)(struct server *);       \/* to be called when connection is dropped *\/$/;"	m	struct:lbprm	access:public
server_id_len	src/proto_http.c	/^			size_t server_id_len;$/;"	l
server_rcvbuf	include/types/global.h	/^		int server_rcvbuf; \/* set server rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon16	access:public
server_sndbuf	include/types/global.h	/^		int server_sndbuf; \/* set server sndbuf to this value if not null *\/$/;"	m	struct:global::__anon16	access:public
server_status_printf	src/checks.c	/^static void server_status_printf(struct chunk *msg, struct server *s, unsigned options, int xferred) {$/;"	f	file:	signature:(struct chunk *msg, struct server *s, unsigned options, int xferred)
server_take_conn	include/types/backend.h	/^	void (*server_take_conn)(struct server *);       \/* to be called when connection is assigned *\/$/;"	m	struct:lbprm	access:public
server_take_conn	src/queue.c	/^		px->lbprm.server_take_conn(srv);$/;"	p	file:
server_take_conn	src/session.c	/^			newsrv->proxy->lbprm.server_take_conn(newsrv);$/;"	p	file:
serverid	include/common/appsession.h	/^	char *serverid;$/;"	m	struct:appsessions	access:public
serverid	include/common/appsession.h	/^	struct pool_head *serverid;$/;"	m	struct:app_pool	typeref:struct:app_pool::pool_head	access:public
ses_msize	src/appsession.c	/^			int ser_msize, ses_msize;$/;"	l
sess	include/types/queue.h	/^	struct session *sess;		\/* the session waiting for a connection *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::session	access:public
sess	include/types/session.h	/^		} sess;$/;"	m	union:session::__anon9	typeref:struct:session::__anon9::__anon11	access:public
sess	src/checks.c	/^		struct session *sess = pc->sess;$/;"	l
sess	src/checks.c	/^		struct session *sess;$/;"	l
sess	src/dumpstats.c	/^	struct session *sess;$/;"	l
sess	src/queue.c	/^		struct session *sess = pendconn_get_next_sess(s, p);$/;"	l
sess	src/queue.c	/^	struct session *sess;$/;"	l
sess_change_server	include/proto/session.h	/^void sess_change_server(struct session *sess, struct server *newsrv);$/;"	p	signature:(struct session *sess, struct server *newsrv)
sess_change_server	src/session.c	/^void sess_change_server(struct session *sess, struct server *newsrv)$/;"	f	signature:(struct session *sess, struct server *newsrv)
sess_cookie	src/proto_http.c	/^const char sess_cookie[8]     = "NIDVEO67";	\/* No cookie, Invalid cookie, cookie for a Down server, Valid cookie, Expired cookie, Old cookie, unknown *\/$/;"	v
sess_establish	src/session.c	/^void sess_establish(struct session *s, struct stream_interface *si)$/;"	f	signature:(struct session *s, struct stream_interface *si)
sess_fin_state	src/log.c	/^const char sess_fin_state[8]  = "-RCHDLQT";	\/* cliRequest, srvConnect, srvHeader, Data, Last, Queue, Tarpit *\/$/;"	v
sess_fin_state	src/proto_http.c	/^extern const char sess_fin_state[8];$/;"	x
sess_per_sec	include/types/server.h	/^	struct freq_ctr sess_per_sec;		\/* sessions per second on this server *\/$/;"	m	struct:server	typeref:struct:server::freq_ctr	access:public
sess_prepare_conn_req	src/session.c	/^static void sess_prepare_conn_req(struct session *s, struct stream_interface *si) {$/;"	f	file:	signature:(struct session *s, struct stream_interface *si)
sess_set_cookie	src/proto_http.c	/^const char sess_set_cookie[8] = "NPDIRU67";	\/* No set-cookie, Set-cookie found and left unchanged (passive),$/;"	v
sess_set_term_flags	include/proto/session.h	/^void sess_set_term_flags(struct session *s);$/;"	p	signature:(struct session *s)
sess_set_term_flags	src/session.c	/^void sess_set_term_flags(struct session *s)$/;"	f	signature:(struct session *s)
sess_term_cond	src/log.c	/^const char sess_term_cond[8]  = "-cCsSPRI";	\/* normal, CliTo, CliErr, SrvTo, SrvErr, PxErr, Resource, Internal *\/$/;"	v
sess_term_cond	src/proto_http.c	/^extern const char sess_term_cond[8];$/;"	x
sess_update_st_cer	src/session.c	/^int sess_update_st_cer(struct session *s, struct stream_interface *si)$/;"	f	signature:(struct session *s, struct stream_interface *si)
sess_update_st_con_tcp	src/session.c	/^int sess_update_st_con_tcp(struct session *s, struct stream_interface *si)$/;"	f	signature:(struct session *s, struct stream_interface *si)
sess_update_stream_int	src/session.c	/^void sess_update_stream_int(struct session *s, struct stream_interface *si)$/;"	f	signature:(struct session *s, struct stream_interface *si)
sessid	include/common/appsession.h	/^	char *sessid;$/;"	m	struct:appsessions	access:public
sessid	include/common/appsession.h	/^	struct pool_head *sessid;$/;"	m	struct:app_pool	typeref:struct:app_pool::pool_head	access:public
sessid	include/types/proto_http.h	/^	char *sessid;                   \/* the appsession id, if found in the request or in the response *\/$/;"	m	struct:http_txn	access:public
sessid_temp	src/proto_http.c	/^	char *sessid_temp = NULL;$/;"	l
session	include/types/acl.h	/^struct session;$/;"	x
session	include/types/buffers.h	/^struct session;$/;"	x
session	include/types/session.h	/^struct session {$/;"	s
session::__anon7::flags	include/types/session.h	/^		int flags;$/;"	m	struct:session::__anon7	access:public
session::__anon7::table	include/types/session.h	/^		struct stktable *table;$/;"	m	struct:session::__anon7	typeref:struct:session::__anon7::stktable	access:public
session::__anon7::ts	include/types/session.h	/^		struct stksess *ts;$/;"	m	struct:session::__anon7	typeref:struct:session::__anon7::stksess	access:public
session::__anon8::accept_date	include/types/session.h	/^		struct timeval accept_date;	\/* date of the accept() in user date *\/$/;"	m	struct:session::__anon8	typeref:struct:session::__anon8::timeval	access:public
session::__anon8::bytes_in	include/types/session.h	/^		long long bytes_in;		\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:session::__anon8	access:public
session::__anon8::bytes_out	include/types/session.h	/^		long long bytes_out;		\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:session::__anon8	access:public
session::__anon8::logwait	include/types/session.h	/^		int logwait;			\/* log fields waiting to be collected : LW_* *\/$/;"	m	struct:session::__anon8	access:public
session::__anon8::prx_queue_size	include/types/session.h	/^		unsigned long prx_queue_size;	\/* overall number of sessions waiting for a connect slot on this instance at accept() time *\/$/;"	m	struct:session::__anon8	access:public
session::__anon8::srv_queue_size	include/types/session.h	/^		unsigned long srv_queue_size;	\/* number of sessions waiting for a connect slot on this server at accept() time (in direct assignment) *\/$/;"	m	struct:session::__anon8	access:public
session::__anon8::t_close	include/types/session.h	/^		unsigned long t_close;		\/* total session duration *\/$/;"	m	struct:session::__anon8	access:public
session::__anon8::t_connect	include/types/session.h	/^		long  t_connect;		\/* delay before the connect() to the server succeeds, -1 if never occurs *\/$/;"	m	struct:session::__anon8	access:public
session::__anon8::t_data	include/types/session.h	/^		long  t_data;			\/* delay before the first data byte from the server ... *\/$/;"	m	struct:session::__anon8	access:public
session::__anon8::t_queue	include/types/session.h	/^		long  t_queue;			\/* delay before the session gets out of the connect queue, -1 if never occurs *\/$/;"	m	struct:session::__anon8	access:public
session::__anon8::tv_accept	include/types/session.h	/^		struct timeval tv_accept;	\/* date of the accept() in internal date (monotonic) *\/$/;"	m	struct:session::__anon8	typeref:struct:session::__anon8::timeval	access:public
session::__anon8::tv_request	include/types/session.h	/^		struct timeval tv_request;	\/* date the request arrives, {0,0} if never occurs *\/$/;"	m	struct:session::__anon8	typeref:struct:session::__anon8::timeval	access:public
session::__anon9::__anon10::flags	include/types/session.h	/^			unsigned int flags;	\/* STAT_* *\/$/;"	m	struct:session::__anon9::__anon10	access:public
session::__anon9::__anon10::iid	include/types/session.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:session::__anon9::__anon10	access:public
session::__anon9::__anon10::l	include/types/session.h	/^			struct listener *l;$/;"	m	struct:session::__anon9::__anon10	typeref:struct:session::__anon9::__anon10::listener	access:public
session::__anon9::__anon10::px	include/types/session.h	/^			struct proxy *px;$/;"	m	struct:session::__anon9::__anon10	typeref:struct:session::__anon9::__anon10::proxy	access:public
session::__anon9::__anon10::px_st	include/types/session.h	/^			short px_st, sv_st;	\/* DATA_ST_INIT or DATA_ST_DATA *\/$/;"	m	struct:session::__anon9::__anon10	access:public
session::__anon9::__anon10::sid	include/types/session.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:session::__anon9::__anon10	access:public
session::__anon9::__anon10::st_code	include/types/session.h	/^			const char *st_code;	\/* pointer to the status code returned by an action *\/$/;"	m	struct:session::__anon9::__anon10	access:public
session::__anon9::__anon10::sv	include/types/session.h	/^			struct server *sv;$/;"	m	struct:session::__anon9::__anon10	typeref:struct:session::__anon9::__anon10::server	access:public
session::__anon9::__anon10::sv_st	include/types/session.h	/^			short px_st, sv_st;	\/* DATA_ST_INIT or DATA_ST_DATA *\/$/;"	m	struct:session::__anon9::__anon10	access:public
session::__anon9::__anon10::type	include/types/session.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:session::__anon9::__anon10	access:public
session::__anon9::__anon11::bref	include/types/session.h	/^			struct bref bref;	\/* back-reference from the session being dumped *\/$/;"	m	struct:session::__anon9::__anon11	typeref:struct:session::__anon9::__anon11::bref	access:public
session::__anon9::__anon11::pos	include/types/session.h	/^			int pos;		\/* last position of the current session's buffer *\/$/;"	m	struct:session::__anon9::__anon11	access:public
session::__anon9::__anon11::section	include/types/session.h	/^			int section;		\/* section of the session being dumped *\/$/;"	m	struct:session::__anon9::__anon11	access:public
session::__anon9::__anon11::target	include/types/session.h	/^			void *target;		\/* session we want to dump, or NULL for all *\/$/;"	m	struct:session::__anon9::__anon11	access:public
session::__anon9::__anon11::uid	include/types/session.h	/^			unsigned int uid;	\/* if non-null, the uniq_id of the session being dumped *\/$/;"	m	struct:session::__anon9::__anon11	access:public
session::__anon9::__anon12::bol	include/types/session.h	/^			int bol;		\/* pointer to beginning of current line *\/$/;"	m	struct:session::__anon9::__anon12	access:public
session::__anon9::__anon12::buf	include/types/session.h	/^			unsigned int buf;	\/* buffer being dumped, 0 = req, 1 = rep *\/$/;"	m	struct:session::__anon9::__anon12	access:public
session::__anon9::__anon12::iid	include/types/session.h	/^			int iid;		\/* if >= 0, ID of the proxy to filter on *\/$/;"	m	struct:session::__anon9::__anon12	access:public
session::__anon9::__anon12::ptr	include/types/session.h	/^			int ptr;		\/* <0: headers, >=0 : text pointer to restart from *\/$/;"	m	struct:session::__anon9::__anon12	access:public
session::__anon9::__anon12::px	include/types/session.h	/^			struct proxy *px;	\/* current proxy being dumped, NULL = not started yet. *\/$/;"	m	struct:session::__anon9::__anon12	typeref:struct:session::__anon9::__anon12::proxy	access:public
session::__anon9::__anon12::sid	include/types/session.h	/^			unsigned int sid;	\/* session ID of error being dumped *\/$/;"	m	struct:session::__anon9::__anon12	access:public
session::__anon9::__anon13::msg	include/types/session.h	/^			const char *msg;	\/* pointer to a persistent message to be returned in PRINT state *\/$/;"	m	struct:session::__anon9::__anon13	access:public
session::__anon9::cli	include/types/session.h	/^		} cli;$/;"	m	union:session::__anon9	typeref:struct:session::__anon9::__anon13	access:public
session::__anon9::errors	include/types/session.h	/^		} errors;$/;"	m	union:session::__anon9	typeref:struct:session::__anon9::__anon12	access:public
session::__anon9::sess	include/types/session.h	/^		} sess;$/;"	m	union:session::__anon9	typeref:struct:session::__anon9::__anon11	access:public
session::__anon9::stats	include/types/session.h	/^		} stats;$/;"	m	union:session::__anon9	typeref:struct:session::__anon9::__anon10	access:public
session::back_refs	include/types/session.h	/^	struct list back_refs;			\/* list of users tracking this session *\/$/;"	m	struct:session	typeref:struct:session::list	access:public
session::be	include/types/session.h	/^	struct proxy *be;			\/* the proxy this session depends on for the server side *\/$/;"	m	struct:session	typeref:struct:session::proxy	access:public
session::cli_addr	include/types/session.h	/^	struct sockaddr_storage cli_addr;	\/* the client address *\/$/;"	m	struct:session	typeref:struct:session::sockaddr_storage	access:public
session::conn_retries	include/types/session.h	/^	int conn_retries;			\/* number of connect retries left *\/$/;"	m	struct:session	access:public
session::data_ctx	include/types/session.h	/^	} data_ctx;				\/* used by stats I\/O handlers to dump the stats *\/$/;"	m	struct:session	typeref:union:session::__anon9	access:public
session::data_source	include/types/session.h	/^	short int data_source;			\/* where to get the data we generate ourselves *\/$/;"	m	struct:session	access:public
session::data_state	include/types/session.h	/^	short int data_state;			\/* where to get the data we generate ourselves *\/$/;"	m	struct:session	access:public
session::do_log	include/types/session.h	/^	void (*do_log)(struct session *s);	\/* the function to call in order to log (or NULL) *\/$/;"	m	struct:session	access:public
session::fe	include/types/session.h	/^	struct proxy *fe;			\/* the proxy this session depends on for the client side *\/$/;"	m	struct:session	typeref:struct:session::proxy	access:public
session::flags	include/types/session.h	/^	int flags;				\/* some flags describing the session *\/$/;"	m	struct:session	access:public
session::from_addr	include/types/session.h	/^	struct sockaddr_in from_addr;		\/* the address to spoof when connecting to the server (transparent mode) *\/$/;"	m	struct:session	typeref:struct:session::sockaddr_in	access:public
session::frt_addr	include/types/session.h	/^	struct sockaddr_storage frt_addr;	\/* the frontend address reached by the client if SN_FRT_ADDR_SET is set *\/$/;"	m	struct:session	typeref:struct:session::sockaddr_storage	access:public
session::list	include/types/session.h	/^	struct list list;			\/* position in global sessions list *\/$/;"	m	struct:session	typeref:struct:session::list	access:public
session::listener	include/types/session.h	/^	struct listener *listener;		\/* the listener by which the request arrived *\/$/;"	m	struct:session	typeref:struct:session::listener	access:public
session::logs	include/types/session.h	/^	} logs;$/;"	m	struct:session	typeref:struct:session::__anon8	access:public
session::pend_pos	include/types/session.h	/^	struct pendconn *pend_pos;		\/* if not NULL, points to the position in the pending queue *\/$/;"	m	struct:session	typeref:struct:session::pendconn	access:public
session::prev_srv	include/types/session.h	/^	struct server *prev_srv;		\/* the server the was running on, after a redispatch, otherwise NULL *\/$/;"	m	struct:session	typeref:struct:session::server	access:public
session::rep	include/types/session.h	/^	struct buffer *rep;			\/* response buffer *\/$/;"	m	struct:session	typeref:struct:session::buffer	access:public
session::req	include/types/session.h	/^	struct buffer *req;			\/* request buffer *\/$/;"	m	struct:session	typeref:struct:session::buffer	access:public
session::si	include/types/session.h	/^	struct stream_interface si[2];          \/* client and server stream interfaces *\/$/;"	m	struct:session	typeref:struct:session::stream_interface	access:public
session::srv	include/types/session.h	/^	struct server *srv;			\/* the server the session will be running or has been running on *\/$/;"	m	struct:session	typeref:struct:session::server	access:public
session::srv_addr	include/types/session.h	/^	struct sockaddr_in srv_addr;		\/* the address to connect to *\/$/;"	m	struct:session	typeref:struct:session::sockaddr_in	access:public
session::srv_conn	include/types/session.h	/^	struct server *srv_conn;		\/* session already has a slot on a server and is not in queue *\/$/;"	m	struct:session	typeref:struct:session::server	access:public
session::srv_error	include/types/session.h	/^	void (*srv_error)(struct session *s,	\/* the function to call upon unrecoverable server errors (or NULL) *\/$/;"	m	struct:session	access:public
session::store	include/types/session.h	/^	} store[8];				\/* tracked stickiness values to store *\/$/;"	m	struct:session	typeref:struct:session::__anon7	access:public
session::store_count	include/types/session.h	/^	int store_count;$/;"	m	struct:session	access:public
session::task	include/types/session.h	/^	struct task *task;			\/* the task associated with this session *\/$/;"	m	struct:session	typeref:struct:session::task	access:public
session::term_trace	include/types/session.h	/^	unsigned term_trace;			\/* term trace: 4*8 bits indicating which part of the code closed *\/$/;"	m	struct:session	access:public
session::txn	include/types/session.h	/^	struct http_txn txn;			\/* current HTTP transaction being processed. Should become a list. *\/$/;"	m	struct:session	typeref:struct:session::http_txn	access:public
session::uniq_id	include/types/session.h	/^	unsigned int uniq_id;			\/* unique ID used for the traces *\/$/;"	m	struct:session	access:public
session_free	include/proto/session.h	/^void session_free(struct session *s);$/;"	p	signature:(struct session *s)
session_free	src/session.c	/^void session_free(struct session *s)$/;"	f	signature:(struct session *s)
session_process_counters	include/proto/session.h	/^void session_process_counters(struct session *s);$/;"	p	signature:(struct session *s)
session_process_counters	src/session.c	/^void session_process_counters(struct session *s)$/;"	f	signature:(struct session *s)
session_set_backend	include/proto/proxy.h	/^int  session_set_backend(struct session *s, struct proxy *be);$/;"	p	signature:(struct session *s, struct proxy *be)
session_set_backend	src/proxy.c	/^int session_set_backend(struct session *s, struct proxy *be)$/;"	f	signature:(struct session *s, struct proxy *be)
sessions	include/proto/session.h	/^extern struct list sessions;$/;"	x
sessions	src/session.c	/^struct list sessions;$/;"	v	typeref:struct:list
set	include/types/fd.h	/^	int  REGPRM2    (*set)(const int fd, int dir);       \/* set   polling on <fd> for <dir> *\/$/;"	m	struct:poller	access:private
set	src/cfgparse.c	/^		unsigned int set = 0;$/;"	l
set_backend_down	src/checks.c	/^static void set_backend_down(struct proxy *be)$/;"	f	file:	signature:(struct proxy *be)
set_server_check_status	src/checks.c	/^static void set_server_check_status(struct server *s, short status, char *desc) {$/;"	f	file:	signature:(struct server *s, short status, char *desc)
set_server_disabled	src/checks.c	/^static void set_server_disabled(struct server *s) {$/;"	f	file:	signature:(struct server *s)
set_server_down	include/proto/checks.h	/^void set_server_down(struct server *s);$/;"	p	signature:(struct server *s)
set_server_down	src/checks.c	/^void set_server_down(struct server *s)$/;"	f	signature:(struct server *s)
set_server_enabled	src/checks.c	/^static void set_server_enabled(struct server *s) {$/;"	f	file:	signature:(struct server *s)
set_server_status_down	include/types/backend.h	/^	void (*set_server_status_down)(struct server *); \/* to be called after status changes to DOWN *\/$/;"	m	struct:lbprm	access:public
set_server_status_down	src/checks.c	/^		s->proxy->lbprm.set_server_status_down(s);$/;"	p	file:
set_server_status_down	src/checks.c	/^	s->proxy->lbprm.set_server_status_down(s);$/;"	p	file:
set_server_status_down	src/dumpstats.c	/^				px->lbprm.set_server_status_down(sv);$/;"	p	file:
set_server_status_up	include/types/backend.h	/^	void (*set_server_status_up)(struct server *);   \/* to be called after status changes to UP *\/$/;"	m	struct:lbprm	access:public
set_server_status_up	src/checks.c	/^		s->proxy->lbprm.set_server_status_up(s);$/;"	p	file:
set_server_status_up	src/checks.c	/^	s->proxy->lbprm.set_server_status_up(s);$/;"	p	file:
set_server_status_up	src/dumpstats.c	/^				px->lbprm.set_server_status_up(sv);$/;"	p	file:
set_server_up	include/proto/checks.h	/^void set_server_up(struct server *s);$/;"	p	signature:(struct server *s)
set_server_up	src/checks.c	/^void set_server_up(struct server *s) {$/;"	f	signature:(struct server *s)
shl32	tests/uri_hash.c	/^static inline u_int32_t shl32(u_int32_t i, int count) {$/;"	f	file:	signature:(u_int32_t i, int count)
showList	examples/stats_haproxy.sh	/^showList ()$/;"	f
shr32	tests/uri_hash.c	/^static inline u_int32_t shr32(u_int32_t i, int count) {$/;"	f	file:	signature:(u_int32_t i, int count)
shutr	include/types/stream_interface.h	/^	void (*shutr)(struct stream_interface *);  \/* shutr function *\/$/;"	m	struct:stream_interface	access:public
shutr	src/dumpstats.c	/^		si->shutr(si);$/;"	p	file:
shutr	src/proto_http.c	/^	si->shutr(si);$/;"	p	file:
shutr	src/session.c	/^			si->shutr(si);$/;"	p	file:
shutw	include/types/stream_interface.h	/^	void (*shutw)(struct stream_interface *);  \/* shutw function *\/$/;"	m	struct:stream_interface	access:public
shutw	src/dumpstats.c	/^				si->shutw(si);$/;"	p	file:
shutw	src/dumpstats.c	/^			si->shutw(si);$/;"	p	file:
shutw	src/dumpstats.c	/^		si->shutw(si);$/;"	p	file:
shutw	src/proto_http.c	/^	si->shutw(si);$/;"	p	file:
shutw	src/session.c	/^			si->shutw(si);$/;"	p	file:
shutw	src/session.c	/^		si->shutw(si);$/;"	p	file:
si	include/types/session.h	/^	struct stream_interface si[2];          \/* client and server stream interfaces *\/$/;"	m	struct:session	typeref:struct:session::stream_interface	access:public
si	src/stream_sock.c	/^	struct stream_interface *si = fdtab[fd].owner;$/;"	l
sibtype	ebtree/ebtree.h	/^	unsigned int pside, gpside, sibtype;$/;"	l
sid	include/types/proxy.h	/^	unsigned int sid;		\/* ID of the faulty session *\/$/;"	m	struct:error_snapshot	access:public
sid	include/types/session.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:session::__anon9::__anon10	access:public
sid	include/types/session.h	/^			unsigned int sid;	\/* session ID of error being dumped *\/$/;"	m	struct:session::__anon9::__anon12	access:public
sid	include/types/stick_table.h	/^	int sid;                  \/* id of server to use for session *\/$/;"	m	struct:stksess	access:public
sid	src/proxy.c	/^	int pid, sid;$/;"	l
side	ebtree/eb32tree.h	/^	unsigned int side;$/;"	l
side	ebtree/eb64tree.h	/^	unsigned int side;$/;"	l
side	ebtree/ebimtree.h	/^	unsigned int side;$/;"	l
side	ebtree/ebistree.h	/^	unsigned int side;$/;"	l
side	ebtree/ebmbtree.h	/^	int pos, side;$/;"	l
side	ebtree/ebmbtree.h	/^	unsigned int side;$/;"	l
side	ebtree/ebsttree.h	/^	unsigned int side;$/;"	l
side	ebtree/ebtree.h	/^		int side;$/;"	l
sig	src/signal.c	/^	int sig, cur_pos = 0;$/;"	l
sig_dump_state	src/haproxy.c	/^void sig_dump_state(int sig)$/;"	f	signature:(int sig)
sig_int	src/haproxy.c	/^void sig_int(int sig)$/;"	f	signature:(int sig)
sig_listen	src/haproxy.c	/^void sig_listen(int sig)$/;"	f	signature:(int sig)
sig_pause	src/haproxy.c	/^void sig_pause(int sig)$/;"	f	signature:(int sig)
sig_soft_stop	src/haproxy.c	/^void sig_soft_stop(int sig)$/;"	f	signature:(int sig)
sig_term	src/haproxy.c	/^void sig_term(int sig)$/;"	f	signature:(int sig)
signal_descriptor	include/types/signal.h	/^struct signal_descriptor {$/;"	s
signal_descriptor::count	include/types/signal.h	/^	int count;  \/* number of times raised *\/$/;"	m	struct:signal_descriptor	access:public
signal_descriptor::handler	include/types/signal.h	/^	void (*handler)(int sig);$/;"	m	struct:signal_descriptor	access:public
signal_handler	include/proto/signal.h	/^void signal_handler(int sig);$/;"	p	signature:(int sig)
signal_handler	src/signal.c	/^void signal_handler(int sig)$/;"	f	signature:(int sig)
signal_init	include/proto/signal.h	/^void signal_init();$/;"	p	signature:()
signal_init	src/signal.c	/^void signal_init()$/;"	f
signal_process_queue	include/proto/signal.h	/^static inline void signal_process_queue()$/;"	f	signature:()
signal_queue	src/signal.c	/^int signal_queue[MAX_SIGNAL];                     \/* in-order queue of received signals *\/$/;"	v
signal_queue_len	include/proto/signal.h	/^extern int signal_queue_len;$/;"	x
signal_queue_len	src/signal.c	/^int signal_queue_len; \/* length of signal queue, <= MAX_SIGNAL (1 entry per signal max) *\/$/;"	v
signal_register	include/proto/signal.h	/^void signal_register(int sig, void (*handler)(int));$/;"	p	signature:(int sig, void (*handler)(int))
signal_register	src/signal.c	/^void signal_register(int sig, void (*handler)(int))$/;"	f	signature:(int sig, void (*handler)(int))
signal_state	include/proto/signal.h	/^extern struct signal_descriptor signal_state[];$/;"	x
signal_state	src/signal.c	/^struct signal_descriptor signal_state[MAX_SIGNAL];$/;"	v	typeref:struct:signal_descriptor
silen	src/proto_tcp.c	/^		int rlen, plen, cilen, silen, chlen;$/;"	l
size	include/common/memory.h	/^	unsigned int size;	\/* chunk size *\/$/;"	m	struct:pool_head	access:public
size	include/types/buffers.h	/^	size_t size;	\/* total size of the buffer, 0 if the *str is read-only *\/$/;"	m	struct:chunk	access:public
size	include/types/buffers.h	/^	unsigned int size;              \/* buffer size in bytes *\/$/;"	m	struct:buffer	access:public
size	include/types/hdr_idx.h	/^	short size;                 \/* size of the array including the head *\/$/;"	m	struct:hdr_idx	access:public
size	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range	access:public
size	include/types/stick_table.h	/^	unsigned int size;        \/* maximum stuck session in table *\/$/;"	m	struct:stktable	access:public
size	src/proto_http.c	/^	int size = 0;$/;"	l
sizeof_talloc	tests/test_pools.c	124;"	d	file:
sk	src/cfgparse.c	/^							struct sockaddr_in *sk = str2sa(args[cur_arg + 1]);$/;"	l
sk	src/cfgparse.c	/^					struct sockaddr_in *sk = str2sa(args[cur_arg + 1]);$/;"	l
sk	src/cfgparse.c	/^				struct sockaddr_in *sk = str2sa(args[1]);$/;"	l
sk	src/cfgparse.c	/^				struct sockaddr_in *sk = str2sa(args[cur_arg + 1]);$/;"	l
sk	src/cfgparse.c	/^				struct sockaddr_in *sk;$/;"	l
sk	src/cfgparse.c	/^				struct sockaddr_un *sk = str2sun(args[1]);$/;"	l
sk	src/cfgparse.c	/^			struct sockaddr_in *sk = str2sa(args[1]);$/;"	l
sk	src/cfgparse.c	/^			struct sockaddr_in *sk;$/;"	l
sk	src/cfgparse.c	/^			struct sockaddr_un *sk = str2sun(args[1]);$/;"	l
sk	src/cfgparse.c	/^		struct sockaddr_in *sk;$/;"	l
skerr	src/checks.c	/^		int skerr, err = errno;$/;"	l
skerr	src/stream_sock.c	/^			int skerr;$/;"	l
skip	src/acl.c	/^	unsigned int j, last, skip = 0;$/;"	l
skip	src/cfgparse.c	/^				int skip = 0;$/;"	l
skip_comma	src/proto_http.c	/^	int delta, skip_comma;$/;"	l
skip_fields	contrib/halog/halog.c	/^	int skip_fields = 1;$/;"	l
sl	include/types/proto_http.h	/^	} sl;                                  \/* start line *\/$/;"	m	struct:http_msg	typeref:union:http_msg::__anon36	access:public
slashes	src/backend.c	/^	int slashes = 0;$/;"	l
slowstart	include/types/server.h	/^	int slowstart;				\/* slowstart time in seconds (ms in the conf) *\/$/;"	m	struct:server	access:public
sn	src/client.c	/^				char pn[INET6_ADDRSTRLEN], sn[INET6_ADDRSTRLEN];$/;"	l
sn	src/client.c	/^				char pn[INET_ADDRSTRLEN], sn[INET_ADDRSTRLEN];$/;"	l
sname	src/acl.c	/^				char *pname, *sname;$/;"	l
sname	src/cfgparse.c	/^				char *pname, *sname;$/;"	l
sock	src/proto_uxst.c	/^	int ret, sock;$/;"	l
sock	src/proto_uxst.c	/^	int sock, ret;$/;"	l
sock	tests/reset.c	/^	int sock;$/;"	l
sock_addrlen	include/types/protocols.h	/^	socklen_t sock_addrlen;				\/* socket address length, used by bind() *\/$/;"	m	struct:protocol	access:public
sock_domain	include/types/protocols.h	/^	int sock_domain;				\/* socket domain, as passed to socket()   *\/$/;"	m	struct:protocol	access:public
sock_family	include/types/protocols.h	/^	sa_family_t sock_family;			\/* socket family, for sockaddr *\/$/;"	m	struct:protocol	access:public
sock_prot	include/types/protocols.h	/^	int sock_prot;					\/* socket protocol, as passed to socket() *\/$/;"	m	struct:protocol	access:public
sock_type	include/types/protocols.h	/^	int sock_type;					\/* socket type, as passed to socket()     *\/$/;"	m	struct:protocol	access:public
soft_stop	include/proto/proxy.h	/^void soft_stop(void);$/;"	p	signature:(void)
soft_stop	src/proxy.c	/^void soft_stop(void)$/;"	f	signature:(void)
sol	include/types/proto_http.h	/^	char *sol;                             \/* start of line, also start of message when fully parsed *\/$/;"	m	struct:http_msg	access:public
sol	src/proto_http.c	/^		char *eol, *sol;$/;"	l
sol	src/proto_http.c	/^	char *eol, *sol, *col, *sov;$/;"	l
sol	src/proto_http.c	/^	char *sol = ctx->line;$/;"	l
som	include/types/proto_http.h	/^	unsigned int som;                      \/* Start Of Message, relative to buffer *\/$/;"	m	struct:http_msg	access:public
source_addr	include/types/proxy.h	/^	struct sockaddr_in source_addr;		\/* the address to which we want to bind for connect() *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_in	access:public
source_addr	include/types/server.h	/^	struct sockaddr_in source_addr;		\/* the address to which we want to bind for connect() *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_in	access:public
sov	include/types/proto_http.h	/^	unsigned int col, sov;                 \/* current header: colon, start of value *\/$/;"	m	struct:http_msg	access:public
sov	src/proto_http.c	/^	char *eol, *sol, *col, *sov;$/;"	l
sov	src/proto_http.c	/^	char *eol, *sov;$/;"	l
spattern	src/pattern.c	/^static struct pattern spattern;$/;"	v	typeref:struct:pattern	file:
spec	include/types/fd.h	/^	} spec;$/;"	m	struct:fdtab	typeref:struct:fdtab::__anon57	access:public
spec_idx	src/ev_sepoll.c	/^	int spec_idx;$/;"	l
spec_list	src/ev_sepoll.c	/^static unsigned int *spec_list = NULL;	\/\/ speculative I\/O list$/;"	v	file:
spec_processed	src/ev_sepoll.c	/^	static unsigned int spec_processed;$/;"	l	file:
sport_range	include/types/server.h	/^	struct port_range *sport_range;		\/* optional per-server TCP source ports *\/$/;"	m	struct:server	typeref:struct:server::port_range	access:public
spread_checks	include/types/global.h	/^	int spread_checks;$/;"	m	struct:global	access:public
sps_max	include/types/counters.h	/^	unsigned int sps_max;			\/* maximum of new sessions per second seen on this server *\/$/;"	m	struct:srvcounters	access:public
sr	src/ev_poll.c	/^	int sr, sw;$/;"	l
src	include/types/proxy.h	/^	struct sockaddr_storage src;	\/* client's address *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::sockaddr_storage	access:public
src	src/checks.c	/^						struct sockaddr_in src;$/;"	l
src	src/checks.c	/^			struct chunk src;$/;"	l
src	src/dumpstats.c	/^						struct chunk src;$/;"	l
src	src/proto_tcp.c	/^			struct sockaddr_in src;$/;"	l
srv	contrib/halog/halog.c	/^			struct srv_st *srv;$/;"	l
srv	contrib/halog/halog.c	/^		struct srv_st *srv;$/;"	l
srv	include/types/acl.h	/^		struct server *srv;$/;"	m	union:acl_expr::__anon54	typeref:struct:acl_expr::__anon54::server	access:public
srv	include/types/lb_map.h	/^	struct server **srv;	\/* the server map used to apply weights *\/$/;"	m	struct:lb_map	typeref:struct:lb_map::server	access:public
srv	include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::server	access:public
srv	include/types/proxy.h	/^	struct server *srv;		\/* server associated with the error (or NULL) *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::server	access:public
srv	include/types/queue.h	/^	struct server *srv;		\/* the server we are waiting for *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::server	access:public
srv	include/types/session.h	/^	struct server *srv;			\/* the server the session will be running or has been running on *\/$/;"	m	struct:session	typeref:struct:session::server	access:public
srv	src/acl.c	/^				struct server *srv;$/;"	l
srv	src/backend.c	/^	struct server *srv = expr->arg.srv;$/;"	l
srv	src/backend.c	/^	struct server *srv;$/;"	l
srv	src/cfgparse.c	/^				struct server *srv;$/;"	l
srv	src/checks.c	/^	struct server *srv;$/;"	l
srv	src/lb_chash.c	/^	struct server *srv, *avoided;$/;"	l
srv	src/lb_chash.c	/^	struct server *srv;$/;"	l
srv	src/lb_fwlc.c	/^	struct server *srv, *avoided;$/;"	l
srv	src/lb_fwlc.c	/^	struct server *srv;$/;"	l
srv	src/lb_fwrr.c	/^	struct server *srv, *full, *avoided;$/;"	l
srv	src/lb_fwrr.c	/^	struct server *srv;$/;"	l
srv	src/lb_map.c	/^	struct server *srv, *avoided;$/;"	l
srv	src/lb_map.c	/^	struct server *srv;$/;"	l
srv	src/proto_http.c	/^				struct server *srv = t->be->srv;$/;"	l
srv	src/proto_http.c	/^			struct server *srv = t->be->srv;$/;"	l
srv	src/proto_tcp.c	/^	struct server *srv = px->srv;$/;"	l
srv	src/session.c	/^							struct server *srv;$/;"	l
srv	tests/filltab25.c	/^struct srv {$/;"	s	file:
srv	tests/filltab25.c	/^} *srv;$/;"	v	typeref:struct:srv
srv	tests/ip-hash.c	/^	int srv, nsrv;$/;"	l
srv	tests/uri_hash.c	/^    int srv, nsrv;$/;"	l
srv2	src/lb_chash.c	/^				struct server *srv2 = srv;$/;"	l
srv2	src/lb_chash.c	/^			struct server *srv2 = p->lbprm.fbck;$/;"	l
srv2	src/lb_fwlc.c	/^				struct server *srv2 = srv;$/;"	l
srv2	src/lb_fwlc.c	/^			struct server *srv2 = p->lbprm.fbck;$/;"	l
srv2	src/lb_fwrr.c	/^				struct server *srv2 = srv;$/;"	l
srv2	src/lb_fwrr.c	/^			struct server *srv2 = p->lbprm.fbck;$/;"	l
srv::last	tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:	access:public
srv::next	tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:	access:public
srv::node	tests/filltab25.c	/^	struct eb32_node node;$/;"	m	struct:srv	typeref:struct:srv::eb32_node	file:	access:public
srv::num	tests/filltab25.c	/^	int num;$/;"	m	struct:srv	file:	access:public
srv::rem	tests/filltab25.c	/^	int rem;$/;"	m	struct:srv	file:	access:public
srv::tree	tests/filltab25.c	/^	struct eb_root *tree; \/\/ we want to know where the server is$/;"	m	struct:srv	typeref:struct:srv::eb_root	file:	access:public
srv::w	tests/filltab25.c	/^	int w; \/* weight *\/$/;"	m	struct:srv	file:	access:public
srv_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:pxcounters	access:public
srv_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters	access:public
srv_act	include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy	access:public
srv_addr	include/types/session.h	/^	struct sockaddr_in srv_addr;		\/* the address to connect to *\/$/;"	m	struct:session	typeref:struct:session::sockaddr_in	access:public
srv_bck	include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy	access:public
srv_conn	include/types/session.h	/^	struct server *srv_conn;		\/* session already has a slot on a server and is not in queue *\/$/;"	m	struct:session	typeref:struct:session::server	access:public
srv_cookie	include/types/proto_http.h	/^	char *srv_cookie;               \/* cookie presented by the server, in capture mode *\/$/;"	m	struct:http_txn	access:public
srv_downtime	include/proto/server.h	/^int srv_downtime(struct server *s);$/;"	p	signature:(struct server *s)
srv_downtime	src/server.c	/^int srv_downtime(struct server *s) {$/;"	f	signature:(struct server *s)
srv_dynamic_maxconn	include/proto/queue.h	/^unsigned int srv_dynamic_maxconn(const struct server *s);$/;"	p	signature:(const struct server *s)
srv_dynamic_maxconn	src/queue.c	/^unsigned int srv_dynamic_maxconn(const struct server *s)$/;"	f	signature:(const struct server *s)
srv_error	include/types/session.h	/^	void (*srv_error)(struct session *s,	\/* the function to call upon unrecoverable server errors (or NULL) *\/$/;"	m	struct:session	access:public
srv_error	src/session.c	/^				s->srv_error(s, si);$/;"	p	file:
srv_error	src/session.c	/^			s->srv_error(s, si);$/;"	p	file:
srv_getinter	include/proto/server.h	/^int srv_getinter(struct server *s);$/;"	p	signature:(struct server *s)
srv_getinter	src/server.c	/^int srv_getinter(struct server *s) {$/;"	f	signature:(struct server *s)
srv_hlt_st	src/checks.c	/^	const char *srv_hlt_st[7] = { "DOWN", "DOWN %d\/%d",$/;"	l
srv_hlt_st	src/dumpstats.c	/^				static char *srv_hlt_st[7] = { "DOWN", "DN %d\/%d &uarr;",$/;"	l	file:
srv_hlt_st	src/dumpstats.c	/^				static char *srv_hlt_st[7] = { "DOWN,", "DOWN %d\/%d,",$/;"	l	file:
srv_inc_sess_ctr	include/proto/server.h	/^static void inline srv_inc_sess_ctr(struct server *s)$/;"	f	signature:(struct server *s)
srv_is_usable	include/proto/backend.h	/^static inline int srv_is_usable(int state, int weight)$/;"	f	signature:(int state, int weight)
srv_name	contrib/halog/halog.c	/^			char *srv_name;$/;"	l
srv_name	contrib/halog/halog.c	/^		char *srv_name;$/;"	l
srv_node	contrib/halog/halog.c	/^			struct ebmb_node *srv_node;$/;"	l
srv_node	contrib/halog/halog.c	/^		struct ebmb_node *srv_node;$/;"	l
srv_queue_size	include/types/session.h	/^		unsigned long srv_queue_size;	\/* number of sessions waiting for a connect slot on this server at accept() time (in direct assignment) *\/$/;"	m	struct:session::__anon8	access:public
srv_redispatch_connect	include/proto/backend.h	/^int srv_redispatch_connect(struct session *t);$/;"	p	signature:(struct session *t)
srv_redispatch_connect	src/backend.c	/^int srv_redispatch_connect(struct session *t)$/;"	f	signature:(struct session *t)
srv_st	contrib/halog/halog.c	/^struct srv_st {$/;"	s	file:
srv_st::cum_ct	contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:	access:public
srv_st::cum_rt	contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:	access:public
srv_st::nb_ct	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:	access:public
srv_st::nb_ok	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:	access:public
srv_st::nb_rt	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:	access:public
srv_st::node	contrib/halog/halog.c	/^	struct ebmb_node node;$/;"	m	struct:srv_st	typeref:struct:srv_st::ebmb_node	file:	access:public
srv_st::st_cnt	contrib/halog/halog.c	/^	unsigned int st_cnt[6]; \/* 0xx to 5xx *\/$/;"	m	struct:srv_st	file:	access:public
srv_was_paused	src/checks.c	/^		int srv_was_paused = s->state & SRV_GOINGDOWN;$/;"	l
srvcounters	include/types/counters.h	/^struct srvcounters {$/;"	s
srvcounters::__anon60::__anon61::rsp	include/types/counters.h	/^			long long rsp[6];	\/* http response codes *\/$/;"	m	struct:srvcounters::__anon60::__anon61	access:public
srvcounters::__anon60::http	include/types/counters.h	/^		} http;$/;"	m	union:srvcounters::__anon60	typeref:struct:srvcounters::__anon60::__anon61	access:public
srvcounters::bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:srvcounters	access:public
srvcounters::bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:srvcounters	access:public
srvcounters::cli_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters	access:public
srvcounters::cum_lbconn	include/types/counters.h	/^	long long cum_lbconn;			\/* cumulated number of sessions directed by load balancing *\/$/;"	m	struct:srvcounters	access:public
srvcounters::cum_sess	include/types/counters.h	/^	long long cum_sess;			\/* cumulated number of sessions really sent to this server *\/$/;"	m	struct:srvcounters	access:public
srvcounters::cur_sess_max	include/types/counters.h	/^	unsigned int cur_sess_max;		\/* max number of currently active sessions *\/$/;"	m	struct:srvcounters	access:public
srvcounters::down_trans	include/types/counters.h	/^	long long down_trans;			\/* up->down transitions *\/$/;"	m	struct:srvcounters	access:public
srvcounters::failed_checks	include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters	access:public
srvcounters::failed_conns	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters	access:public
srvcounters::failed_hana	include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters	access:public
srvcounters::failed_resp	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters	access:public
srvcounters::failed_secu	include/types/counters.h	/^	long long failed_secu;			\/* blocked responses because of security concerns *\/$/;"	m	struct:srvcounters	access:public
srvcounters::nbpend_max	include/types/counters.h	/^	unsigned int nbpend_max;		\/* max number of pending connections reached *\/$/;"	m	struct:srvcounters	access:public
srvcounters::p	include/types/counters.h	/^	} p;$/;"	m	struct:srvcounters	typeref:union:srvcounters::__anon60	access:public
srvcounters::redispatches	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters	access:public
srvcounters::retries	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters	access:public
srvcounters::sps_max	include/types/counters.h	/^	unsigned int sps_max;			\/* maximum of new sessions per second seen on this server *\/$/;"	m	struct:srvcounters	access:public
srvcounters::srv_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters	access:public
srvpos	src/checks.c	/^	int nbchk=0, mininter=0, srvpos=0;$/;"	l
ss	src/cfgparse.c	/^		struct sockaddr_storage ss;$/;"	l
sslv3_client_hello_pkt	src/cfgparse.c	/^const char sslv3_client_hello_pkt[] = {$/;"	v
st	include/types/proto_http.h	/^		} st;                          \/* status line : field, length *\/$/;"	m	union:http_msg::__anon36	typeref:struct:http_msg::__anon36::__anon38	access:public
st0	include/types/stream_interface.h	/^	unsigned int st0, st1;  \/* may be used by any function above *\/$/;"	m	struct:stream_interface	access:private
st1	include/types/stream_interface.h	/^	unsigned int st0, st1;  \/* may be used by any function above *\/$/;"	m	struct:stream_interface	access:private
st_cnt	contrib/halog/halog.c	/^	unsigned int st_cnt[6]; \/* 0xx to 5xx *\/$/;"	m	struct:srv_st	file:	access:public
st_code	include/types/session.h	/^			const char *st_code;	\/* pointer to the status code returned by an action *\/$/;"	m	struct:session::__anon9::__anon10	access:public
stable_key	src/pattern.c	/^static struct stktable_key stable_key;$/;"	v	typeref:struct:stktable_key	file:
start	contrib/halog/fgets2-64.c	/^				const char *start = line;$/;"	l
start	contrib/halog/fgets2.c	/^				const char *start = line;$/;"	l
start	src/memory.c	/^	struct list *start;$/;"	l
start	src/standard.c	/^	char *start;$/;"	l
start	tests/test_hashes.c	/^  char **start;$/;"	l
start_checks	include/proto/checks.h	/^int start_checks();$/;"	p	signature:()
start_checks	src/checks.c	/^int start_checks() {$/;"	f
start_date	include/common/time.h	/^extern struct timeval start_date;       \/* the process's start date *\/$/;"	x
start_date	src/time.c	/^struct timeval start_date;      \/* the process's start date *\/$/;"	v	typeref:struct:timeval
start_proxies	include/proto/proxy.h	/^int start_proxies(int verbose);$/;"	p	signature:(int verbose)
start_proxies	src/proxy.c	/^int start_proxies(int verbose)$/;"	f	signature:(int verbose)
stat	src/cfgparse.c	/^		struct stat stat;$/;"	l
stat_scope	include/common/uri_auth.h	/^struct stat_scope {$/;"	s
stat_scope::next	include/common/uri_auth.h	/^	struct stat_scope *next;	\/* next entry, NULL if none *\/$/;"	m	struct:stat_scope	typeref:struct:stat_scope::stat_scope	access:public
stat_scope::px_id	include/common/uri_auth.h	/^	char *px_id;			\/* proxy id *\/$/;"	m	struct:stat_scope	access:public
stat_scope::px_len	include/common/uri_auth.h	/^	int px_len;			\/* proxy name length *\/$/;"	m	struct:stat_scope	access:public
state	include/types/fd.h	/^	unsigned char state;                 \/* the state of this fd *\/$/;"	m	struct:fdtab	access:public
state	include/types/lb_map.h	/^	int state;		\/* LB_MAP_RECALC *\/$/;"	m	struct:lb_map	access:public
state	include/types/protocols.h	/^	int state;			\/* state: NEW, INIT, ASSIGNED, LISTEN, READY, FULL *\/$/;"	m	struct:listener	access:public
state	include/types/proxy.h	/^	int state;				\/* proxy state *\/$/;"	m	struct:proxy	access:public
state	include/types/server.h	/^	int state;				\/* server state (SRV_*) *\/$/;"	m	struct:server	access:public
state	include/types/stream_interface.h	/^	unsigned int state;     \/* SI_ST* *\/$/;"	m	struct:stream_interface	access:public
state	include/types/task.h	/^	int state;			\/* task state : bit field of TASK_* *\/$/;"	m	struct:task	access:public
state	src/checks.c	/^		int health, rise, fall, state;$/;"	l
state	src/proto_http.c	/^	unsigned int state;       \/* updated only when leaving the FSM *\/$/;"	l
stats	include/types/session.h	/^		} stats;$/;"	m	union:session::__anon9	typeref:struct:session::__anon9::__anon10	access:public
stats_add_auth	include/common/uri_auth.h	/^struct uri_auth *stats_add_auth(struct uri_auth **root, char *user);$/;"	p	signature:(struct uri_auth **root, char *user)
stats_add_auth	src/uri_auth.c	/^struct uri_auth *stats_add_auth(struct uri_auth **root, char *user)$/;"	f	signature:(struct uri_auth **root, char *user)
stats_add_scope	include/common/uri_auth.h	/^struct uri_auth *stats_add_scope(struct uri_auth **root, char *scope);$/;"	p	signature:(struct uri_auth **root, char *scope)
stats_add_scope	src/uri_auth.c	/^struct uri_auth *stats_add_scope(struct uri_auth **root, char *scope)$/;"	f	signature:(struct uri_auth **root, char *scope)
stats_admin_rule	include/common/uri_auth.h	/^struct stats_admin_rule {$/;"	s
stats_admin_rule	src/proto_http.c	/^		struct stats_admin_rule *stats_admin_rule;$/;"	l
stats_admin_rule::cond	include/common/uri_auth.h	/^	struct acl_cond *cond;	\/* acl condition to meet *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::acl_cond	access:public
stats_admin_rule::list	include/common/uri_auth.h	/^	struct list list;	\/* list linked to from the proxy *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::list	access:public
stats_check_init_uri_auth	include/common/uri_auth.h	/^struct uri_auth *stats_check_init_uri_auth(struct uri_auth **root);$/;"	p	signature:(struct uri_auth **root)
stats_check_init_uri_auth	src/uri_auth.c	/^struct uri_auth *stats_check_init_uri_auth(struct uri_auth **root)$/;"	f	signature:(struct uri_auth **root)
stats_check_uri	include/proto/proto_http.h	/^int stats_check_uri(struct session *s, struct proxy *backend);$/;"	p	signature:(struct session *s, struct proxy *backend)
stats_check_uri	src/proto_http.c	/^int stats_check_uri(struct session *t, struct proxy *backend)$/;"	f	signature:(struct session *t, struct proxy *backend)
stats_dump_errors_to_buffer	include/proto/dumpstats.h	/^int stats_dump_errors_to_buffer(struct session *s, struct buffer *rep);$/;"	p	signature:(struct session *s, struct buffer *rep)
stats_dump_errors_to_buffer	src/dumpstats.c	/^int stats_dump_errors_to_buffer(struct session *s, struct buffer *rep)$/;"	f	signature:(struct session *s, struct buffer *rep)
stats_dump_full_sess_to_buffer	src/dumpstats.c	/^int stats_dump_full_sess_to_buffer(struct session *s, struct buffer *rep)$/;"	f	signature:(struct session *s, struct buffer *rep)
stats_dump_http	include/proto/dumpstats.h	/^int stats_dump_http(struct session *s, struct buffer *rep, struct uri_auth *uri);$/;"	p	signature:(struct session *s, struct buffer *rep, struct uri_auth *uri)
stats_dump_http	src/dumpstats.c	/^int stats_dump_http(struct session *s, struct buffer *rep, struct uri_auth *uri)$/;"	f	signature:(struct session *s, struct buffer *rep, struct uri_auth *uri)
stats_dump_proxy	include/proto/dumpstats.h	/^int stats_dump_proxy(struct session *s, struct proxy *px, struct uri_auth *uri);$/;"	p	signature:(struct session *s, struct proxy *px, struct uri_auth *uri)
stats_dump_proxy	src/dumpstats.c	/^int stats_dump_proxy(struct session *s, struct proxy *px, struct uri_auth *uri)$/;"	f	signature:(struct session *s, struct proxy *px, struct uri_auth *uri)
stats_dump_raw_to_buffer	include/proto/dumpstats.h	/^int stats_dump_raw_to_buffer(struct session *s, struct buffer *rep);$/;"	p	signature:(struct session *s, struct buffer *rep)
stats_dump_raw_to_buffer	src/dumpstats.c	/^int stats_dump_raw_to_buffer(struct session *s, struct buffer *rep)$/;"	f	signature:(struct session *s, struct buffer *rep)
stats_dump_sess_to_buffer	include/proto/dumpstats.h	/^int stats_dump_sess_to_buffer(struct session *s, struct buffer *rep);$/;"	p	signature:(struct session *s, struct buffer *rep)
stats_dump_sess_to_buffer	src/dumpstats.c	/^int stats_dump_sess_to_buffer(struct session *s, struct buffer *rep)$/;"	f	signature:(struct session *s, struct buffer *rep)
stats_fe	include/types/global.h	/^	struct proxy *stats_fe;     \/* the frontend holding the stats settings *\/$/;"	m	struct:global	typeref:struct:global::proxy	access:public
stats_http_redir	src/dumpstats.c	/^int stats_http_redir(struct session *s, struct buffer *rep, struct uri_auth *uri)$/;"	f	signature:(struct session *s, struct buffer *rep, struct uri_auth *uri)
stats_io_handler	include/proto/dumpstats.h	/^void stats_io_handler(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stats_io_handler	src/dumpstats.c	/^void stats_io_handler(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stats_parse_global	src/dumpstats.c	/^static int stats_parse_global(char **args, int section_type, struct proxy *curpx,$/;"	f	file:	signature:(char **args, int section_type, struct proxy *curpx, struct proxy *defpx, char *err, int errlen)
stats_permission_denied_msg	src/dumpstats.c	/^const char stats_permission_denied_msg[] =$/;"	v
stats_set_desc	include/common/uri_auth.h	/^struct uri_auth *stats_set_desc(struct uri_auth **root, char *desc);$/;"	p	signature:(struct uri_auth **root, char *desc)
stats_set_desc	src/uri_auth.c	/^struct uri_auth *stats_set_desc(struct uri_auth **root, char *desc)$/;"	f	signature:(struct uri_auth **root, char *desc)
stats_set_flag	include/common/uri_auth.h	/^struct uri_auth *stats_set_flag(struct uri_auth **root, int flag);$/;"	p	signature:(struct uri_auth **root, int flag)
stats_set_flag	src/uri_auth.c	/^struct uri_auth *stats_set_flag(struct uri_auth **root, int flag)$/;"	f	signature:(struct uri_auth **root, int flag)
stats_set_node	include/common/uri_auth.h	/^struct uri_auth *stats_set_node(struct uri_auth **root, char *name);$/;"	p	signature:(struct uri_auth **root, char *name)
stats_set_node	src/uri_auth.c	/^struct uri_auth *stats_set_node(struct uri_auth **root, char *name)$/;"	f	signature:(struct uri_auth **root, char *name)
stats_set_realm	include/common/uri_auth.h	/^struct uri_auth *stats_set_realm(struct uri_auth **root, char *realm);$/;"	p	signature:(struct uri_auth **root, char *realm)
stats_set_realm	src/uri_auth.c	/^struct uri_auth *stats_set_realm(struct uri_auth **root, char *realm)$/;"	f	signature:(struct uri_auth **root, char *realm)
stats_set_refresh	include/common/uri_auth.h	/^struct uri_auth *stats_set_refresh(struct uri_auth **root, int interval);$/;"	p	signature:(struct uri_auth **root, int interval)
stats_set_refresh	src/uri_auth.c	/^struct uri_auth *stats_set_refresh(struct uri_auth **root, int interval)$/;"	f	signature:(struct uri_auth **root, int interval)
stats_set_uri	include/common/uri_auth.h	/^struct uri_auth *stats_set_uri(struct uri_auth **root, char *uri);$/;"	p	signature:(struct uri_auth **root, char *uri)
stats_set_uri	src/uri_auth.c	/^struct uri_auth *stats_set_uri(struct uri_auth **root, char *uri)$/;"	f	signature:(struct uri_auth **root, char *uri)
stats_sock	include/types/global.h	/^	struct listener stats_sock; \/* unix socket listener for statistics *\/$/;"	m	struct:global	typeref:struct:global::listener	access:public
stats_sock_parse_request	include/proto/dumpstats.h	/^int stats_sock_parse_request(struct stream_interface *si, char *line);$/;"	p	signature:(struct stream_interface *si, char *line)
stats_sock_parse_request	src/dumpstats.c	/^int stats_sock_parse_request(struct stream_interface *si, char *line)$/;"	f	signature:(struct stream_interface *si, char *line)
stats_sock_usage_msg	src/dumpstats.c	/^const char stats_sock_usage_msg[] =$/;"	v
status	include/types/proto_http.h	/^	int status;                     \/* HTTP status from the server, negative if from proxy *\/$/;"	m	struct:http_txn	access:public
status	src/ev_epoll.c	/^	int status;$/;"	l
status	src/ev_kqueue.c	/^	int status;$/;"	l
status	src/ev_poll.c	/^	int status;$/;"	l
status	src/ev_select.c	/^	int status;$/;"	l
status	src/ev_sepoll.c	/^	int status, eo;$/;"	l
status_code	src/checks.c	/^	char status_code[] = "000";$/;"	l
status_msg	src/checks.c	/^	static char status_msg[] = "HTTP status check returned code <000>";$/;"	l	file:
step	contrib/halog/halog.c	/^		double step;$/;"	l
step	src/lb_fwrr.c	/^			int step = grp->next_weight \/ srv->eweight;$/;"	l
step	tests/filltab25.c	/^					int step = (nsw \/*+ sw - p*\/) \/ s->w;$/;"	l
step	tests/test_hashes.c	/^  unsigned step = 16;$/;"	l
sticking_rule	include/types/proxy.h	/^struct sticking_rule {$/;"	s
sticking_rule::__anon22::name	include/types/proxy.h	/^		char *name;                     \/* target table name during config parsing *\/$/;"	m	union:sticking_rule::__anon22	access:public
sticking_rule::__anon22::t	include/types/proxy.h	/^		struct stktable *t;	        \/* target table *\/$/;"	m	union:sticking_rule::__anon22	typeref:struct:sticking_rule::__anon22::stktable	access:public
sticking_rule::cond	include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::acl_cond	access:public
sticking_rule::expr	include/types/proxy.h	/^	struct pattern_expr *expr;              \/* fetch expr to fetch key *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::pattern_expr	access:public
sticking_rule::flags	include/types/proxy.h	/^	int flags;                              \/* STK_* *\/$/;"	m	struct:sticking_rule	access:public
sticking_rule::list	include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::list	access:public
sticking_rule::table	include/types/proxy.h	/^	} table;$/;"	m	struct:sticking_rule	typeref:union:sticking_rule::__anon22	access:public
sticking_rules	include/types/proxy.h	/^	struct list sticking_rules;             \/* content sticking rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
stksess	include/types/stick_table.h	/^struct stksess {$/;"	s
stksess::expire	include/types/stick_table.h	/^	unsigned int expire;      \/* session expiration date *\/$/;"	m	struct:stksess	access:public
stksess::exps	include/types/stick_table.h	/^	struct eb32_node exps;    \/* ebtree node used to hold the session in expiration tree *\/$/;"	m	struct:stksess	typeref:struct:stksess::eb32_node	access:public
stksess::keys	include/types/stick_table.h	/^	struct ebmb_node keys;    \/* ebtree node used to hold the session in table *\/$/;"	m	struct:stksess	typeref:struct:stksess::ebmb_node	access:public
stksess::sid	include/types/stick_table.h	/^	int sid;                  \/* id of server to use for session *\/$/;"	m	struct:stksess	access:public
stksess_free	include/proto/stick_table.h	/^void stksess_free(struct stktable *t, struct stksess *ts);$/;"	p	signature:(struct stktable *t, struct stksess *ts)
stksess_free	src/stick_table.c	/^void stksess_free(struct stktable *t, struct stksess *ts)$/;"	f	signature:(struct stktable *t, struct stksess *ts)
stksess_init	src/stick_table.c	/^struct stksess *stksess_init(struct stktable *t, struct stksess * ts, struct stktable_key *key)$/;"	f	signature:(struct stktable *t, struct stksess * ts, struct stktable_key *key)
stksess_key	include/proto/stick_table.h	/^void stksess_key(struct stktable *t, struct stksess *ts, struct stktable_key *key);$/;"	p	signature:(struct stktable *t, struct stksess *ts, struct stktable_key *key)
stksess_key	src/stick_table.c	/^void stksess_key(struct stktable *t, struct stksess *ts, struct stktable_key *key)$/;"	f	signature:(struct stktable *t, struct stksess *ts, struct stktable_key *key)
stksess_new	include/proto/stick_table.h	/^struct stksess *stksess_new(struct stktable *t, struct stktable_key *key);$/;"	p	signature:(struct stktable *t, struct stktable_key *key)
stksess_new	src/stick_table.c	/^struct stksess *stksess_new(struct stktable *t, struct stktable_key *key)$/;"	f	signature:(struct stktable *t, struct stktable_key *key)
stktable	include/types/stick_table.h	/^struct stktable {$/;"	s
stktable::current	include/types/stick_table.h	/^	unsigned int current;     \/* number of stuck session in table *\/$/;"	m	struct:stktable	access:public
stktable::exp_next	include/types/stick_table.h	/^	int exp_next;             \/* next epiration date *\/$/;"	m	struct:stktable	access:public
stktable::exp_task	include/types/stick_table.h	/^	struct task *exp_task;    \/* expiration task *\/$/;"	m	struct:stktable	typeref:struct:stktable::task	access:public
stktable::expire	include/types/stick_table.h	/^	int expire;               \/* duration before expiration of stuck session *\/$/;"	m	struct:stktable	access:public
stktable::exps	include/types/stick_table.h	/^	struct eb_root exps;      \/* head of stuck session expiration tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root	access:public
stktable::key_size	include/types/stick_table.h	/^	size_t key_size;          \/* size of a key, maximum size in case of string *\/$/;"	m	struct:stktable	access:public
stktable::keys	include/types/stick_table.h	/^	struct eb_root keys;      \/* head of stuck session tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root	access:public
stktable::nopurge	include/types/stick_table.h	/^	int nopurge;              \/* 1 never purge stuck sessions *\/$/;"	m	struct:stktable	access:public
stktable::pool	include/types/stick_table.h	/^	struct pool_head *pool;   \/* pool used to allocate stuck sessions *\/$/;"	m	struct:stktable	typeref:struct:stktable::pool_head	access:public
stktable::size	include/types/stick_table.h	/^	unsigned int size;        \/* maximum stuck session in table *\/$/;"	m	struct:stktable	access:public
stktable::type	include/types/stick_table.h	/^	unsigned long type;       \/* type of table (determine key format) *\/$/;"	m	struct:stktable	access:public
stktable_init	include/proto/stick_table.h	/^int stktable_init(struct stktable *t);$/;"	p	signature:(struct stktable *t)
stktable_init	src/stick_table.c	/^int stktable_init(struct stktable *t)$/;"	f	signature:(struct stktable *t)
stktable_key	include/types/stick_table.h	/^struct stktable_key {$/;"	s
stktable_key::data	include/types/stick_table.h	/^	union stktable_key_data data;   \/* data *\/$/;"	m	struct:stktable_key	typeref:union:stktable_key::stktable_key_data	access:public
stktable_key::key	include/types/stick_table.h	/^	void *key;                      \/* pointer on key buffer *\/$/;"	m	struct:stktable_key	access:public
stktable_key::key_len	include/types/stick_table.h	/^	size_t key_len;                 \/* data len to read in buff in case of null terminated string *\/$/;"	m	struct:stktable_key	access:public
stktable_key_data	include/types/stick_table.h	/^union stktable_key_data {$/;"	u
stktable_key_data::buf	include/types/stick_table.h	/^	char buf[BUFSIZE];        \/* used to store a null terminated string key *\/$/;"	m	union:stktable_key_data	access:public
stktable_key_data::integer	include/types/stick_table.h	/^	uint32_t integer;         \/* used to store an integer key *\/$/;"	m	union:stktable_key_data	access:public
stktable_key_data::ip	include/types/stick_table.h	/^	struct in_addr ip;        \/* used to store an ip key *\/$/;"	m	union:stktable_key_data	typeref:struct:stktable_key_data::in_addr	access:public
stktable_lookup	include/proto/stick_table.h	/^struct stksess *stktable_lookup(struct stktable *t, struct stktable_key *key);$/;"	p	signature:(struct stktable *t, struct stktable_key *key)
stktable_lookup	src/stick_table.c	/^struct stksess *stktable_lookup(struct stktable *t, struct stktable_key *key)$/;"	f	signature:(struct stktable *t, struct stktable_key *key)
stktable_parse_type	include/proto/stick_table.h	/^int stktable_parse_type(char **args, int *idx, unsigned long *type, size_t *key_size);$/;"	p	signature:(char **args, int *idx, unsigned long *type, size_t *key_size)
stktable_parse_type	src/stick_table.c	/^int stktable_parse_type(char **args, int *myidx, unsigned long *type, size_t *key_size)$/;"	f	signature:(char **args, int *myidx, unsigned long *type, size_t *key_size)
stktable_store	include/proto/stick_table.h	/^int stktable_store(struct stktable *t, struct stksess *ts, int sid);$/;"	p	signature:(struct stktable *t, struct stksess *ts, int sid)
stktable_store	src/stick_table.c	/^int stktable_store(struct stktable *t, struct stksess *tsess, int sid)$/;"	f	signature:(struct stktable *t, struct stksess *tsess, int sid)
stktable_trash_expired	src/stick_table.c	/^static int stktable_trash_expired(struct stktable *t)$/;"	f	file:	signature:(struct stktable *t)
stktable_trash_oldest	src/stick_table.c	/^static int stktable_trash_oldest(struct stktable *t, int to_batch)$/;"	f	file:	signature:(struct stktable *t, int to_batch)
stktable_type	include/types/stick_table.h	/^struct stktable_type {$/;"	s
stktable_type::default_size	include/types/stick_table.h	/^	size_t default_size;  \/* default key size *\/$/;"	m	struct:stktable_type	access:public
stktable_type::flags	include/types/stick_table.h	/^	int flags;            \/* type flags *\/$/;"	m	struct:stktable_type	access:public
stktable_type::kw	include/types/stick_table.h	/^	const char *kw;       \/* keyword string *\/$/;"	m	struct:stktable_type	access:public
stktable_types	src/stick_table.c	/^struct stktable_type stktable_types[STKTABLE_TYPES] = { { "ip", 0, 4 } ,$/;"	v	typeref:struct:stktable_type
stop	src/lb_chash.c	/^	struct eb32_node *node, *stop, *avoided_node;$/;"	l
stop	src/lb_chash.c	/^	struct eb32_node *stop = node;$/;"	l
stop_proxy	include/proto/proxy.h	/^void stop_proxy(struct proxy *p);$/;"	p	signature:(struct proxy *p)
stop_proxy	src/proxy.c	/^void stop_proxy(struct proxy *p)$/;"	f	signature:(struct proxy *p)
stop_time	include/types/proxy.h	/^	int stop_time;                          \/* date to stop listening, when stopping != 0 (int ticks) *\/$/;"	m	struct:proxy	access:public
stopping	include/types/global.h	/^extern int stopping;	\/* non zero means stopping in progress *\/$/;"	x
stopping	src/haproxy.c	/^int stopping;	\/* non zero means stopping in progress *\/$/;"	v
store	include/types/session.h	/^	} store[8];				\/* tracked stickiness values to store *\/$/;"	m	struct:session	typeref:struct:session::__anon7	access:public
store_count	include/types/session.h	/^	int store_count;$/;"	m	struct:session	access:public
storereqidx	src/session.c	/^		int storereqidx = -1;$/;"	l
storersp_rules	include/types/proxy.h	/^	struct list storersp_rules;             \/* content store response rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
str	include/types/acl.h	/^		char *str;              \/* any string  *\/$/;"	m	union:acl_pattern::__anon52	access:public
str	include/types/acl.h	/^		char *str;$/;"	m	union:acl_expr::__anon54	access:public
str	include/types/buffers.h	/^	char *str;	\/* beginning of the string itself. Might not be 0-terminated *\/$/;"	m	struct:chunk	access:public
str	include/types/pattern.h	/^	struct chunk str;  \/* used for char string type *\/$/;"	m	union:pattern_data	typeref:struct:pattern_data::chunk	access:public
str	src/dumpstats.c	/^						char str[INET6_ADDRSTRLEN], *fmt = NULL;$/;"	l
str	src/dumpstats.c	/^					char str[INET6_ADDRSTRLEN];$/;"	l
str2ic	contrib/halog/halog.c	/^int str2ic(const char *s)$/;"	f	signature:(const char *s)
str2listener	src/cfgparse.c	/^static int str2listener(char *str, struct proxy *curproxy)$/;"	f	file:	signature:(char *str, struct proxy *curproxy)
str2mask	include/common/standard.h	/^int str2mask(const char *str, struct in_addr *mask);$/;"	p	signature:(const char *str, struct in_addr *mask)
str2mask	src/standard.c	/^int str2mask(const char *str, struct in_addr *mask)$/;"	f	signature:(const char *str, struct in_addr *mask)
str2net	include/common/standard.h	/^int str2net(const char *str, struct in_addr *addr, struct in_addr *mask);$/;"	p	signature:(const char *str, struct in_addr *addr, struct in_addr *mask)
str2net	src/standard.c	/^int str2net(const char *str, struct in_addr *addr, struct in_addr *mask)$/;"	f	signature:(const char *str, struct in_addr *addr, struct in_addr *mask)
str2sa	include/common/standard.h	/^struct sockaddr_in *str2sa(char *str);$/;"	p	signature:(char *str)
str2sa	src/standard.c	/^struct sockaddr_in *str2sa(char *str)$/;"	f	signature:(char *str)
str2sa_range	include/common/standard.h	/^struct sockaddr_in *str2sa_range(char *str, int *low, int *high);$/;"	p	signature:(char *str, int *low, int *high)
str2sa_range	src/standard.c	/^struct sockaddr_in *str2sa_range(char *str, int *low, int *high)$/;"	f	signature:(char *str, int *low, int *high)
str2sun	include/common/standard.h	/^struct sockaddr_un *str2sun(const char *str);$/;"	p	signature:(const char *str)
str2sun	src/standard.c	/^struct sockaddr_un *str2sun(const char *str)$/;"	f	signature:(const char *str)
str2ui	include/common/standard.h	/^extern unsigned int str2ui(const char *s);$/;"	p	signature:(const char *s)
str2ui	src/standard.c	/^unsigned int str2ui(const char *s)$/;"	f	signature:(const char *s)
str2uic	include/common/standard.h	/^extern unsigned int str2uic(const char *s);$/;"	p	signature:(const char *s)
str2uic	src/standard.c	/^unsigned int str2uic(const char *s)$/;"	f	signature:(const char *s)
stream_int_check_timeouts	include/proto/stream_interface.h	/^int stream_int_check_timeouts(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_int_check_timeouts	src/stream_interface.c	/^int stream_int_check_timeouts(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_int_chk_rcv	include/proto/stream_interface.h	/^void stream_int_chk_rcv(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_int_chk_rcv	src/stream_interface.c	/^void stream_int_chk_rcv(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_int_chk_snd	include/proto/stream_interface.h	/^void stream_int_chk_snd(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_int_chk_snd	src/stream_interface.c	/^void stream_int_chk_snd(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_int_register_handler	include/proto/stream_interface.h	/^struct task *stream_int_register_handler(struct stream_interface *si,$/;"	p	signature:(struct stream_interface *si, void (*fct)(struct stream_interface *))
stream_int_register_handler	src/stream_interface.c	/^struct task *stream_int_register_handler(struct stream_interface *si,$/;"	f	signature:(struct stream_interface *si, void (*fct)(struct stream_interface *))
stream_int_register_handler_task	include/proto/stream_interface.h	/^struct task *stream_int_register_handler_task(struct stream_interface *si,$/;"	p	signature:(struct stream_interface *si, struct task *(*fct)(struct task *))
stream_int_register_handler_task	src/stream_interface.c	/^struct task *stream_int_register_handler_task(struct stream_interface *si,$/;"	f	signature:(struct stream_interface *si, struct task *(*fct)(struct task *))
stream_int_report_error	include/proto/stream_interface.h	/^void stream_int_report_error(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_int_report_error	src/stream_interface.c	/^void stream_int_report_error(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_int_retnclose	include/proto/stream_interface.h	/^void stream_int_retnclose(struct stream_interface *si, const struct chunk *msg);$/;"	p	signature:(struct stream_interface *si, const struct chunk *msg)
stream_int_retnclose	src/stream_interface.c	/^void stream_int_retnclose(struct stream_interface *si, const struct chunk *msg)$/;"	f	signature:(struct stream_interface *si, const struct chunk *msg)
stream_int_shutr	include/proto/stream_interface.h	/^void stream_int_shutr(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_int_shutr	src/stream_interface.c	/^void stream_int_shutr(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_int_shutw	include/proto/stream_interface.h	/^void stream_int_shutw(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_int_shutw	src/stream_interface.c	/^void stream_int_shutw(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_int_unregister_handler	include/proto/stream_interface.h	/^void stream_int_unregister_handler(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_int_unregister_handler	src/stream_interface.c	/^void stream_int_unregister_handler(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_int_update	include/proto/stream_interface.h	/^void stream_int_update(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_int_update	src/stream_interface.c	/^void stream_int_update(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_int_update_embedded	include/proto/stream_interface.h	/^void stream_int_update_embedded(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_int_update_embedded	src/stream_interface.c	/^void stream_int_update_embedded(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_interface	include/types/stream_interface.h	/^struct stream_interface {$/;"	s
stream_interface::chk_rcv	include/types/stream_interface.h	/^	void (*chk_rcv)(struct stream_interface *);\/* chk_rcv function *\/$/;"	m	struct:stream_interface	access:public
stream_interface::chk_snd	include/types/stream_interface.h	/^	void (*chk_snd)(struct stream_interface *);\/* chk_snd function *\/$/;"	m	struct:stream_interface	access:public
stream_interface::connect	include/types/stream_interface.h	/^	int (*connect)(struct stream_interface *, struct proxy *, struct server *,$/;"	m	struct:stream_interface	access:public
stream_interface::err_loc	include/types/stream_interface.h	/^	void *err_loc;          \/* commonly the server, NULL when SI_ET_NONE *\/$/;"	m	struct:stream_interface	access:public
stream_interface::err_type	include/types/stream_interface.h	/^	unsigned int err_type;  \/* first error detected, one of SI_ET_* *\/$/;"	m	struct:stream_interface	access:public
stream_interface::exp	include/types/stream_interface.h	/^	unsigned int exp;       \/* wake up time for connect, queue, turn-around, ... *\/$/;"	m	struct:stream_interface	access:public
stream_interface::fd	include/types/stream_interface.h	/^	int fd;                 \/* file descriptor for a stream driver when known *\/$/;"	m	struct:stream_interface	access:public
stream_interface::flags	include/types/stream_interface.h	/^	unsigned int flags;$/;"	m	struct:stream_interface	access:public
stream_interface::ib	include/types/stream_interface.h	/^	struct buffer *ib, *ob; \/* input and output buffers *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::buffer	access:public
stream_interface::iohandler	include/types/stream_interface.h	/^	void (*iohandler)(struct stream_interface *);  \/* internal I\/O handler when embedded *\/$/;"	m	struct:stream_interface	access:public
stream_interface::ob	include/types/stream_interface.h	/^	struct buffer *ib, *ob; \/* input and output buffers *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::	access:public
stream_interface::owner	include/types/stream_interface.h	/^	void *owner;            \/* generally a (struct task*) *\/$/;"	m	struct:stream_interface	access:public
stream_interface::prev_state	include/types/stream_interface.h	/^	unsigned int prev_state;\/* SI_ST*, copy of previous state *\/$/;"	m	struct:stream_interface	access:public
stream_interface::shutr	include/types/stream_interface.h	/^	void (*shutr)(struct stream_interface *);  \/* shutr function *\/$/;"	m	struct:stream_interface	access:public
stream_interface::shutw	include/types/stream_interface.h	/^	void (*shutw)(struct stream_interface *);  \/* shutw function *\/$/;"	m	struct:stream_interface	access:public
stream_interface::st0	include/types/stream_interface.h	/^	unsigned int st0, st1;  \/* may be used by any function above *\/$/;"	m	struct:stream_interface	access:private
stream_interface::st1	include/types/stream_interface.h	/^	unsigned int st0, st1;  \/* may be used by any function above *\/$/;"	m	struct:stream_interface	access:private
stream_interface::state	include/types/stream_interface.h	/^	unsigned int state;     \/* SI_ST* *\/$/;"	m	struct:stream_interface	access:public
stream_interface::update	include/types/stream_interface.h	/^	void (*update)(struct stream_interface *); \/* I\/O update function *\/$/;"	m	struct:stream_interface	access:public
stream_sock_chk_rcv	include/proto/stream_sock.h	/^void stream_sock_chk_rcv(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_sock_chk_rcv	src/stream_sock.c	/^void stream_sock_chk_rcv(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_sock_chk_snd	include/proto/stream_sock.h	/^void stream_sock_chk_snd(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_sock_chk_snd	src/stream_sock.c	/^void stream_sock_chk_snd(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_sock_data_finish	include/proto/stream_sock.h	/^void stream_sock_data_finish(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_sock_data_finish	src/stream_sock.c	/^void stream_sock_data_finish(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_sock_read	include/proto/stream_sock.h	/^int stream_sock_read(int fd);$/;"	p	signature:(int fd)
stream_sock_read	src/stream_sock.c	/^int stream_sock_read(int fd) {$/;"	f	signature:(int fd)
stream_sock_shutr	include/proto/stream_sock.h	/^void stream_sock_shutr(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_sock_shutr	src/stream_sock.c	/^void stream_sock_shutr(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_sock_shutw	include/proto/stream_sock.h	/^void stream_sock_shutw(struct stream_interface *si);$/;"	p	signature:(struct stream_interface *si)
stream_sock_shutw	src/stream_sock.c	/^void stream_sock_shutw(struct stream_interface *si)$/;"	f	signature:(struct stream_interface *si)
stream_sock_splice_in	src/stream_sock.c	/^static int stream_sock_splice_in(struct buffer *b, struct stream_interface *si)$/;"	f	file:	signature:(struct buffer *b, struct stream_interface *si)
stream_sock_write	include/proto/stream_sock.h	/^int stream_sock_write(int fd);$/;"	p	signature:(int fd)
stream_sock_write	src/stream_sock.c	/^int stream_sock_write(int fd)$/;"	f	signature:(int fd)
stream_sock_write_loop	src/stream_sock.c	/^static int stream_sock_write_loop(struct stream_interface *si, struct buffer *b)$/;"	f	file:	signature:(struct stream_interface *si, struct buffer *b)
string_equal_bits	ebtree/ebtree.h	/^static forceinline int string_equal_bits(const unsigned char *a,$/;"	f	signature:(const unsigned char *a, const unsigned char *b, int ignore)
stripped_after	src/proto_http.c	/^				int stripped_after = 0;$/;"	l
stripped_before	src/proto_http.c	/^				int stripped_before = 0;$/;"	l
strl2ic	include/common/standard.h	/^extern int strl2ic(const char *s, int len);$/;"	p	signature:(const char *s, int len)
strl2ic	src/standard.c	/^int strl2ic(const char *s, int len)$/;"	f	signature:(const char *s, int len)
strl2irc	include/common/standard.h	/^extern int strl2irc(const char *s, int len, int *ret);$/;"	p	signature:(const char *s, int len, int *ret)
strl2irc	src/standard.c	/^int strl2irc(const char *s, int len, int *ret)$/;"	f	signature:(const char *s, int len, int *ret)
strl2llrc	include/common/standard.h	/^extern int strl2llrc(const char *s, int len, long long *ret);$/;"	p	signature:(const char *s, int len, long long *ret)
strl2llrc	src/standard.c	/^int strl2llrc(const char *s, int len, long long *ret)$/;"	f	signature:(const char *s, int len, long long *ret)
strl2ui	contrib/halog/halog.c	/^unsigned int strl2ui(const char *s, int len)$/;"	f	signature:(const char *s, int len)
strl2ui	include/common/standard.h	/^extern unsigned int strl2ui(const char *s, int len);$/;"	p	signature:(const char *s, int len)
strl2ui	src/standard.c	/^unsigned int strl2ui(const char *s, int len)$/;"	f	signature:(const char *s, int len)
strl2uic	include/common/standard.h	/^extern unsigned int strl2uic(const char *s, int len);$/;"	p	signature:(const char *s, int len)
strl2uic	src/standard.c	/^unsigned int strl2uic(const char *s, int len)$/;"	f	signature:(const char *s, int len)
strlcpy2	include/common/standard.h	/^extern int strlcpy2(char *dst, const char *src, int size);$/;"	p	signature:(char *dst, const char *src, int size)
strlcpy2	src/standard.c	/^int strlcpy2(char *dst, const char *src, int size)$/;"	f	signature:(char *dst, const char *src, int size)
strsz	src/standard.c	/^	int strsz;	\/* length included null *\/$/;"	l
su	src/dumpstats.c	/^		struct sockaddr_un su;$/;"	l
su	src/standard.c	/^	static struct sockaddr_un su;$/;"	l	file:
suite	src/acl.c	/^	struct acl_term_suite *suite, *tmp_suite;$/;"	l
suite	src/acl.c	/^	struct acl_term_suite *suite;$/;"	l
suite_res	src/acl.c	/^	int acl_res, suite_res, cond_res;$/;"	l
suites	include/types/acl.h	/^	struct list suites;         \/* list of acl_term_suites *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list	access:public
sv	include/types/session.h	/^			struct server *sv;$/;"	m	struct:session::__anon9::__anon10	typeref:struct:session::__anon9::__anon10::server	access:public
sv	src/dumpstats.c	/^			struct server *sv;$/;"	l
sv	src/dumpstats.c	/^	struct server *sv, *svs;	\/* server and server-state, server-state=server or server->tracked *\/$/;"	l
sv	src/proto_http.c	/^	struct server *sv;$/;"	l
sv_st	include/types/session.h	/^			short px_st, sv_st;	\/* DATA_ST_INIT or DATA_ST_DATA *\/$/;"	m	struct:session::__anon9::__anon10	access:public
sv_state	src/checks.c	/^	int sv_state;$/;"	l
sv_state	src/dumpstats.c	/^			int sv_state; \/* 0=DOWN, 1=going up, 2=going down, 3=UP, 4,5=NOLB, 6=unchecked *\/$/;"	l
svid	src/log.c	/^	char *svid;$/;"	l
svid	src/proto_http.c	/^	char *svid;$/;"	l
svs	src/dumpstats.c	/^	struct server *sv, *svs;	\/* server and server-state, server-state=server or server->tracked *\/$/;"	l
sw	src/ev_poll.c	/^	int sr, sw;$/;"	l
sw	tests/filltab25.c	/^int nsw, sw;    \/* sum of weights *\/$/;"	v
swap	src/lb_fwrr.c	/^	struct eb_root *swap;$/;"	l
swap	tests/filltab25.c	/^	struct eb_root *swap;$/;"	l
swap_buffer	include/types/global.h	/^extern char *swap_buffer;$/;"	x
swap_buffer	src/haproxy.c	/^char *swap_buffer = NULL;$/;"	v
switch_trees	tests/filltab25.c	/^void switch_trees() {$/;"	f
switched	src/lb_fwrr.c	/^	int switched;$/;"	l
switching_rule	include/types/proxy.h	/^struct switching_rule {$/;"	s
switching_rule::__anon21::backend	include/types/proxy.h	/^		struct proxy *backend;		\/* target backend *\/$/;"	m	union:switching_rule::__anon21	typeref:struct:switching_rule::__anon21::proxy	access:public
switching_rule::__anon21::name	include/types/proxy.h	/^		char *name;			\/* target backend name during config parsing *\/$/;"	m	union:switching_rule::__anon21	access:public
switching_rule::be	include/types/proxy.h	/^	} be;$/;"	m	struct:switching_rule	typeref:union:switching_rule::__anon21	access:public
switching_rule::cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::acl_cond	access:public
switching_rule::list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::list	access:public
switching_rules	include/types/proxy.h	/^	struct list switching_rules;            \/* content switching rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list	access:public
t	contrib/halog/halog.c	/^	struct timer *t = *alloc;$/;"	l
t	contrib/halog/halog.c	/^	struct timer *t = NULL, *t2;$/;"	l
t	ebtree/ebtree.h	/^	eb_troot_t *t = node->leaf_p;$/;"	l
t	include/proto/task.h	/^	struct task *t = pool_alloc2(pool2_task);$/;"	l
t	include/types/proxy.h	/^		struct stktable *t;	        \/* target table *\/$/;"	m	union:sticking_rule::__anon22	typeref:struct:sticking_rule::__anon22::stktable	access:public
t	src/base64.c	/^	unsigned char t[4];$/;"	l
t	src/checks.c	/^	struct task *t = fdtab[fd].owner;$/;"	l
t	src/checks.c	/^	struct task *t;$/;"	l
t	src/client.c	/^	struct task *t;$/;"	l
t	src/lb_map.c	/^				int t = pgcd % w;$/;"	l
t	src/proto_uxst.c	/^	struct task *t;$/;"	l
t	src/proxy.c	/^				int t;$/;"	l
t	src/stick_table.c	/^	struct stktable *t = (struct stktable *)task->context;$/;"	l
t	src/stream_interface.c	/^	struct task *t;$/;"	l
t	src/task.c	/^	struct task *t;$/;"	l
t0	include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root	access:public
t1	include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::	access:public
t2	contrib/halog/halog.c	/^	struct timer *t = NULL, *t2;$/;"	l
t_close	include/types/session.h	/^		unsigned long t_close;		\/* total session duration *\/$/;"	m	struct:session::__anon8	access:public
t_con	src/checks.c	/^							int t_con = tick_add(now_ms, s->proxy->timeout.connect);$/;"	l
t_con	src/checks.c	/^			int t_con;$/;"	l
t_connect	include/types/session.h	/^		long  t_connect;		\/* delay before the connect() to the server succeeds, -1 if never occurs *\/$/;"	m	struct:session::__anon8	access:public
t_data	include/types/session.h	/^		long  t_data;			\/* delay before the first data byte from the server ... *\/$/;"	m	struct:session::__anon8	access:public
t_queue	include/types/session.h	/^		long  t_queue;			\/* delay before the session gets out of the connect queue, -1 if never occurs *\/$/;"	m	struct:session::__anon8	access:public
t_request	src/proto_http.c	/^	int t_request;$/;"	l
table	include/common/sessionhash.h	/^	struct list *table;$/;"	m	struct:appsession_hash	typeref:struct:appsession_hash::list	access:public
table	include/types/proxy.h	/^	struct stktable table;			\/* table for storing sticking sessions *\/$/;"	m	struct:proxy	typeref:struct:proxy::stktable	access:public
table	include/types/proxy.h	/^	} table;$/;"	m	struct:sticking_rule	typeref:union:sticking_rule::__anon22	access:public
table	include/types/session.h	/^		struct stktable *table;$/;"	m	struct:session::__anon7	typeref:struct:session::__anon7::stktable	access:public
tail	include/types/hdr_idx.h	/^	signed short tail;          \/* last used element, 0..size-1 *\/$/;"	m	struct:hdr_idx	access:public
target	include/types/session.h	/^			void *target;		\/* session we want to dump, or NULL for all *\/$/;"	m	struct:session::__anon9::__anon11	access:public
target	src/cfgparse.c	/^					struct server *target = container_of(node, struct server, conf.id);$/;"	l
target	src/cfgparse.c	/^				struct proxy *target;$/;"	l
target	src/cfgparse.c	/^			struct proxy *target = container_of(node, struct proxy, conf.id);$/;"	l
target	src/cfgparse.c	/^			struct proxy *target;$/;"	l
target	src/proxy.c	/^	struct proxy *curproxy, *target = NULL;$/;"	l
target	src/proxy.c	/^	struct server *cursrv, *target = NULL;$/;"	l
tarpit	include/types/proxy.h	/^		int tarpit;                     \/* tarpit timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon19	access:public
task	include/types/session.h	/^	struct task *task;			\/* the task associated with this session *\/$/;"	m	struct:session	typeref:struct:session::task	access:public
task	include/types/task.h	/^struct task {$/;"	s
task	src/task.c	/^	struct task *task;$/;"	l
task::calls	include/types/task.h	/^	unsigned int calls;		\/* number of times ->process() was called *\/$/;"	m	struct:task	access:public
task::context	include/types/task.h	/^	void *context;			\/* the task's context *\/$/;"	m	struct:task	access:public
task::expire	include/types/task.h	/^	int expire;			\/* next expiration date for this task, in ticks *\/$/;"	m	struct:task	access:public
task::nice	include/types/task.h	/^	int nice;			\/* the task's current nice value from -1024 to +1024 *\/$/;"	m	struct:task	access:public
task::process	include/types/task.h	/^	struct task * (*process)(struct task *t);  \/* the function which processes the task *\/$/;"	m	struct:task	typeref:struct:task::process	access:public
task::rq	include/types/task.h	/^	struct eb32_node rq;		\/* ebtree node used to hold the task in the run queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node	access:public
task::state	include/types/task.h	/^	int state;			\/* task state : bit field of TASK_* *\/$/;"	m	struct:task	access:public
task::wq	include/types/task.h	/^	struct eb32_node wq;		\/* ebtree node used to hold the task in the wait queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node	access:public
task_delete	include/proto/task.h	/^static inline struct task *task_delete(struct task *t)$/;"	f	signature:(struct task *t)
task_free	include/proto/task.h	/^static inline void task_free(struct task *t)$/;"	f	signature:(struct task *t)
task_in_rq	include/proto/task.h	/^static inline int task_in_rq(struct task *t)$/;"	f	signature:(struct task *t)
task_in_wq	include/proto/task.h	/^static inline int task_in_wq(struct task *t)$/;"	f	signature:(struct task *t)
task_init	include/proto/task.h	/^static inline struct task *task_init(struct task *t)$/;"	f	signature:(struct task *t)
task_new	include/proto/task.h	/^static inline struct task *task_new(void)$/;"	f	signature:(void)
task_queue	include/proto/task.h	/^static inline void task_queue(struct task *task)$/;"	f	signature:(struct task *task)
task_unlink_rq	include/proto/task.h	/^static inline struct task *task_unlink_rq(struct task *t)$/;"	f	signature:(struct task *t)
task_unlink_wq	include/proto/task.h	/^static inline struct task *task_unlink_wq(struct task *t)$/;"	f	signature:(struct task *t)
task_wakeup	include/proto/task.h	/^static inline struct task *task_wakeup(struct task *t, unsigned int f)$/;"	f	signature:(struct task *t, unsigned int f)
tau	src/auth.c	/^	struct auth_users *au, *tau;$/;"	l
tcp_bind_listener	include/proto/proto_tcp.h	/^int tcp_bind_listener(struct listener *listener, char *errmsg, int errlen);$/;"	p	signature:(struct listener *listener, char *errmsg, int errlen)
tcp_bind_listener	src/proto_tcp.c	/^int tcp_bind_listener(struct listener *listener, char *errmsg, int errlen)$/;"	f	signature:(struct listener *listener, char *errmsg, int errlen)
tcp_bind_listeners	src/proto_tcp.c	/^static int tcp_bind_listeners(struct protocol *proto)$/;"	f	file:	signature:(struct protocol *proto)
tcp_bind_listeners	src/proto_tcp.c	/^static int tcp_bind_listeners(struct protocol *proto);$/;"	p	file:	signature:(struct protocol *proto)
tcp_close_return	src/proto_tcp.c	/^	__label__ tcp_return, tcp_close_return;$/;"	l
tcp_event_accept	include/proto/proto_tcp.h	/^int tcp_event_accept(int fd);$/;"	p	signature:(int fd)
tcp_inspect_request	include/proto/proto_tcp.h	/^int tcp_inspect_request(struct session *s, struct buffer *req, int an_bit);$/;"	p	signature:(struct session *s, struct buffer *req, int an_bit)
tcp_inspect_request	src/proto_tcp.c	/^int tcp_inspect_request(struct session *s, struct buffer *req, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit)
tcp_parse_tcp_req	src/proto_tcp.c	/^static int tcp_parse_tcp_req(char **args, int section_type, struct proxy *curpx,$/;"	f	file:	signature:(char **args, int section_type, struct proxy *curpx, struct proxy *defpx, char *err, int errlen)
tcp_persist_rdp_cookie	include/proto/proto_tcp.h	/^int tcp_persist_rdp_cookie(struct session *s, struct buffer *req, int an_bit);$/;"	p	signature:(struct session *s, struct buffer *req, int an_bit)
tcp_persist_rdp_cookie	src/proto_tcp.c	/^int tcp_persist_rdp_cookie(struct session *s, struct buffer *req, int an_bit)$/;"	f	signature:(struct session *s, struct buffer *req, int an_bit)
tcp_req	include/types/proxy.h	/^	} tcp_req;$/;"	m	struct:proxy	typeref:struct:proxy::__anon18	access:public
tcp_return	src/proto_tcp.c	/^	__label__ tcp_return, tcp_close_return;$/;"	l
tcp_rule	include/types/proto_tcp.h	/^struct tcp_rule {$/;"	s
tcp_rule::action	include/types/proto_tcp.h	/^	int action;$/;"	m	struct:tcp_rule	access:public
tcp_rule::cond	include/types/proto_tcp.h	/^	struct acl_cond *cond;$/;"	m	struct:tcp_rule	typeref:struct:tcp_rule::acl_cond	access:public
tcp_rule::list	include/types/proto_tcp.h	/^	struct list list;$/;"	m	struct:tcp_rule	typeref:struct:tcp_rule::list	access:public
tcp_sess_log	include/proto/log.h	/^void tcp_sess_log(struct session *s);$/;"	p	signature:(struct session *s)
tcp_sess_log	src/log.c	/^void tcp_sess_log(struct session *s)$/;"	f	signature:(struct session *s)
tcpv4_add_listener	include/proto/proto_tcp.h	/^void tcpv4_add_listener(struct listener *listener);$/;"	p	signature:(struct listener *listener)
tcpv4_add_listener	src/proto_tcp.c	/^void tcpv4_add_listener(struct listener *listener)$/;"	f	signature:(struct listener *listener)
tcpv4_bind_socket	include/proto/proto_tcp.h	/^int tcpv4_bind_socket(int fd, int flags, struct sockaddr_in *local, struct sockaddr_in *remote);$/;"	p	signature:(int fd, int flags, struct sockaddr_in *local, struct sockaddr_in *remote)
tcpv4_bind_socket	src/proto_tcp.c	/^int tcpv4_bind_socket(int fd, int flags, struct sockaddr_in *local, struct sockaddr_in *remote)$/;"	f	signature:(int fd, int flags, struct sockaddr_in *local, struct sockaddr_in *remote)
tcpv4_connect_server	include/proto/proto_tcp.h	/^int tcpv4_connect_server(struct stream_interface *si,$/;"	p	signature:(struct stream_interface *si, struct proxy *be, struct server *srv, struct sockaddr *srv_addr, struct sockaddr *from_addr)
tcpv4_connect_server	src/proto_tcp.c	/^int tcpv4_connect_server(struct stream_interface *si,$/;"	f	signature:(struct stream_interface *si, struct proxy *be, struct server *srv, struct sockaddr *srv_addr, struct sockaddr *from_addr)
tcpv6_add_listener	include/proto/proto_tcp.h	/^void tcpv6_add_listener(struct listener *listener);$/;"	p	signature:(struct listener *listener)
tcpv6_add_listener	src/proto_tcp.c	/^void tcpv6_add_listener(struct listener *listener)$/;"	f	signature:(struct listener *listener)
td	src/proxy.c	/^	int *td = NULL;$/;"	l
td	src/proxy.c	/^	unsigned int *td = NULL;$/;"	l
tell_old_pids	src/haproxy.c	/^static int tell_old_pids(int sig)$/;"	f	file:	signature:(int sig)
temp	include/common/memory.h	/^	void *temp, *next;$/;"	l
temp	src/memory.c	/^		void *temp, *next;$/;"	l
temp	src/memory.c	/^	void *temp, *next;$/;"	l
temp	tests/test_pools.c	/^	void *temp, *next;$/;"	l
temp1	src/appsession.c	/^    appsess *temp1,*temp2;$/;"	l
temp2	src/appsession.c	/^    appsess *temp1,*temp2;$/;"	l
tempname	src/proto_uxst.c	/^	char tempname[MAXPATHLEN];$/;"	l
term	include/types/fd.h	/^	void REGPRM1   (*term)(struct poller *p);            \/* termination of this poller *\/$/;"	m	struct:poller	access:private
term	src/acl.c	/^	struct acl_term *term, *tmp_term;$/;"	l
term	src/acl.c	/^	struct acl_term *term;$/;"	l
term	src/fd.c	/^			bp->term(bp);$/;"	p	file:
term	src/proto_http.c	/^	char term;$/;"	l
term_trace	include/types/session.h	/^	unsigned term_trace;			\/* term trace: 4*8 bits indicating which part of the code closed *\/$/;"	m	struct:session	access:public
terms	include/types/acl.h	/^	struct list terms;          \/* list of acl_terms *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list	access:public
test	contrib/halog/halog.c	/^	int val, test;$/;"	l
test	include/types/fd.h	/^	int  REGPRM1   (*test)(struct poller *p);            \/* pre-init check of the poller *\/$/;"	m	struct:poller	access:private
test	src/acl.c	/^	struct acl_test test;$/;"	l
test	src/backend.c	/^	struct acl_test  test;$/;"	l
test	src/proto_tcp.c	/^	struct acl_test  test;$/;"	l
test_speed1	tests/test_pools.c	/^static bool test_speed1(void)$/;"	f	file:	signature:(void)
text	src/proto_http.c	/^	const char text[8];$/;"	m	struct:http_method_desc	file:	access:public
thisline	src/cfgparse.c	/^	char thisline[LINESIZE];$/;"	l
thres	contrib/halog/halog.c	/^			unsigned int thres = tot * (step \/ 1000.0);$/;"	l
tick_add	include/common/ticks.h	/^static inline int tick_add(int now, int timeout)$/;"	f	signature:(int now, int timeout)
tick_add_ifset	include/common/ticks.h	/^static inline int tick_add_ifset(int now, int timeout)$/;"	f	signature:(int now, int timeout)
tick_first	include/common/ticks.h	/^static inline int tick_first(int t1, int t2)$/;"	f	signature:(int t1, int t2)
tick_first_2nz	include/common/ticks.h	/^static inline int tick_first_2nz(int t1, int t2)$/;"	f	signature:(int t1, int t2)
tick_is_expired	include/common/ticks.h	/^static inline int tick_is_expired(int timer, int now)$/;"	f	signature:(int timer, int now)
tick_is_le	include/common/ticks.h	/^static inline int tick_is_le(int t1, int t2)$/;"	f	signature:(int t1, int t2)
tick_is_lt	include/common/ticks.h	/^static inline int tick_is_lt(int t1, int t2)$/;"	f	signature:(int t1, int t2)
tick_isset	include/common/ticks.h	/^static inline int tick_isset(int expire)$/;"	f	signature:(int expire)
tick_remain	include/common/ticks.h	/^static inline int tick_remain(int now, int exp)$/;"	f	signature:(int now, int exp)
time	include/types/acl.h	/^		struct acl_time time;           \/* valid hours and days *\/$/;"	m	union:acl_pattern::__anon49	typeref:struct:acl_pattern::__anon49::acl_time	access:public
timeout	include/types/protocols.h	/^	int  *timeout;                  \/* pointer to client-side timeout *\/$/;"	m	struct:listener	access:public
timeout	include/types/proxy.h	/^	} timeout;$/;"	m	struct:proxy	typeref:struct:proxy::__anon19	access:public
timeout	src/dumpstats.c	/^				unsigned timeout;$/;"	l
timeout	src/dumpstats.c	/^		unsigned timeout;$/;"	l
timeout	src/ev_kqueue.c	/^	struct timespec timeout;$/;"	l
timeout	src/proxy.c	/^	unsigned timeout;$/;"	l
timer	contrib/halog/halog.c	/^struct timer {$/;"	s	file:
timer::count	contrib/halog/halog.c	/^	unsigned int count;$/;"	m	struct:timer	file:	access:public
timer::node	contrib/halog/halog.c	/^	struct eb32_node node;$/;"	m	struct:timer	typeref:struct:timer::eb32_node	file:	access:public
timers	contrib/halog/halog.c	/^static struct eb_root timers[5] = {$/;"	v	typeref:struct:eb_root	file:
timers	src/task.c	/^static struct eb_root timers;      \/* sorted timers tree *\/$/;"	v	typeref:struct:eb_root	file:
timeval_current	tests/test_hashes.c	/^static struct timeval timeval_current(void)$/;"	f	file:	signature:(void)
timeval_current	tests/test_pools.c	/^static struct timeval timeval_current(void)$/;"	f	file:	signature:(void)
timeval_elapsed	tests/test_hashes.c	/^static double timeval_elapsed(struct timeval *tv)$/;"	f	file:	signature:(struct timeval *tv)
timeval_elapsed	tests/test_pools.c	/^static double timeval_elapsed(struct timeval *tv)$/;"	f	file:	signature:(struct timeval *tv)
tm	src/dumpstats.c	/^			struct tm tm;$/;"	l
tm	src/dumpstats.c	/^	struct tm tm;$/;"	l
tm	src/log.c	/^		struct tm tm;$/;"	l
tm	src/log.c	/^	struct tm tm;$/;"	l
tm	src/proto_http.c	/^	struct tm tm;$/;"	l
tmp	src/acl.c	/^	struct acl_pattern *pat, *tmp;$/;"	l
tmp	src/haproxy.c	/^	char *tmp;$/;"	l
tmp	src/pattern.c	/^	u_char tmp[4], *tp;$/;"	l
tmp	src/proto_http.c	/^		int tmp = TX_CON_WANT_TUN;$/;"	l
tmp	src/proto_http.c	/^	char *tmp;$/;"	l
tmp	src/rbtree.c	/^				register struct rb_node *tmp;$/;"	l
tmp	src/standard.c	/^	u_char tmp[4], *tp;$/;"	l
tmp	tests/sessionhash_test.c	/^	appsess *a, *b, *c, *d, *tmp;$/;"	l
tmp	tests/test_hashes.c	/^    int tmp;$/;"	l
tmp	tests/test_hashes.c	/^uint32_t hash = len, tmp;$/;"	l
tmp	tests/uri_hash.c	/^uint32_t hash = len, tmp;$/;"	l
tmp_evts	src/ev_select.c	/^static fd_set *tmp_evts[2];$/;"	v	file:
tmp_suite	src/acl.c	/^	struct acl_term_suite *suite, *tmp_suite;$/;"	l
tmp_term	src/acl.c	/^	struct acl_term *term, *tmp_term;$/;"	l
tmpline	src/proto_http.c	/^	static char tmpline[MAX_SYSLOG_LEN];$/;"	l	file:
to	src/buffers.c	/^	char *from, *to;$/;"	l
to_del	src/proto_http.c	/^			int to_del = 0;$/;"	l
to_del	src/proto_http.c	/^		int to_del = 0;$/;"	l
to_forward	include/types/buffers.h	/^	unsigned long to_forward;       \/* number of bytes to forward after send_max without a wake-up *\/$/;"	m	struct:buffer	access:public
to_log	include/types/proxy.h	/^	int to_log;				\/* things to be logged (LW_*) *\/$/;"	m	struct:proxy	access:public
to_move	src/buffers.c	/^	int advance, to_move;$/;"	l
tolog	src/log.c	/^	int tolog, level, err;$/;"	l
tolog	src/proto_http.c	/^	int tolog, level, err;$/;"	l
torture_assert	tests/test_pools.c	31;"	d	file:
torture_assert_str_equal	tests/test_pools.c	37;"	d	file:
tot	contrib/halog/halog.c	/^	int f, tot, last, linenum, err, parse_err;$/;"	l
tot	src/lb_map.c	/^	int o, tot, flag;$/;"	l
tot_rq	contrib/halog/halog.c	/^			int tot_rq;$/;"	l
tot_used	include/types/backend.h	/^	int tot_used;			\/* total number of servers used for LB *\/$/;"	m	struct:lbprm	access:public
tot_wact	include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm	access:public
tot_wbck	include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm	access:public
tot_weight	include/types/backend.h	/^	int tot_weight;			\/* total effective weight of servers participating to LB *\/$/;"	m	struct:lbprm	access:public
total	include/types/buffers.h	/^	unsigned long long total;       \/* total data read *\/$/;"	m	struct:buffer	access:public
total_err	tests/ip-hash.c	/^	double err, total_err, max_err;$/;"	l
total_time	contrib/halog/halog.c	/^	unsigned long long total_time;    \/* sum(all reqs' times) *\/$/;"	m	struct:url_stat	file:	access:public
total_time_ok	contrib/halog/halog.c	/^	unsigned long long total_time_ok; \/* sum(all OK reqs' times) *\/$/;"	m	struct:url_stat	file:	access:public
totalconn	include/types/fd.h	/^extern int totalconn;                   \/* total # of terminated sessions *\/$/;"	x
totalconn	src/fd.c	/^int totalconn;                  \/* total # of terminated sessions *\/$/;"	v
totpend	include/types/proxy.h	/^	int totpend;				\/* total number of pending connections on this instance (for stats) *\/$/;"	m	struct:proxy	access:public
tp	src/pattern.c	/^	u_char tmp[4], *tp;$/;"	l
tp	src/standard.c	/^	u_char tmp[4], *tp;$/;"	l
tproxy_addr	include/types/proxy.h	/^	struct sockaddr_in tproxy_addr;		\/* non-local address we want to bind to for connect() *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_in	access:public
tproxy_addr	include/types/server.h	/^	struct sockaddr_in tproxy_addr;		\/* non-local address we want to bind to for connect() *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_in	access:public
tps	contrib/halog/halog.c	/^			int tps;$/;"	l
tr	src/auth.c	/^	struct req_acl_rule *tr, *pr;$/;"	l
trace_term	include/proto/session.h	/^static void inline trace_term(struct session *s, unsigned int code)$/;"	f	signature:(struct session *s, unsigned int code)
tracked	include/types/server.h	/^	struct server *tracknext, *tracked;	\/* next server in a tracking list, tracked server *\/$/;"	m	struct:server	typeref:struct:server::	access:public
trackit	include/types/server.h	/^	char *trackit;				\/* temporary variable to make assignment deferrable *\/$/;"	m	struct:server	access:public
tracknext	include/types/server.h	/^	struct server *tracknext, *tracked;	\/* next server in a tracking list, tracked server *\/$/;"	m	struct:server	typeref:struct:server::server	access:public
trash	include/types/global.h	/^extern char trash[BUFSIZE];$/;"	x
trash	src/haproxy.c	/^char trash[BUFSIZE];$/;"	v
trash	src/pattern.c	/^	struct chunk *trash = get_trash_chunk();$/;"	l
trash_chunk	src/pattern.c	/^static struct chunk trash_chunk;$/;"	v	typeref:struct:chunk	file:
tree	include/types/acl.h	/^		struct eb_root *tree;           \/* tree storing all values if any *\/$/;"	m	union:acl_pattern::__anon49	typeref:struct:acl_pattern::__anon49::eb_root	access:public
tree	src/acl.c	/^	struct eb_root *tree = NULL;$/;"	l
tree	tests/filltab25.c	/^	struct eb_root *tree; \/\/ we want to know where the server is$/;"	m	struct:srv	typeref:struct:srv::eb_root	file:	access:public
tree_0	tests/filltab25.c	/^struct eb_root tree_0 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_1	tests/filltab25.c	/^struct eb_root tree_1 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_2	tests/filltab25.c	/^struct eb_root tree_2 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_occ	include/types/server.h	/^struct tree_occ {$/;"	s
tree_occ::node	include/types/server.h	/^	struct eb32_node node;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::eb32_node	access:public
tree_occ::server	include/types/server.h	/^	struct server *server;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::server	access:public
troot	ebtree/eb32tree.c	/^	eb_troot_t *troot;$/;"	l
troot	ebtree/eb32tree.h	/^	eb_troot_t *troot, **up_ptr;$/;"	l
troot	ebtree/eb32tree.h	/^	eb_troot_t *troot;$/;"	l
troot	ebtree/eb64tree.c	/^	eb_troot_t *troot;$/;"	l
troot	ebtree/eb64tree.h	/^	eb_troot_t *troot;$/;"	l
troot	ebtree/ebimtree.h	/^	eb_troot_t *troot;$/;"	l
troot	ebtree/ebistree.h	/^	eb_troot_t *troot;$/;"	l
troot	ebtree/ebmbtree.h	/^	eb_troot_t *troot, **up_ptr;$/;"	l
troot	ebtree/ebmbtree.h	/^	eb_troot_t *troot, *cover;$/;"	l
troot	ebtree/ebmbtree.h	/^	eb_troot_t *troot;$/;"	l
troot	ebtree/ebpttree.c	/^	eb_troot_t *troot;$/;"	l
troot	ebtree/ebsttree.h	/^	eb_troot_t *troot;$/;"	l
truncated_line	contrib/halog/halog.c	/^void truncated_line(int linenum, const char *line)$/;"	f	signature:(int linenum, const char *line)
ts	include/types/session.h	/^		struct stksess *ts;$/;"	m	struct:session::__anon7	typeref:struct:session::__anon7::stksess	access:public
ts	src/session.c	/^					struct stksess *ts;$/;"	l
ts	src/session.c	/^				struct stksess *ts;$/;"	l
ts	src/stick_table.c	/^	struct stksess *ts;$/;"	l
tul	src/auth.c	/^	struct userlist *tul;$/;"	l
tune	include/types/global.h	/^	} tune;$/;"	m	struct:global	typeref:struct:global::__anon16	access:public
tv	src/proxy.c	/^	int *tv = NULL;$/;"	l
tv	src/proxy.c	/^	unsigned int *tv = NULL;$/;"	l
tv	tests/test_hashes.c	/^	struct timeval tv;$/;"	l
tv	tests/test_pools.c	/^	struct timeval tv;$/;"	l
tv2	tests/test_hashes.c	/^	struct timeval tv2 = timeval_current();$/;"	l
tv2	tests/test_pools.c	/^	struct timeval tv2 = timeval_current();$/;"	l
tv_accept	include/types/session.h	/^		struct timeval tv_accept;	\/* date of the accept() in internal date (monotonic) *\/$/;"	m	struct:session::__anon8	typeref:struct:session::__anon8::timeval	access:public
tv_add	include/common/time.h	372;"	d
tv_add_ifset	include/common/time.h	390;"	d
tv_bound	include/common/time.h	511;"	d
tv_eternity	include/common/time.h	/^REGPRM1 static inline struct timeval *tv_eternity(struct timeval *tv)$/;"	f	signature:(struct timeval *tv)
tv_isbefore	include/common/time.h	485;"	d
tv_iseq	include/common/time.h	194;"	d
tv_iseternity	include/common/time.h	128;"	d
tv_isge	include/common/time.h	213;"	d
tv_isgt	include/common/time.h	202;"	d
tv_isle	include/common/time.h	233;"	d
tv_islt	include/common/time.h	223;"	d
tv_isset	include/common/time.h	133;"	d
tv_iszero	include/common/time.h	138;"	d
tv_min	include/common/time.h	496;"	d
tv_ms_add	include/common/time.h	/^REGPRM3 struct timeval *tv_ms_add(struct timeval *tv, const struct timeval *from, int ms);$/;"	p	signature:(struct timeval *tv, const struct timeval *from, int ms)
tv_ms_add	include/common/time.h	464;"	d
tv_ms_cmp	include/common/time.h	/^REGPRM2 int tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
tv_ms_cmp	include/common/time.h	247;"	d
tv_ms_cmp2	include/common/time.h	/^REGPRM2 int tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2);$/;"	p	signature:(const struct timeval *tv1, const struct timeval *tv2)
tv_ms_cmp2	include/common/time.h	275;"	d
tv_ms_elapsed	include/common/time.h	327;"	d
tv_ms_le2	include/common/time.h	295;"	d
tv_ms_remain	include/common/time.h	344;"	d
tv_ms_remain2	include/common/time.h	359;"	d
tv_now	include/common/time.h	/^REGPRM1 static inline struct timeval *tv_now(struct timeval *tv)$/;"	f	signature:(struct timeval *tv)
tv_offset	src/time.c	/^	static struct timeval tv_offset; \/* warning: signed offset! *\/$/;"	l	file:
tv_remain	include/common/time.h	424;"	d
tv_remain2	include/common/time.h	451;"	d
tv_request	include/types/session.h	/^		struct timeval tv_request;	\/* date the request arrives, {0,0} if never occurs *\/$/;"	m	struct:session::__anon8	typeref:struct:session::__anon8::timeval	access:public
tv_update_date	include/common/time.h	/^REGPRM2 void tv_update_date(int max_wait, int interrupted);$/;"	p	signature:(int max_wait, int interrupted)
tv_update_date	src/time.c	/^REGPRM2 void tv_update_date(int max_wait, int interrupted)$/;"	f	signature:(int max_wait, int interrupted)
tv_zero	include/common/time.h	/^REGPRM1 static inline struct timeval *tv_zero(struct timeval *tv) {$/;"	f	signature:(struct timeval *tv)
tvsec	src/log.c	/^	static long tvsec = -1;	\/* to force the string to be initialized *\/$/;"	l	file:
txn	include/types/session.h	/^	struct http_txn txn;			\/* current HTTP transaction being processed. Should become a list. *\/$/;"	m	struct:session	typeref:struct:session::http_txn	access:public
txn	src/backend.c	/^	struct http_txn *txn  = &s->txn;$/;"	l
txn	src/client.c	/^	struct http_txn *txn;$/;"	l
txn	src/proto_http.c	/^	struct http_txn *txn = &s->txn;$/;"	l
txn	src/proto_http.c	/^	struct http_txn *txn = &t->txn;$/;"	l
txn	src/proto_http.c	/^	struct http_txn *txn = l7;$/;"	l
txn	src/proto_http.c	/^	struct http_txn *txn;$/;"	l
txn	src/session.c	/^	struct http_txn *txn = &s->txn;$/;"	l
type	include/types/pattern.h	/^	int type;                 \/* current type of data *\/$/;"	m	struct:pattern	access:public
type	include/types/proxy.h	/^	int type;$/;"	m	struct:persist_rule	access:public
type	include/types/proxy.h	/^	int type;$/;"	m	struct:redirect_rule	access:public
type	include/types/session.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:session::__anon9::__anon10	access:public
type	include/types/stick_table.h	/^	unsigned long type;       \/* type of table (determine key format) *\/$/;"	m	struct:stktable	access:public
type	src/cfgparse.c	/^		int type = REDIRECT_TYPE_NONE;$/;"	l
u	include/types/auth.h	/^	} u;$/;"	m	struct:auth_users	typeref:union:auth_users::__anon28	access:public
u	include/types/log.h	/^	} u;$/;"	m	struct:logsrv	typeref:union:logsrv::__anon1	access:public
u	include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
u	src/auth.c	/^	struct auth_users *u;$/;"	l
u	src/cfgparse.c	/^			int u;$/;"	l
u	src/uri_auth.c	/^	struct uri_auth *u;$/;"	l
u32	ebtree/eb32tree.h	/^typedef unsigned int u32;$/;"	t
u32	include/common/epoll.h	/^		uint32_t u32;$/;"	m	union:epoll_event::__anon65	access:public
u64	ebtree/eb64tree.h	/^typedef unsigned long long u64;$/;"	t
u64	include/common/epoll.h	/^		uint64_t u64;$/;"	m	union:epoll_event::__anon65	access:public
u_int32_t	tests/uri_hash.c	/^typedef unsigned int u_int32_t;$/;"	t	file:
u_l	include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
ua	src/haproxy.c	/^	struct uri_auth *uap, *ua = NULL;$/;"	l
uap	src/haproxy.c	/^	struct uri_auth *uap, *ua = NULL;$/;"	l
ub1	tests/test_hashes.c	/^typedef  unsigned       char ub1;   \/* unsigned 1-byte quantities *\/$/;"	t	file:
ub4	tests/test_hashes.c	/^typedef  unsigned long  int  ub4;   \/* unsigned 4-byte quantities *\/$/;"	t	file:
uid	include/types/global.h	/^	int uid;$/;"	m	struct:global	access:public
uid	include/types/protocols.h	/^			uid_t uid;	\/* -1 to leave unchanged *\/$/;"	m	struct:listener::__anon23::__anon24	access:public
uid	include/types/session.h	/^			unsigned int uid;	\/* if non-null, the uniq_id of the session being dumped *\/$/;"	m	struct:session::__anon9::__anon11	access:public
ul	include/types/acl.h	/^		struct userlist *ul;$/;"	m	union:acl_expr::__anon54	typeref:struct:acl_expr::__anon54::userlist	access:public
ul	src/acl.c	/^	struct userlist *ul;$/;"	l
ul	src/auth.c	/^	struct userlist *ul = test->ctx.a[0];$/;"	l
ulltoh_r	include/common/standard.h	/^extern const char *ulltoh_r(unsigned long long n, char *buffer, int size);$/;"	p	signature:(unsigned long long n, char *buffer, int size)
ulltoh_r	src/standard.c	/^const char *ulltoh_r(unsigned long long n, char *buffer, int size)$/;"	f	signature:(unsigned long long n, char *buffer, int size)
ultoa	include/common/standard.h	/^static inline const char *ultoa(unsigned long n)$/;"	f	signature:(unsigned long n)
ultoa_r	include/common/standard.h	/^extern char *ultoa_r(unsigned long n, char *buffer, int size);$/;"	p	signature:(unsigned long n, char *buffer, int size)
ultoa_r	src/standard.c	/^char *ultoa_r(unsigned long n, char *buffer, int size)$/;"	f	signature:(unsigned long n, char *buffer, int size)
un	include/types/log.h	/^		struct sockaddr_un un;	\/* AF_UNIX *\/$/;"	m	union:logsrv::__anon1	typeref:struct:logsrv::__anon1::sockaddr_un	access:public
unbind_all	include/types/protocols.h	/^	int (*unbind_all)(struct protocol *proto);	\/* unbind all bound listeners *\/$/;"	m	struct:protocol	access:public
unbind_all_listeners	include/proto/protocols.h	/^int unbind_all_listeners(struct protocol *proto);$/;"	p	signature:(struct protocol *proto)
unbind_all_listeners	src/protocols.c	/^int unbind_all_listeners(struct protocol *proto)$/;"	f	signature:(struct protocol *proto)
unbind_listener	include/proto/protocols.h	/^int unbind_listener(struct listener *listener);$/;"	p	signature:(struct listener *listener)
unbind_listener	src/protocols.c	/^		unbind_listener(listener);$/;"	p	file:
unbind_listener	src/protocols.c	/^int unbind_listener(struct listener *listener)$/;"	f	signature:(struct listener *listener)
uncle	src/rbtree.c	/^				register struct rb_node *uncle = gparent->rb_left;$/;"	l
uncle	src/rbtree.c	/^				register struct rb_node *uncle = gparent->rb_right;$/;"	l
uniq_id	include/types/session.h	/^	unsigned int uniq_id;			\/* unique ID used for the traces *\/$/;"	m	struct:session	access:public
unlikely	include/common/compiler.h	102;"	d
unlikely	include/common/compiler.h	91;"	d
unlikely	include/common/compiler.h	95;"	d
up	src/dumpstats.c	/^	unsigned int up;$/;"	l
up_ptr	ebtree/eb32tree.h	/^	eb_troot_t *troot, **up_ptr;$/;"	l
up_ptr	ebtree/ebmbtree.h	/^	eb_troot_t *troot, **up_ptr;$/;"	l
update	include/types/stream_interface.h	/^	void (*update)(struct stream_interface *); \/* I\/O update function *\/$/;"	m	struct:stream_interface	access:public
update	src/dumpstats.c	/^	si->update(si);$/;"	p	file:
update_backend_weight	include/proto/backend.h	/^void update_backend_weight(struct proxy *px);$/;"	p	signature:(struct proxy *px)
update_backend_weight	src/backend.c	/^void update_backend_weight(struct proxy *px)$/;"	f	signature:(struct proxy *px)
update_freq_ctr	include/proto/freq_ctr.h	/^static inline void update_freq_ctr(struct freq_ctr *ctr, unsigned int inc)$/;"	f	signature:(struct freq_ctr *ctr, unsigned int inc)
update_position	tests/filltab25.c	/^void update_position(struct srv *s) {$/;"	f	signature:(struct srv *s)
update_server_eweight	include/types/backend.h	/^	void (*update_server_eweight)(struct server *);  \/* to be called after eweight change *\/$/;"	m	struct:lbprm	access:public
update_server_eweight	src/checks.c	/^						s->proxy->lbprm.update_server_eweight(s);$/;"	p	file:
update_server_eweight	src/checks.c	/^					s->proxy->lbprm.update_server_eweight(s);$/;"	p	file:
update_server_eweight	src/dumpstats.c	/^				px->lbprm.update_server_eweight(sv);$/;"	p	file:
uri	include/types/proto_http.h	/^	char *uri;                      \/* first line if log needed, NULL otherwise *\/$/;"	m	struct:http_txn	access:public
uri	src/proto_http.c	/^	char *uri, *h;$/;"	l
uri_auth	include/common/uri_auth.h	/^struct uri_auth {$/;"	s
uri_auth	include/types/proxy.h	/^	struct uri_auth *uri_auth;		\/* if non-NULL, the (list of) per-URI authentications *\/$/;"	m	struct:proxy	typeref:struct:proxy::uri_auth	access:public
uri_auth	src/proto_http.c	/^	struct uri_auth *uri_auth = backend->uri_auth;$/;"	l
uri_auth::admin_rules	include/common/uri_auth.h	/^	struct list admin_rules;	\/* 'stats admin' rules (chained) *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list	access:public
uri_auth::auth_realm	include/common/uri_auth.h	/^	char *auth_realm;		\/* the realm reported to the client *\/$/;"	m	struct:uri_auth	access:public
uri_auth::desc	include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth	access:public
uri_auth::flags	include/common/uri_auth.h	/^	int flags;			\/* some flags describing the statistics page *\/$/;"	m	struct:uri_auth	access:public
uri_auth::next	include/common/uri_auth.h	/^	struct uri_auth *next;		\/* Used at deinit() to build a list of unique elements *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::uri_auth	access:public
uri_auth::node	include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth	access:public
uri_auth::refresh	include/common/uri_auth.h	/^	int refresh;			\/* refresh interval for the browser (in seconds) *\/$/;"	m	struct:uri_auth	access:public
uri_auth::req_acl	include/common/uri_auth.h	/^	struct list req_acl; 		\/* http stats ACL: allow\/deny\/auth *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list	access:public
uri_auth::scope	include/common/uri_auth.h	/^	struct stat_scope *scope;	\/* linked list of authorized proxies *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::stat_scope	access:public
uri_auth::uri_len	include/common/uri_auth.h	/^	int uri_len;			\/* the prefix length *\/$/;"	m	struct:uri_auth	access:public
uri_auth::uri_prefix	include/common/uri_auth.h	/^	char *uri_prefix;		\/* the prefix we want to match *\/$/;"	m	struct:uri_auth	access:public
uri_auth::userlist	include/common/uri_auth.h	/^	struct userlist *userlist;	\/* private userlist to emulate legacy "stats auth user:password" *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::userlist	access:public
uri_auth_compat_req	src/cfgparse.c	/^			const char *uri_auth_compat_req[10];$/;"	l
uri_copy	src/uri_auth.c	/^	char *uri_copy;$/;"	l
uri_dirs_depth1	include/types/proxy.h	/^	int  uri_dirs_depth1;			\/* directories+1 (slashes) limit for uri balancing algorithm *\/$/;"	m	struct:proxy	access:public
uri_len	include/common/uri_auth.h	/^	int uri_len;			\/* the prefix length *\/$/;"	m	struct:uri_auth	access:public
uri_len	src/uri_auth.c	/^	int uri_len;$/;"	l
uri_len_limit	include/types/proxy.h	/^	int  uri_len_limit;			\/* character limit for uri balancing algorithm *\/$/;"	m	struct:proxy	access:public
uri_prefix	include/common/uri_auth.h	/^	char *uri_prefix;		\/* the prefix we want to match *\/$/;"	m	struct:uri_auth	access:public
urilen	src/proto_http.c	/^			int urilen = msg->sl.rq.l;$/;"	l
url	contrib/halog/halog.c	/^		struct ebpt_node url;$/;"	m	union:url_stat::__anon67	typeref:struct:url_stat::__anon67::ebpt_node	file:	access:public
url	contrib/halog/halog.c	/^	char *url;$/;"	m	struct:url_stat	file:	access:public
url2ip	include/common/standard.h	/^int url2ip(const char *addr, struct in_addr *dst);$/;"	p	signature:(const char *addr, struct in_addr *dst)
url2ip	src/standard.c	/^int url2ip(const char *addr, struct in_addr *dst)$/;"	f	signature:(const char *addr, struct in_addr *dst)
url2sa	include/common/standard.h	/^int url2sa(const char *url, int ulen, struct sockaddr_in *addr);$/;"	p	signature:(const char *url, int ulen, struct sockaddr_in *addr)
url2sa	src/standard.c	/^int url2sa(const char *url, int ulen, struct sockaddr_in *addr)$/;"	f	signature:(const char *url, int ulen, struct sockaddr_in *addr)
url_code	src/standard.c	/^	int ret, url_code = 0;$/;"	l
url_encode_map	src/proto_http.c	/^fd_set url_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
url_param_len	include/types/proxy.h	/^	int  url_param_len;			\/* strlen(url_param_name), computed only once *\/$/;"	m	struct:proxy	access:public
url_param_name	include/types/proxy.h	/^	char *url_param_name;			\/* name of the URL parameter used for hashing *\/$/;"	m	struct:proxy	access:public
url_param_post_limit	include/types/proxy.h	/^	unsigned url_param_post_limit;		\/* if checking POST body for URI parameter, max body to wait for *\/$/;"	m	struct:proxy	access:public
url_stat	contrib/halog/halog.c	/^struct url_stat {$/;"	s	file:
url_stat::__anon67::url	contrib/halog/halog.c	/^		struct ebpt_node url;$/;"	m	union:url_stat::__anon67	typeref:struct:url_stat::__anon67::ebpt_node	file:	access:public
url_stat::__anon67::val	contrib/halog/halog.c	/^		struct eb64_node val;$/;"	m	union:url_stat::__anon67	typeref:struct:url_stat::__anon67::eb64_node	file:	access:public
url_stat::nb_err	contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:	access:public
url_stat::nb_req	contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:	access:public
url_stat::node	contrib/halog/halog.c	/^	} node;$/;"	m	struct:url_stat	typeref:union:url_stat::__anon67	file:	access:public
url_stat::total_time	contrib/halog/halog.c	/^	unsigned long long total_time;    \/* sum(all reqs' times) *\/$/;"	m	struct:url_stat	file:	access:public
url_stat::total_time_ok	contrib/halog/halog.c	/^	unsigned long long total_time_ok; \/* sum(all OK reqs' times) *\/$/;"	m	struct:url_stat	file:	access:public
url_stat::url	contrib/halog/halog.c	/^	char *url;$/;"	m	struct:url_stat	file:	access:public
urls	tests/test_hashes.c	/^  char *urls[] = {$/;"	l
usable	src/fd.c	/^	int usable;$/;"	l
usage	src/haproxy.c	/^void usage(char *name)$/;"	f	signature:(char *name)
use_close_only	src/proto_http.c	/^	int use_close_only;$/;"	l
use_cnt	include/types/acl.h	/^	int use_cnt;$/;"	m	struct:acl_keyword	access:public
used	include/common/memory.h	/^	unsigned int used;	\/* how many chunks are currently in use *\/$/;"	m	struct:pool_head	access:public
used	include/types/hdr_idx.h	/^	short used;                 \/* # of elements really used (1..size) *\/$/;"	m	struct:hdr_idx	access:public
used	src/memory.c	/^	unsigned long allocated, used;$/;"	l
used	src/standard.c	/^	struct eb32_node *used;$/;"	l
used_listener_id	include/types/proxy.h	/^		struct eb_root used_listener_id;\/* list of listener IDs in use *\/$/;"	m	struct:proxy::__anon20	typeref:struct:proxy::__anon20::eb_root	access:public
used_proxy_id	include/types/proxy.h	/^extern struct eb_root used_proxy_id;	\/* list of proxy IDs in use *\/$/;"	x
used_proxy_id	src/proxy.c	/^struct eb_root used_proxy_id = EB_ROOT;	\/* list of proxy IDs in use *\/$/;"	v	typeref:struct:eb_root
used_server_id	include/types/proxy.h	/^		struct eb_root used_server_id;	\/* list of server IDs in use *\/$/;"	m	struct:proxy::__anon20	typeref:struct:proxy::__anon20::eb_root	access:public
user	include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users	access:public
user	include/types/proto_http.h	/^	char *user, *pass;		\/* extracted username & password *\/$/;"	m	struct:http_auth_data	access:public
user	src/auth.c	/^	char *user = test->ctx.a[1];$/;"	l
user	src/cfgparse.c	/^			char *user = NULL;$/;"	l
user	src/dumpstats.c	/^				struct passwd *user;$/;"	l
userlen	src/cfgparse.c	/^						int packetlen, reqlen, userlen;$/;"	l
userlist	include/common/uri_auth.h	/^	struct userlist *userlist;	\/* private userlist to emulate legacy "stats auth user:password" *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::userlist	access:public
userlist	include/proto/auth.h	/^extern struct userlist *userlist;$/;"	x
userlist	include/types/auth.h	/^struct userlist {$/;"	s
userlist	src/auth.c	/^struct userlist *userlist = NULL;    \/* list of all existing userlists *\/$/;"	v	typeref:struct:userlist
userlist::groups	include/types/auth.h	/^	char *groups[MAX_AUTH_GROUPS];$/;"	m	struct:userlist	access:public
userlist::groupusers	include/types/auth.h	/^	char **groupusers;$/;"	m	struct:userlist	access:public
userlist::grpcnt	include/types/auth.h	/^	int grpcnt;$/;"	m	struct:userlist	access:public
userlist::name	include/types/auth.h	/^	char *name;$/;"	m	struct:userlist	access:public
userlist::next	include/types/auth.h	/^	struct userlist *next;$/;"	m	struct:userlist	typeref:struct:userlist::userlist	access:public
userlist::users	include/types/auth.h	/^	struct auth_users *users;$/;"	m	struct:userlist	typeref:struct:userlist::auth_users	access:public
userlist_free	include/proto/auth.h	/^void userlist_free(struct userlist *ul);$/;"	p	signature:(struct userlist *ul)
userlist_free	src/auth.c	/^userlist_free(struct userlist *ul)$/;"	f	signature:(struct userlist *ul)
users	include/common/memory.h	/^	unsigned int users;	\/* number of pools sharing this zone *\/$/;"	m	struct:pool_head	access:public
users	include/common/mini-clist.h	/^	struct list users;$/;"	m	struct:bref	typeref:struct:bref::list	access:public
users	include/types/auth.h	/^	struct auth_users *users;$/;"	m	struct:userlist	typeref:struct:userlist::auth_users	access:public
ustat	contrib/halog/halog.c	/^	struct url_stat *ustat = NULL;$/;"	l
ustat_old	contrib/halog/halog.c	/^				struct url_stat *ustat_old;$/;"	l
uuid	include/types/proxy.h	/^	int uuid;				\/* universally unique proxy ID, used for SNMP *\/$/;"	m	struct:proxy	access:public
uweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server	access:public
ux	include/types/protocols.h	/^		} ux;$/;"	m	union:listener::__anon23	typeref:struct:listener::__anon23::__anon24	access:public
uxst_add_listener	include/proto/proto_uxst.h	/^void uxst_add_listener(struct listener *listener);$/;"	p	signature:(struct listener *listener)
uxst_add_listener	src/proto_uxst.c	/^void uxst_add_listener(struct listener *listener)$/;"	f	signature:(struct listener *listener)
uxst_bind_listener	src/proto_uxst.c	/^static int uxst_bind_listener(struct listener *listener)$/;"	f	file:	signature:(struct listener *listener)
uxst_bind_listeners	src/proto_uxst.c	/^static int uxst_bind_listeners(struct protocol *proto)$/;"	f	file:	signature:(struct protocol *proto)
uxst_bind_listeners	src/proto_uxst.c	/^static int uxst_bind_listeners(struct protocol *proto);$/;"	p	file:	signature:(struct protocol *proto)
uxst_event_accept	include/proto/proto_uxst.h	/^int uxst_event_accept(int fd);$/;"	p	signature:(int fd)
uxst_event_accept	src/proto_uxst.c	/^int uxst_event_accept(int fd) {$/;"	f	signature:(int fd)
uxst_req_analyser_stats	include/proto/proto_uxst.h	/^int uxst_req_analyser_stats(struct session *s, struct buffer *req, int an_bit);$/;"	p	signature:(struct session *s, struct buffer *req, int an_bit)
uxst_unbind_listener	src/proto_uxst.c	/^		uxst_unbind_listener(listener);$/;"	p	file:
uxst_unbind_listener	src/proto_uxst.c	/^static int uxst_unbind_listener(struct listener *listener)$/;"	f	file:	signature:(struct listener *listener)
uxst_unbind_listeners	src/proto_uxst.c	/^static int uxst_unbind_listeners(struct protocol *proto)$/;"	f	file:	signature:(struct protocol *proto)
uxst_unbind_listeners	src/proto_uxst.c	/^static int uxst_unbind_listeners(struct protocol *proto);$/;"	p	file:	signature:(struct protocol *proto)
v	contrib/halog/halog.c	/^					int v;$/;"	l
v	include/import/ip_tproxy.h	/^	} v;$/;"	m	struct:in_tproxy	typeref:union:in_tproxy::_in_args	access:public
v	include/types/hdr_idx.h	/^	struct hdr_idx_elem *v;     \/* the array itself *\/$/;"	m	struct:hdr_idx	typeref:struct:hdr_idx::hdr_idx_elem	access:public
v	include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
v	src/lb_map.c	/^				int v;$/;"	l
v_l	include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon36::__anon37	access:public
v_l	include/types/proto_http.h	/^			int v_l;               \/* VERSION length (version starts at ->som) *\/$/;"	m	struct:http_msg::__anon36::__anon38	access:public
val	contrib/halog/halog.c	/^			int val;$/;"	l
val	contrib/halog/halog.c	/^		struct eb64_node val;$/;"	m	union:url_stat::__anon67	typeref:struct:url_stat::__anon67::eb64_node	file:	access:public
val	contrib/halog/halog.c	/^	int val, test;$/;"	l
val	include/types/acl.h	/^	} val;                                  \/* direct value *\/$/;"	m	struct:acl_pattern	typeref:union:acl_pattern::__anon49	access:public
val	include/types/proto_http.h	/^	int  val;  \/* relative to line *\/$/;"	m	struct:hdr_ctx	access:public
val	src/cfgparse.c	/^	unsigned int val;$/;"	m	struct:cfg_opt	file:	access:public
val	src/cfgparse.c	/^	unsigned val;$/;"	l
val	src/pattern.c	/^		uint32_t val = data->str.str[i] - '0';$/;"	l
val	src/pattern.c	/^		uint32_t val = pdata->str.str[i] - '0';$/;"	l
val	src/proto_http.c	/^						int val;$/;"	l
val	src/proto_http.c	/^		int val;$/;"	l
val	src/proto_http.c	/^	const char *val;$/;"	l
val	src/proto_tcp.c	/^	unsigned int val;$/;"	l
val	src/proxy.c	/^	unsigned int val;$/;"	l
val	tests/test_hashes.c	/^  unsigned int        val;$/;"	l
val	tests/uri_hash.c	/^    unsigned long data, val;$/;"	l
val_beg	src/proto_http.c	/^	char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;$/;"	l
val_end	src/proto_http.c	/^	char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;$/;"	l
value	src/proto_http.c	/^		char *key, *value;$/;"	l
value	src/standard.c	/^	unsigned value = 0;$/;"	l
value	src/standard.c	/^	unsigned value;$/;"	l
value_begin	src/proto_http.c	/^				char *value_begin;$/;"	l
value_len	src/proto_http.c	/^				int cmp_len, value_len;$/;"	l
value_len	src/proto_http.c	/^	int value_len;$/;"	l
vbar1	src/proto_http.c	/^					char *vbar1;$/;"	l
version	include/import/ip_tproxy.h	/^		u_int32_t		version;$/;"	m	union:in_tproxy::_in_args	access:public
version	src/proto_tcp.c	/^	int version, bleft, msg_len;$/;"	l
vlen	include/types/proto_http.h	/^	int  vlen; \/* relative to line+val *\/$/;"	m	struct:hdr_ctx	access:public
w	include/types/buffers.h	/^	char *r, *w, *lr;               \/* read ptr, write ptr, last read *\/$/;"	m	struct:buffer	access:public
w	src/cfgparse.c	/^				int w;$/;"	l
w	src/dumpstats.c	/^			int w;$/;"	l
w	src/haproxy.c	/^		struct timeval w;$/;"	l
w	src/lb_map.c	/^			int w = srv->uweight;$/;"	l
w	src/proto_http.c	/^	size_t w;$/;"	l
w	tests/filltab25.c	/^				int w = i + 1;$/;"	l
w	tests/filltab25.c	/^			int w = \/*20*\/\/**\/random()%4096\/**\/;$/;"	l
w	tests/filltab25.c	/^	int w; \/* weight *\/$/;"	m	struct:srv	file:	access:public
wait	src/freq_ctr.c	/^	unsigned int wait, age;$/;"	l
wait	src/proxy.c	/^	unsigned int wait;$/;"	l
wait_time	src/ev_epoll.c	/^	int wait_time;$/;"	l
wait_time	src/ev_poll.c	/^	int wait_time;$/;"	l
wait_time	src/ev_sepoll.c	/^	int wait_time;$/;"	l
wake_expired_tasks	include/proto/task.h	/^void wake_expired_tasks(int *next);$/;"	p	signature:(int *next)
wake_expired_tasks	src/task.c	/^void wake_expired_tasks(int *next)$/;"	f	signature:(int *next)
want_flags	src/proto_http.c	/^			unsigned int want_flags = 0;$/;"	l
want_flags	src/proto_http.c	/^		unsigned int want_flags = 0;$/;"	l
warn	src/proto_tcp.c	/^		int warn = 0;$/;"	l
warnif_cond_requires_req	src/cfgparse.c	/^static int warnif_cond_requires_req(const struct acl_cond *cond, const char *file, int line)$/;"	f	file:	signature:(const struct acl_cond *cond, const char *file, int line)
warnif_cond_requires_resp	src/cfgparse.c	/^static int warnif_cond_requires_resp(const struct acl_cond *cond, const char *file, int line)$/;"	f	file:	signature:(const struct acl_cond *cond, const char *file, int line)
warnif_misplaced_block	src/cfgparse.c	/^int warnif_misplaced_block(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f	signature:(struct proxy *proxy, const char *file, int line, const char *arg)
warnif_misplaced_reqadd	src/cfgparse.c	/^int warnif_misplaced_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f	signature:(struct proxy *proxy, const char *file, int line, const char *arg)
warnif_misplaced_reqxxx	src/cfgparse.c	/^int warnif_misplaced_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f	signature:(struct proxy *proxy, const char *file, int line, const char *arg)
warnif_rule_after_block	src/cfgparse.c	/^int warnif_rule_after_block(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f	signature:(struct proxy *proxy, const char *file, int line, const char *arg)
warnif_rule_after_redirect	src/cfgparse.c	/^int warnif_rule_after_redirect(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f	signature:(struct proxy *proxy, const char *file, int line, const char *arg)
warnif_rule_after_reqadd	src/cfgparse.c	/^int warnif_rule_after_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f	signature:(struct proxy *proxy, const char *file, int line, const char *arg)
warnif_rule_after_reqxxx	src/cfgparse.c	/^int warnif_rule_after_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f	signature:(struct proxy *proxy, const char *file, int line, const char *arg)
warnif_rule_after_use_backend	src/cfgparse.c	/^int warnif_rule_after_use_backend(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f	signature:(struct proxy *proxy, const char *file, int line, const char *arg)
warnifnotcap	src/cfgparse.c	/^int warnifnotcap(struct proxy *proxy, int cap, const char *file, int line, const char *arg, const char *hint)$/;"	f	signature:(struct proxy *proxy, int cap, const char *file, int line, const char *arg, const char *hint)
wdiv	include/types/backend.h	/^	int wdiv;			\/* ratio between effective weight and user weight *\/$/;"	m	struct:lbprm	access:public
wex	include/types/buffers.h	/^	int wex;                        \/* expiration date for a write or connect, in ticks *\/$/;"	m	struct:buffer	access:public
when	include/types/proxy.h	/^	struct timeval when;		\/* date of this event, (tv_sec == 0) means "never" *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::timeval	access:public
while_dlist_item	include/common/mini-clist.h	103;"	d
wl	src/cfgparse.c	/^		struct cond_wordlist *wl;$/;"	l
wl	src/haproxy.c	/^	struct wordlist *wl, *wlb;$/;"	l
wl	src/haproxy.c	/^	struct wordlist *wl;$/;"	l
wl	src/proto_http.c	/^	struct cond_wordlist *wl;$/;"	l
wlb	src/haproxy.c	/^	struct wordlist *wl, *wlb;$/;"	l
wmult	include/types/backend.h	/^	int wmult;			\/* ratio between user weight and effective weight *\/$/;"	m	struct:lbprm	access:public
wn	src/ev_poll.c	/^	unsigned rn, wn; \/* read new, write new *\/$/;"	l
word	src/acl.c	/^	const char *word;$/;"	l
word_match	include/common/standard.h	/^int word_match(const char *sample, int slen, const char *word, int wlen);$/;"	p	signature:(const char *sample, int slen, const char *word, int wlen)
word_match	src/standard.c	/^int word_match(const char *sample, int slen, const char *word, int wlen)$/;"	f	signature:(const char *sample, int slen, const char *word, int wlen)
wordlist	include/common/mini-clist.h	/^struct wordlist {$/;"	s
wordlist::list	include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:wordlist	typeref:struct:wordlist::list	access:public
wordlist::s	include/common/mini-clist.h	/^	char *s;$/;"	m	struct:wordlist	access:public
wq	include/types/task.h	/^	struct eb32_node wq;		\/* ebtree node used to hold the task in the wait queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node	access:public
write	include/types/protocols.h	/^	int (*write)(int fd);				\/* generic write function *\/$/;"	m	struct:protocol	access:public
write_poll	src/stream_sock.c	/^	int write_poll = MAX_WRITE_POLL_LOOPS;$/;"	l
writenotnull	src/ev_select.c	/^	int readnotnull, writenotnull;$/;"	l
wscore	include/types/server.h	/^	unsigned wscore;			\/* weight score, used during srv map computation *\/$/;"	m	struct:server	access:public
wt_hash	tests/test_hashes.c	/^unsigned wt_hash ( void *key, int len )$/;"	f	signature:( void *key, int len )
wto	include/types/buffers.h	/^	int wto;                        \/* write timeout, in ticks *\/$/;"	m	struct:buffer	access:public
x1F	ebtree/eb64tree.h	/^			side >>= old_node_bit & 0x1F;$/;"	l
xfer_large	include/types/buffers.h	/^	unsigned char xfer_large;       \/* number of consecutive large xfers *\/$/;"	m	struct:buffer	access:public
xfer_small	include/types/buffers.h	/^	unsigned char xfer_small;       \/* number of consecutive small xfers *\/$/;"	m	struct:buffer	access:public
xferred	src/checks.c	/^	int xferred = 0;$/;"	l
xferred	src/checks.c	/^	int xferred;$/;"	l
y	contrib/halog/fgets2-64.c	/^	unsigned int y;$/;"	l
y	contrib/halog/fgets2-64.c	/^	unsigned long long y;$/;"	l
y	contrib/halog/fgets2.c	/^	unsigned int y;$/;"	l
y	ebtree/eb32tree.h	/^	u32 y;$/;"	l
y	ebtree/eb64tree.h	/^	u64 y;$/;"	l
zero	include/types/global.h	/^extern const int zero;$/;"	x
zero	src/haproxy.c	/^const int zero = 0;$/;"	v
